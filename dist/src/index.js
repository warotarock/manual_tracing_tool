(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const index = "";
const custombox_min = "";
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n = 60103, p = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q = 60109, r$1 = 60110, t = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  n = w("react.element");
  p = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q = w("react.provider");
  r$1 = w("react.context");
  t = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}
var x = "function" === typeof Symbol && Symbol.iterator;
function y$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$1 = {};
function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C.prototype;
function E$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
var F$1 = E$1.prototype = new D$1();
F$1.constructor = E$1;
l(F$1, C.prototype);
F$1.isPureReactComponent = true;
var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
function J(a, b, c) {
  var e, d = {}, k = null, h = null;
  if (null != b)
    for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
      H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);
  var g = arguments.length - 2;
  if (1 === g)
    d.children = c;
  else if (1 < g) {
    for (var f = Array(g), m2 = 0; m2 < g; m2++)
      f[m2] = arguments[m2 + 2];
    d.children = f;
  }
  if (a && a.defaultProps)
    for (e in g = a.defaultProps, g)
      void 0 === d[e] && (d[e] = g[e]);
  return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return "object" === typeof a && null !== a && a.$$typeof === n;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e, d) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k)
    a = null;
  var h = false;
  if (null === a)
    h = true;
  else
    switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n:
          case p:
            h = true;
        }
    }
  if (h)
    return h = a, d = d(h), a = "" === e ? "." + N$1(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = "" === e ? "." : e + ":";
  if (Array.isArray(a))
    for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N$1(k, g);
      h += O$1(k, b, c, f, d);
    }
  else if (f = y$1(a), "function" === typeof f)
    for (a = f.call(a), g = 0; !(k = a.next()).done; )
      k = k.value, f = e + N$1(k, g++), h += O$1(k, b, c, f, d);
  else if ("object" === k)
    throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}
function P$1(a, b, c) {
  if (null == a)
    return a;
  var e = [], d = 0;
  O$1(a, e, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e;
}
function Q(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      0 === a._status && (a._status = 2, a._result = b2);
    });
  }
  if (1 === a._status)
    return a._result;
  throw a._result;
}
var R$1 = { current: null };
function S$1() {
  var a = R$1.current;
  if (null === a)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (null === a || void 0 === a)
    throw Error(z(267, a));
  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = G$1.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f in b)
      H$1.call(b, f) && !I$1.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (1 === f)
    e.children = c;
  else if (1 < f) {
    g = Array(f);
    for (var m2 = 0; m2 < f; m2++)
      g[m2] = arguments[m2 + 2];
    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};
react_production_min.createContext = function(a, b) {
  void 0 === b && (b = null);
  a = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
(function(module) {
  {
    module.exports = react_production_min;
  }
})(react);
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f, g, h, k;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w = function() {
      if (null !== t2)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w, 0), b;
        }
    };
    f = function(a) {
      null !== t2 ? setTimeout(f, 0, a) : (t2 = a, setTimeout(w, 0));
    };
    g = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E;
    };
    k = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a = exports.unstable_now();
        E = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g = function(a, b) {
      C2 = x2(function() {
        a(exports.unstable_now());
      }, b);
    };
    h = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (void 0 !== e && 0 < I2(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return void 0 === a ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (void 0 !== b) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length; d < e; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (void 0 !== n2 && 0 > I2(n2, c))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); null !== b; ) {
      if (null === b.callback)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f(V2);
      else {
        var b = J2(M2);
        null !== b && g(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
        var d = O2.callback;
        if ("function" === typeof d) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e = d(O2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? O2.callback = e : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), null === J2(L2) && a === J2(M2) && (S2 ? h() : S2 = true, g(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
(function(module) {
  {
    module.exports = scheduler_production_min;
  }
})(scheduler);
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m = objectAssign, r = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (null === b || "undefined" === typeof b || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    oa,
    pa
  );
  D[b] = new B(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
  f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;
function La(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var Ma;
function Na(a) {
  if (void 0 === Ma)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && "string" === typeof k.stack) {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
        h--;
      for (; 1 <= g && 0 <= h; g--, h--)
        if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h])
                return "\n" + e[g].replace(" at new ", " at ");
            while (1 <= g && 0 <= h);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get, f = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function $a(a, b) {
  b = b.checked;
  null != b && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function bb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    null != a2 && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML)
    throw Error(y(91));
  return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
      throw Error(y(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children)
        throw Error(y(60));
      if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (null != b.style && "object" !== typeof b.style)
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e, f, g, h, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function $b(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b)
      return b.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (null === b)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (null === e)
      break;
    var f = e.alternate;
    if (null === f) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f; ) {
        if (f === c)
          return ac(e), a;
        if (f === d)
          return ac(e), b;
        f = f.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e, d = f;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h; ) {
          if (h === c) {
            g = true;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (3 !== c.tag)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (5 === b.tag || 6 === b.tag)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; null !== b; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}
function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f)
    return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), true;
    case "pointerover":
      var f = e.pointerId;
      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (null !== b) {
    var c = Zb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = $b(c), null !== b) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (3 === b && c.stateNode.hydrate) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null !== c)
      return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (null !== a.blockedOn) {
      a = Cb(a.blockedOn);
      null !== a && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null !== c) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    null === a.blockedOn && jc.shift();
  }
  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== kc && Bc(kc, a);
  null !== lc && Bc(lc, a);
  null !== mc && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
    vc(c), null === c.blockedOn && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}
var Qc = r.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if (0 !== (1 & a))
    return F = 15, 1;
  if (0 !== (2 & a))
    return F = 14, 2;
  if (0 !== (4 & a))
    return F = 13, 4;
  var b = 24 & a;
  if (0 !== b)
    return F = 12, b;
  if (0 !== (a & 32))
    return F = 11, 32;
  b = 192 & a;
  if (0 !== b)
    return F = 10, b;
  if (0 !== (a & 256))
    return F = 9, 256;
  b = 3584 & a;
  if (0 !== b)
    return F = 8, b;
  if (0 !== (a & 4096))
    return F = 7, 4096;
  b = 4186112 & a;
  if (0 !== b)
    return F = 6, b;
  b = 62914560 & a;
  if (0 !== b)
    return F = 5, b;
  if (a & 67108864)
    return F = 4, 67108864;
  if (0 !== (a & 134217728))
    return F = 3, 134217728;
  b = 805306368 & a;
  if (0 !== b)
    return F = 2, b;
  if (0 !== (1073741824 & a))
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c)
    return F = 0;
  var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
  if (0 !== f)
    d = f, e = F = 15;
  else if (f = c & 134217727, 0 !== f) {
    var k = f & ~g;
    0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
  } else
    f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
  if (0 === d)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (0 !== b && b !== d && 0 === (b & g)) {
    Rc(b);
    if (e <= F)
      return b;
    F = e;
  }
  b = a.entangledLanes;
  if (0 !== b)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd, f = Kb;
  Kb = true;
  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}
function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f = yc(a, b, c, d);
      if (null === f)
        e && sc(a, d);
      else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f, a, b, c, d))
            return;
          sc(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);
  if (null !== e) {
    var f = Zb(e);
    if (null === f)
      e = null;
    else {
      var g = f.tag;
      if (13 === g) {
        e = $b(f);
        if (null !== e)
          return e;
        e = null;
      } else if (3 === g) {
        if (f.stateNode.hydrate)
          return 3 === f.tag ? f.stateNode.containerInfo : null;
        e = null;
      } else
        f !== e && (e = null);
    }
  }
  jd(a, b, d, e, c);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
    ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b)
      return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if ("change" === a)
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b) {
  if ("click" === a)
    return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a)
    return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
      else
        for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f = c;
  "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);
  if (null !== d && !b && Ye.has(a)) {
    if ("scroll" !== a)
      return;
    e |= 2;
    f = d;
  }
  var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
  g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
}
function af(a, b, c, d) {
  var e = Nc.get(b);
  switch (void 0 === e ? 2 : e) {
    case 0:
      e = gd;
      break;
    case 1:
      e = id;
      break;
    default:
      e = hd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
  d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e) {
  var f = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e)
            break;
          if (4 === g)
            for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                  return;
              }
              g = g.return;
            }
          for (; null !== h; ) {
            g = wc(h);
            if (null === g)
              return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f, e2 = xb(c), g2 = [];
    a: {
      var h2 = Mc.get(a);
      if (void 0 !== h2) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w = 0 !== (b & 4), z2 = !w && "scroll" === a, u2 = w ? null !== h2 ? h2 + "Capture" : null : h2;
        w = [];
        for (var t2 = d2, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w.length && (h2 = new k2(h2, x2, null, c, e2), g2.push({ event: h2, listeners: w }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h2 = "mouseover" === a || "pointerover" === a;
        k2 = "mouseout" === a || "pointerout" === a;
        if (h2 && 0 === (b & 16) && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              w = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k2 ? h2 : ue(k2);
            q2 = null == x2 ? h2 : ue(x2);
            h2 = new w(v2, t2 + "leave", k2, c, e2);
            h2.target = z2;
            h2.relatedTarget = q2;
            v2 = null;
            wc(e2) === d2 && (w = new w(u2, t2 + "enter", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);
            z2 = v2;
            if (k2 && x2)
              b: {
                w = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w = gf(w), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w === u2 || null !== u2 && w === u2.alternate)
                    break b;
                  w = gf(w);
                  u2 = gf(u2);
                }
                w = null;
              }
            else
              w = null;
            null !== k2 && hf(g2, h2, k2, w, false);
            null !== x2 && null !== z2 && hf(g2, z2, x2, w, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k2 = h2.nodeName && h2.nodeName.toLowerCase();
        if ("select" === k2 || "input" === k2 && "file" === h2.type)
          var J2 = ve;
        else if (me(h2))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne(g2, J2, c, e2);
          break a;
        }
        K2 && K2(a, h2, d2);
        "focusout" === a && (K2 = h2._wrapperState) && K2.controlled && "number" === h2.type && bb(h2, "number", h2.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe = K2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a, c) && (L2 = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L2 = "onCompositionStart");
      L2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g2.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          e2
        ), g2.push({ event: e2, listeners: d2 }), e2.data = Q2);
    }
    se(g2, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e = a, f = e.stateNode;
    5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d; ) {
    var h = c, k = h.alternate, l2 = h.stateNode;
    if (null !== k && k === d)
      break;
    5 === h.tag && null !== l2 && (h = l2, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b, listeners: g });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a) {
  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
}
function rf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b)
          return a;
        b--;
      } else
        "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child)
        for (a = sf(a); null !== a; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f;
  for (f in c)
    e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Ff(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b);
  I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in a))
      throw Error(y(108, Ra(b) || "Unknown", e));
  return m({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}
var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (null !== bg) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (null !== c);
        }
      });
      ag = null;
    } catch (c) {
      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; null !== a; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (null === c || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, null !== c && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && false !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (null !== a) {
    a = a.shared;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null, f = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f ? e = f = g : f = f.next = g;
        c = c.next;
      } while (null !== c);
      null === f ? e = f = b : f = f.next = b;
    } else
      e = f = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k = h, l2 = k.next;
    k.next = null;
    null === g ? f = l2 : g.next = l2;
    g = k;
    var n2 = a.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (null !== f) {
    A2 = e.baseState;
    g = 0;
    n2 = l2 = k = null;
    do {
      h = f.lane;
      var p2 = f.eventTime;
      if ((d & h) === h) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f;
          h = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p2, A2, h);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h = "function" === typeof C2 ? C2.call(p2, A2, h) : C2;
              if (null === h || void 0 === h)
                break a;
              A2 = m({}, A2, h);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
      } else
        p2 = { eventTime: p2, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, null === n2 ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g |= h;
      f = f.next;
      if (null === f)
        if (h = e.shared.pending, null === h)
          break;
        else
          f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);
    null === n2 && (k = A2);
    e.baseState = k;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    Dg |= g;
    a.lanes = g;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e)
          throw Error(y(191, e));
        e.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : m({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.payload = b;
  void 0 !== c && null !== c && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.tag = 1;
  f.payload = b;
  void 0 !== c && null !== c && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e = zg(c, d);
  e.tag = 2;
  void 0 !== b && null !== b && (e.callback = b);
  Ag(a, e);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
}
function Mg(a, b, c) {
  var d = false, e = Cf;
  var f = b.contextType;
  "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
  b = new b(c, f);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f = b.contextType;
  "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        null === a2 ? delete b2[e] : b2[e] = a2;
      };
      b._stringRef = e;
      return b;
    }
    if ("string" !== typeof a)
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if ("textarea" !== a.type)
    throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
      null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g(b2) {
    a && null === b2.alternate && (b2.flags = 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (null !== b2 && b2.elementType === c2.type)
      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f2) {
    if (null === b2 || 7 !== b2.tag)
      return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if ("string" === typeof b2 || "number" === typeof b2)
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(
          b2,
          a2.mode,
          c2,
          null
        ), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e2 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 || "number" === typeof c2)
      return null !== e2 ? null : h(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return null !== e2 ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e2) {
    if ("string" === typeof d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
        case ta:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e2, g2, h2, k2) {
    for (var l3 = null, t2 = null, u2 = g2, z2 = g2 = 0, q2 = null; null !== u2 && z2 < h2.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e2, u2, h2[z2], k2);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === n3.alternate && b(e2, u2);
      g2 = f(n3, g2, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h2.length)
      return c(e2, u2), l3;
    if (null === u2) {
      for (; z2 < h2.length; z2++)
        u2 = A2(e2, h2[z2], k2), null !== u2 && (g2 = f(u2, g2, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e2, u2); z2 < h2.length; z2++)
      q2 = C2(u2, e2, z2, h2[z2], k2), null !== q2 && (a && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g2 = f(q2, g2, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  function w(e2, g2, h2, k2) {
    var l3 = La(h2);
    if ("function" !== typeof l3)
      throw Error(y(150));
    h2 = l3.call(h2);
    if (null == h2)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g2, z2 = g2 = 0, q2 = null, n3 = h2.next(); null !== u2 && !n3.done; z2++, n3 = h2.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w2 = p2(e2, u2, n3.value, k2);
      if (null === w2) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === w2.alternate && b(e2, u2);
      g2 = f(w2, g2, z2);
      null === t2 ? l3 = w2 : t2.sibling = w2;
      t2 = w2;
      u2 = q2;
    }
    if (n3.done)
      return c(e2, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h2.next())
        n3 = A2(e2, n3.value, k2), null !== n3 && (g2 = f(n3, g2, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h2.next())
      n3 = C2(u2, e2, z2, n3.value, k2), null !== n3 && (a && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g2 = f(n3, g2, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  return function(a2, d2, f2, h2) {
    var k2 = "object" === typeof f2 && null !== f2 && f2.type === ua && null === f2.key;
    k2 && (f2 = f2.props.children);
    var l3 = "object" === typeof f2 && null !== f2;
    if (l3)
      switch (f2.$$typeof) {
        case sa:
          a: {
            l3 = f2.key;
            for (k2 = d2; null !== k2; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f2.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f2.type) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props);
                      d2.ref = Qg(a2, k2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
          }
          return g(a2);
        case ta:
          a: {
            for (k2 = f2.key; null !== d2; ) {
              if (d2.key === k2)
                if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f2, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
      }
    if ("string" === typeof f2 || "number" === typeof f2)
      return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
    if (Pg(f2))
      return x2(a2, d2, f2, h2);
    if (La(f2))
      return w(a2, d2, f2, h2);
    l3 && Rg(a2, f2);
    if ("undefined" === typeof f2 && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I(ch, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H(ah);
  I(ah, b);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 64))
        return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (null === b)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e, f) {
  xh = f;
  R = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = null === a || null === a.memoizedState ? Dh : Eh;
  a = c(d, e);
  if (zh) {
    f = 0;
    do {
      zh = false;
      if (!(25 > f))
        throw Error(y(301));
      f += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }
  vh.current = Gh;
  b = null !== S && null !== S.next;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T ? R.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (null === S) {
    var a = R.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = S.next;
  var b = null === T ? R.memoizedState : T.next;
  if (null !== b)
    T = b, S = a;
  else {
    if (null === a)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    null === T ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e = d.baseQueue, f = c.pending;
  if (null !== f) {
    if (null !== e) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (null !== e) {
    e = e.next;
    d = d.baseState;
    var h = g = f = null, k = e;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        null === h ? (g = h = n2, f = d) : h = h.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (null !== k && k !== e);
    null === h ? f = d : h.next = g;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do
      f = a(f, g.action), g = g.next;
    while (g !== e);
    He(f, b.memoizedState) || (ug = true);
    b.memoizedState = f;
    null === b.baseQueue && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (null !== e)
    a = e === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;
  if (null === e)
    throw Error(y(349));
  var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
    return Mh(e, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w = R;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f(b._source);
    if (!He(g, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
      a2 = e.mutableReadLanes;
      e.entangledLanes |= a2;
      for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
        var k2 = 31 - Vc(h2), v2 = 1 << k2;
        d2[k2] |= a2;
        h2 &= ~v2;
      }
    }
  }, [c, b, d]);
  h.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w);
        e.mutableReadLanes |= d2 & e.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R.updateQueue;
  null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e = Hh();
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();
  d = void 0 === d ? null : d;
  var f = void 0;
  if (null !== S) {
    var g = S.memoizedState;
    f = g.destroy;
    if (null !== d && Bh(d, g.deps)) {
      Rh(b, c, f, d);
      return;
    }
  }
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, f, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if ("function" === typeof b)
    return a = a(), b(a), function() {
      b(null);
    };
  if (null !== b && void 0 !== b)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function() {
    a(true);
  });
  gg(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
  null === g ? f.next = f : (f.next = g.next, g.next = f);
  b.pending = f;
  g = a.alternate;
  if (a === R || null !== g && g === R)
    zh = yh = true;
  else {
    if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g))
      try {
        var h = b.lastRenderedState, k = g(h, c);
        f.eagerReducer = g;
        f.eagerState = k;
        if (He(k, h))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(
    null,
    b,
    a
  ), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    0 === (R.mode & 2) && (R.flags |= 516, Rh(
      5,
      function() {
        c("r:" + (tf++).toString(36));
      },
      void 0,
      null
    ));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f, e);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}
function ii(a, b, c, d, e, f) {
  if (null === a) {
    var g = c.type;
    if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
    a = Vg(c.type, null, d, b, b.mode, f);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g = a.child;
  if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref))
    return hi(a, b, f);
  b.flags |= 1;
  a = Tg(g, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e, f) {
  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, 0 !== (f & e))
      0 !== (a.flags & 16384) && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f);
  return li(a, b, c, d, f);
}
function mi(a, b, c) {
  var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
    if (0 === (b.mode & 4))
      b.memoizedState = { baseLanes: 0 }, ni(b, c);
    else if (0 !== (c & 1073741824))
      b.memoizedState = { baseLanes: 0 }, ni(b, null !== f ? f.baseLanes : c);
    else
      return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  else
    null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;
  f = Ef(b, f);
  tg(b, e);
  c = Ch(a, b, c, d, f, e);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}
function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f = true;
    Jf(b);
  } else
    f = false;
  tg(b, e);
  if (null === b.stateNode)
    null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
  else if (null === a) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l2) && Ng(b, g, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    k = b.memoizedState;
    h !== d || p2 !== k || N.current || wg ? ("function" === typeof n2 && (Gg(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = false);
  } else {
    g = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : lg(b.type, h);
    g.props = l2;
    A2 = b.pendingProps;
    p2 = g.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A2 || p2 !== k) && Ng(b, g, d, k);
    wg = false;
    p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    var x2 = b.memoizedState;
    h !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(
      d,
      x2,
      k
    ), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x2, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g.props = d, g.state = x2, g.context = k, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f, e);
}
function qi(a, b, c, d, e, f) {
  oi(a, b);
  var g = 0 !== (b.flags & 64);
  if (!d && !g)
    return e && Kf(b, c, false), hi(a, b, f);
  d = b.stateNode;
  ei.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
  b.memoizedState = d.state;
  e && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e = P.current, f = false, g;
  (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
  g ? (f = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
  I(P, e & 1);
  if (null === a) {
    void 0 !== d.fallback && ph(b);
    a = d.children;
    e = d.fallback;
    if (f)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if ("number" === typeof d.unstable_expectedLoadTime)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (null !== a.memoizedState) {
    if (f)
      return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f)
    return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e = a.mode, f = a.child;
  b = { mode: "hidden", children: b };
  0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f.return = a;
  c.return = a;
  f.sibling = c;
  a.child = f;
  return c;
}
function xi(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, { mode: "visible", children: c });
  0 === (b.mode & 2) && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e) {
  var f = b.mode, g = a.child;
  a = g.sibling;
  var h = { mode: "hidden", children: c };
  0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
  null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;
  null === g ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (null !== a && 0 !== (a.flags & 64))
      a:
        for (a = b.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && yi(a, c);
          else if (19 === a.tag)
            yi(a, c);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I(P, d);
  if (0 === (b.mode & 2))
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; )
          a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, false, e, c, f, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === ih(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        zi(b, true, c, null, f, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if (0 !== (c & b.childLanes)) {
    if (null !== a && b.child !== a.child)
      throw Error(y(153));
    if (null !== b.child) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f = [];
        break;
      case "select":
        e = m({}, e, { value: void 0 });
        d = m({}, d, { value: void 0 });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
    }
    vb(c, d);
    var g;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2])
        if ("style" === l2) {
          var h = e[l2];
          for (g in h)
            h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h = null != e ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h && (null != k || null != h))
        if ("style" === l2)
          if (h) {
            for (g in h)
              !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k)
              k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else
            c || (f || (f = []), f.push(l2, c)), c = k;
        else
          "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l2, k));
    }
    c && (f = f || []).push(
      "style",
      c
    );
    var l2 = f;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; )
          null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e = dh(ch.current);
      c = b.type;
      if (null !== a && null != b.stateNode)
        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (null === b.stateNode)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[wf] = b;
          d[xf] = f;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f), G("invalid", d);
          }
          vb(c, f);
          a = null;
          for (var g in f)
            f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f.onClick && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;
            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++)
                G(Xe[e], a);
              e = d;
              break;
            case "source":
              G("error", a);
              e = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;
            case "details":
              G("toggle", a);
              e = d;
              break;
            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e = m({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;
            default:
              e = d;
          }
          vb(c, e);
          var h = e;
          for (f in h)
            if (h.hasOwnProperty(f)) {
              var k = h[f];
              "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              null != d.value && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f = d.value;
              null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              "function" === typeof e.onClick && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && null != b.stateNode)
        Ei(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode)
          throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H(P);
      d = b.memoizedState;
      if (0 !== (b.flags & 64))
        return b.lanes = c, b;
      d = null !== d;
      c = false;
      null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
      if (d && !c && 0 !== (b.mode & 2))
        if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
          0 === V && (V = 3);
        else {
          if (0 === V || 3 === V)
            V = 4;
          null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H(P);
      d = b.memoizedState;
      if (null === d)
        return null;
      f = 0 !== (b.flags & 64);
      g = d.rendering;
      if (null === g)
        if (f)
          Fi(d, false);
        else {
          if (0 !== V || null !== a && 0 !== (a.flags & 64))
            for (a = b.child; null !== a; ) {
              g = ih(a);
              if (null !== g) {
                b.flags |= 64;
                Fi(d, false);
                f = g.updateQueue;
                null !== f && (b.updateQueue = f, b.flags |= 4);
                null === d.lastEffect && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; null !== c; )
                  f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          null !== d.tail && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f)
          if (a = ih(g), null !== a) {
            if (b.flags |= 64, f = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
      }
      return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if (0 !== (b & 64))
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return { value: a, source: b, stack: e };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = "function" === typeof WeakMap ? WeakMap : Map;
function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e);
    };
  }
  var f = a.stateNode;
  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
    "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (null !== b)
    if ("function" === typeof b)
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && null !== a) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          if (3 === (a.tag & 3)) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          var e = a;
          d = e.next;
          e = e.tag;
          0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(
        d,
        b.memoizedState,
        a.__reactInternalSnapshotBeforeUpdate
      )));
      b = c.updateQueue;
      null !== b && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (null !== b) {
        a = null;
        if (null !== c.child)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (5 === c.tag) {
      var d = c.stateNode;
      if (b)
        d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (6 === c.tag)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (null !== a && (a = a.lastEffect, null !== a)) {
        var c = a = a.next;
        do {
          var d = c, e = d.destroy;
          d = d.tag;
          if (void 0 !== e)
            if (0 !== (d & 4))
              Zi(b, c);
            else {
              d = b;
              try {
                e();
              } catch (f) {
                Wi(d, f);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if ("function" === typeof a.componentWillUnmount)
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f) {
          Wi(
            b,
            f
          );
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function fj(a) {
  a: {
    for (var b = a.return; null !== b; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; null === c.sibling; ) {
          if (null === c.return || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
          if (c.flags & 2)
            continue b;
          if (null === c.child || 4 === c.tag)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e = 5 === d || 6 === d;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
  else if (4 !== d && (a = a.child, null !== a))
    for (gj(a, b, c), a = a.sibling; null !== a; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e = 5 === d || 6 === d;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (hj(a, b, c), a = a.sibling; null !== a; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e, f; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (null === d)
            throw Error(y(160));
          e = d.stateNode;
          switch (d.tag) {
            case 5:
              f = false;
              break a;
            case 3:
              e = e.containerInfo;
              f = true;
              break a;
            case 4:
              e = e.containerInfo;
              f = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (5 === c.tag || 6 === c.tag) {
      a:
        for (var g = a, h = c, k = h; ; )
          if (bj(g, k), null !== k.child && 4 !== k.tag)
            k.child.return = k, k = k.child;
          else {
            if (k === h)
              break a;
            for (; null === k.sibling; ) {
              if (null === k.return || k.return === h)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (4 === c.tag) {
      if (null !== c.child) {
        e = c.stateNode.containerInfo;
        f = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
      4 === c.tag && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = null !== c ? c.lastEffect : null;
      if (null !== c) {
        var d = c = c.next;
        do
          3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (null != c) {
        d = b.memoizedProps;
        var e = null !== a ? a.memoizedProps : d;
        a = b.type;
        var f = b.updateQueue;
        b.updateQueue = null;
        if (null !== f) {
          c[xf] = d;
          "input" === a && "radio" === d.type && null != d.name && $a(c, d);
          wb(a, e);
          b = wb(a, d);
          for (e = 0; e < f.length; e += 2) {
            var g = f[e], h = f[e + 1];
            "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b.stateNode)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b.memoizedState && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, null !== b.memoizedState);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if (0 === (a & 2))
    return 1;
  if (0 === (a & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
    return b;
  }
  a = eg();
  0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (null === a)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, 4 === V && Ii(a, W));
  var d = eg();
  1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
    var h = 31 - Vc(g), k = 1 << h, l2 = f[h];
    if (-1 === l2) {
      if (0 === (k & d) || 0 !== (k & e)) {
        l2 = b;
        Rc(k);
        var n2 = F;
        f[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F;
  if (0 === d)
    null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (null !== c) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X & 48))
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (0 === c)
    return null;
  var d = c;
  var e = X;
  X |= 16;
  var f = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  while (1);
  qg();
  oj.current = f;
  X = e;
  null !== Y ? d = 0 : (U = null, W = 0, d = V);
  if (0 !== (tj & Hi))
    Qj(a, 0);
  else if (0 !== d) {
    2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
    if (1 === d)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (0 !== Uc(a, 0))
            break;
          e = a.suspendedLanes;
          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e = -1; 0 < c; ) {
          var g = 31 - Vc(c);
          f = 1 << g;
          g = d[g];
          g > e && (e = g);
          c &= ~f;
        }
        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if (0 !== (X & 48))
    throw Error(y(327));
  Oj();
  if (a === U && 0 !== (a.expiredLanes & W)) {
    var b = W;
    var c = Tj(a, b);
    0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
  if (1 === c)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function ni(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, pf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R.memoizedState; null !== d; ) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (null === c || null === c.return) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f = a, g = c.return, h = c, k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;
        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l2 = k;
          if (0 === (h.mode & 2)) {
            var n2 = h.alternate;
            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var A2 = 0 !== (P.current & 1), p2 = g;
          do {
            var C2;
            if (C2 = 13 === p2.tag) {
              var x2 = p2.memoizedState;
              if (null !== x2)
                C2 = null !== x2.dehydrated ? true : false;
              else {
                var w = p2.memoizedProps;
                C2 = void 0 === w.fallback ? false : true !== w.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p2.mode & 2)) {
                p2.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (1 === h.tag)
                  if (null === h.alternate)
                    h.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h, t2);
                  }
                h.lanes |= 1;
                break a;
              }
              k = void 0;
              h = b;
              var q2 = f.pingCache;
              null === q2 ? (q2 = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), void 0 === k && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
              if (!k.has(h)) {
                k.add(h);
                var v2 = Yj.bind(null, f, l2, h);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (null !== p2);
          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V && (V = 2);
        k = Mi(k, h);
        p2 = g;
        do {
          switch (p2.tag) {
            case 3:
              f = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi(p2, f, b);
              Bg(p2, J2);
              break a;
            case 1:
              f = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (null !== p2);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return null === a ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (null !== Y)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; null !== Y; )
    bk(Y);
}
function Rj() {
  for (; null !== Y && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  null === b ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 2048)) {
      c = Gi(c, b, qj);
      if (null !== c) {
        Y = c;
        return;
      }
      c = b;
      if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
        for (var d = 0, e = c.child; null !== e; )
          d |= e.lanes | e.childLanes, e = e.sibling;
        c.childLanes = d;
      }
      null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (null !== c) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === V && (V = 5);
}
function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X & 48))
    throw Error(y(327));
  var c = a.finishedWork;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;
  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
    var k = 31 - Vc(f), l2 = 1 << k;
    e[k] = 0;
    g[k] = -1;
    h[k] = -1;
    f &= ~l2;
  }
  null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (null !== d) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g = Ne();
    if (Oe(g)) {
      if ("selectionStart" in g)
        h = { start: g.selectionStart, end: g.selectionEnd };
      else
        a:
          if (h = (h = g.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && 0 !== l2.rangeCount) {
            h = l2.anchorNode;
            f = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h.nodeType, k.nodeType;
            } catch (va) {
              h = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w !== h || 0 !== f && 3 !== w.nodeType || (A2 = n2 + f);
                  w !== k || 0 !== l2 && 3 !== w.nodeType || (p2 = n2 + l2);
                  3 === w.nodeType && (n2 += w.nodeValue.length);
                  if (null === (u2 = w.firstChild))
                    break;
                  z2 = w;
                  w = u2;
                }
                for (; ; ) {
                  if (w === g)
                    break b;
                  z2 === h && ++C2 === f && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if (null !== (u2 = w.nextSibling))
                    break;
                  w = z2;
                  z2 = w.parentNode;
                }
                w = u2;
              }
            h = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
          } else
            h = null;
      h = h || { start: 0, end: 0 };
    } else
      h = null;
    lf = { focusedElem: g, selectionRange: h };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Ij = null;
    Z = d;
    do
      try {
        for (g = a; null !== Z; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h = Z;
              cj(g, h);
              var J2 = h.alternate;
              dj(h);
              null !== J2 && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g && Oe(t2) && (q2 = g.start, v2 = g.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g.start, h), g = void 0 === g.end ? J2 : Math.min(g.end, h), !v2.extend && J2 > g && (h = g, g = J2, J2 = h), h = Le(t2, J2), f = Le(t2, g), h && f && (1 !== v2.rangeCount || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f.node || v2.focusOffset !== f.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g ? (v2.addRange(q2), v2.extend(f.node, f.offset)) : (q2.setEnd(f.node, f.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; null !== Z; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (null !== Q2) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Z = null;
    $f();
    X = e;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; null !== Z; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  0 === d && (Ti = null);
  1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if (0 !== (X & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z; ) {
    var a = Z.alternate;
    Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    0 !== (b & 256) && Xi(a, Z);
    0 === (b & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a = yj;
  yj = null;
  if (0 !== (X & 48))
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e = c[d], f = c[d + 1], g = e.destroy;
    e.destroy = void 0;
    if ("function" === typeof g)
      try {
        g();
      } catch (k) {
        if (null === f)
          throw Error(y(330));
        Wi(f, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f = c[d + 1];
    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (null === f)
        throw Error(y(330));
      Wi(f, k);
    }
  }
  for (h = a.current.firstEffect; null !== h; )
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  null !== a && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (3 === a.tag)
    gk(a, a, b);
  else
    for (var c = a.return; null !== c; ) {
      if (3 === c.tag) {
        gk(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;
        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (null !== c)
            $c(c, 1, e), Mj(c, e);
          else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  null !== c && c.delete(b);
  b = 0;
  0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  null !== a && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (null !== a)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if (0 !== (c & d))
      ug = 0 !== (a.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I(mg, e._currentValue);
          e._currentValue = d;
          break;
        case 13:
          if (null !== b.memoizedState) {
            if (0 !== (c & b.child.childLanes))
              return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return null !== b ? b.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 64)) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;
      if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
        xg(b);
        var g = d.getDerivedStateFromProps;
        "function" === typeof g && Gg(b, d, g, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f, c);
      } else
        b.tag = 0, fi(null, b, e, c), b = b.child;
      return b;
    case 16:
      e = b.elementType;
      a: {
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f = e._init;
        e = f(e._payload);
        b.type = e;
        f = b.tag = hk(e);
        a = lg(e, a);
        switch (f) {
          case 0:
            b = li(null, b, e, a, c);
            break a;
          case 1:
            b = pi(null, b, e, a, c);
            break a;
          case 11:
            b = gi(null, b, e, a, c);
            break a;
          case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);
            break a;
        }
        throw Error(y(306, e, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (null === a || null === d)
        throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = null !== e ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e)
        sh(), b = hi(a, b, c);
      else {
        e = b.stateNode;
        if (f = e.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
        if (f) {
          a = e.mutableSourceEagerHydrationData;
          if (null != a)
            for (e = 0; e < a.length; e += 2)
              f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
    case 6:
      return null === a && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(
        a,
        b,
        b.pendingProps.children,
        c
      ), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g = b.memoizedProps;
        f = e.value;
        var h = b.type._context;
        I(mg, h._currentValue);
        h._currentValue = f;
        if (null !== g)
          if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
            if (g.children === e.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h = b.child, null !== h && (h.return = b); null !== h; ) {
              var k = h.dependencies;
              if (null !== k) {
                g = h.child;
                for (var l2 = k.firstContext; null !== l2; ) {
                  if (l2.context === d && 0 !== (l2.observedBits & f)) {
                    1 === h.tag && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));
                    h.lanes |= c;
                    l2 = h.alternate;
                    null !== l2 && (l2.lanes |= c);
                    sg(h.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;
              if (null !== g)
                g.return = h;
              else
                for (g = h; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  h = g.sibling;
                  if (null !== h) {
                    h.return = g.return;
                    g = h;
                    break;
                  }
                  g = g.return;
                }
              h = g;
            }
        fi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(
        e,
        f.unstable_observedBits
      ), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if ("function" === typeof a)
    return ji(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if ("function" === typeof a)
    ji(a) && (g = 1);
  else if ("string" === typeof a)
    g = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e, f, b);
        case Ha:
          g = 8;
          e |= 16;
          break;
        case wa:
          g = 8;
          e |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
        case Ba:
          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
        case Ca:
          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
        case Ia:
          return vi(c, e, f, b);
        case Ja:
          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case ya:
                g = 10;
                break a;
              case za:
                g = 9;
                break a;
              case Aa:
                g = 11;
                break a;
              case Da:
                g = 14;
                break a;
              case Ea:
                g = 16;
                d = null;
                break a;
              case Fa:
                g = 22;
                break a;
            }
          throw Error(y(130, null == a ? a : typeof a, ""));
      }
  b = nh(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current, f = Hg(), g = Ig(e);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || 1 !== c.tag)
          throw Error(y(170));
        var h = c;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;
            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h = h.return;
        } while (null !== h);
        throw Error(y(171));
      }
      if (1 === c.tag) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }
      c = h;
    } else
      c = Cf;
  null === b.context ? b.context = c : b.pendingContext = c;
  b = zg(f, g);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  Ag(e, b);
  Jg(e, g, f);
  return g;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, null != c && true === c.hydrate);
  b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(8 === a.nodeType ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function sk(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f._internalRoot;
    if ("function" === typeof e) {
      var h = e;
      e = function() {
        var a2 = mk(g);
        h.call(a2);
      };
    }
    lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);
    g = f._internalRoot;
    if ("function" === typeof e) {
      var k = e;
      e = function() {
        var a2 = mk(g);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g, a, e);
    });
  }
  return mk(g);
}
ec = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};
fc = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (13 === a.tag) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e) {
  var f = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, 0 === X && (wj(), ig());
  }
};
Ib = function() {
  0 === (X & 49) && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render)
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if (0 !== (c & 48))
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
(function(module) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module.exports = reactDom_production_min;
  }
})(reactDom);
class Maths {
  static clamp(x2, a, b) {
    return x2 < a ? a : x2 > b ? b : x2;
  }
  static lerp(x2, a, b) {
    return a + x2 * (b - a);
  }
  static fract(x2) {
    return x2 - Math.floor(x2);
  }
  static step(edge, x2) {
    return x2 < edge ? 0 : 1;
  }
  static smoothstep(edge0, edge1, x2) {
    const t2 = Maths.clamp((x2 - edge0) / (edge1 - edge0), 0, 1);
    return t2 * t2 * (3 - 2 * t2);
  }
  static gaussian(x2, eRange) {
    const d = eRange * eRange;
    const timeScale = 0.5;
    const r2 = 1 + 2 * x2;
    return Math.exp(-timeScale * r2 * r2 / d);
  }
  static sigmoid10(x2) {
    const a = 1 / (1 + Math.exp(-20 * (x2 - 0.5)));
    return a;
  }
  static sigmoid10half(x2) {
    return (Maths.sigmoid10(0.5 + x2 * 0.5) - 0.5) * 2;
  }
  static pointToLineSegment_SorroundingDistance(x0, y0, x1, y1, x2, y2) {
    const a = x2 - x1;
    const b = y2 - y1;
    const a2 = a * a;
    const b2 = b * b;
    const r2 = a2 + b2;
    if (r2 < 1e-6) {
      return (x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1);
    }
    const tt = -(a * (x1 - x0) + b * (y1 - y0));
    if (tt < 0) {
      return (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
    }
    if (tt > r2) {
      return (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);
    }
    const f1 = a * (y1 - y0) - b * (x1 - x0);
    return f1 * f1 / r2;
  }
  static pointToLine_Distance(P_x, P_y, A_x, A_y, B_x, B_y) {
    const AB_x = B_x - A_x;
    const AB_y = B_y - A_y;
    const AP_x = P_x - A_x;
    const AP_y = P_y - A_y;
    const D2 = Math.abs(AB_x * AP_y - AB_y * AP_x);
    const L2 = Math.sqrt((B_x - A_x) * (B_x - A_x) + (B_y - A_y) * (B_y - A_y));
    const H2 = D2 / L2;
    return H2;
  }
  static pointToLine_NearestPointNormalizedPosition(P_x, P_y, A_x, A_y, B_x, B_y) {
    const AB_x = B_x - A_x;
    const AB_y = B_y - A_y;
    const AP_x = P_x - A_x;
    const AP_y = P_y - A_y;
    const len = Math.sqrt(AB_x * AB_x + AB_y * AB_y);
    if (len <= 0) {
      return null;
    }
    const nAB_x = AB_x / len;
    const nAB_y = AB_y / len;
    const dist_AX = nAB_x * AP_x + nAB_y * AP_y;
    return dist_AX / len;
  }
  static pointToLine_NearestPoint(result, P_x, P_y, A_x, A_y, B_x, B_y) {
    const AB_x = B_x - A_x;
    const AB_y = B_y - A_y;
    const AP_x = P_x - A_x;
    const AP_y = P_y - A_y;
    const len = Math.sqrt(AB_x * AB_x + AB_y * AB_y);
    if (len <= 0) {
      return null;
    }
    const nAB_x = AB_x / len;
    const nAB_y = AB_y / len;
    const dist_AX = nAB_x * AP_x + nAB_y * AP_y;
    result[0] = A_x + nAB_x * dist_AX;
    result[1] = A_y + nAB_y * dist_AX;
    return result;
  }
  static lineToLine_CrossPoint(result, L1_x, L1_y, L2_x, L2_y, L3_x, L3_y, L4_x, L4_y) {
    let ksi = (L4_y - L3_y) * (L4_x - L1_x) - (L4_x - L3_x) * (L4_y - L1_y);
    let eta = (L2_x - L1_x) * (L4_y - L1_y) - (L2_y - L1_y) * (L4_x - L1_x);
    let delta = (L2_x - L1_x) * (L4_y - L3_y) - (L2_y - L1_y) * (L4_x - L3_x);
    let ramda = ksi / delta;
    let mu = eta / delta;
    if (ramda >= 0 && ramda <= 1 && (mu >= 0 && mu <= 1)) {
      result[0] = L1_x + ramda * (L2_x - L1_x);
      result[1] = L1_y + ramda * (L2_y - L1_y);
      return true;
    }
    return false;
  }
  static copyTranslation(result, matrix) {
    result[0] = matrix[12];
    result[1] = matrix[13];
    result[2] = matrix[14];
  }
  static mat4SetVectors(result, vecX, vecY, vecZ) {
    result[0] = vecX[0];
    result[1] = vecX[1];
    result[2] = vecX[2];
    result[3] = 0;
    result[4] = vecY[0];
    result[5] = vecY[1];
    result[6] = vecY[2];
    result[7] = 0;
    result[8] = vecZ[0];
    result[9] = vecZ[1];
    result[10] = vecZ[2];
    result[11] = 0;
  }
  static mat4SegmentMat(result, resultNormalVec, locationFrom, locationTo) {
    vec3.subtract(resultNormalVec, locationTo, locationFrom);
    vec3.normalize(resultNormalVec, resultNormalVec);
    result[0] = resultNormalVec[0];
    result[1] = resultNormalVec[1];
    result[2] = 0;
    result[3] = 0;
    result[4] = -resultNormalVec[1];
    result[5] = resultNormalVec[0];
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = 1;
    result[11] = 1;
    result[12] = locationFrom[0];
    result[13] = locationFrom[1];
    result[14] = 0;
    result[15] = 1;
  }
  static getRoundedAngle(angle) {
    if (angle <= -Math.PI) {
      angle += Math.PI * 2;
    }
    if (angle >= Math.PI) {
      angle -= Math.PI * 2;
    }
    return angle;
  }
}
class ColorLogic {
  static floatToHex2String(v2) {
    return ("00" + v2.toString(16)).substr(-2);
  }
  static rgbToHex2String(color) {
    return `${this.floatToHex2String(Math.floor(color[0] * 255))}${this.floatToHex2String(Math.floor(color[1] * 255))}${this.floatToHex2String(Math.floor(color[2] * 255))}`;
  }
  static rgbaToRgbaString(color) {
    return `${(color[0] * 255).toFixed(0)},${(color[1] * 255).toFixed(0)},${(color[2] * 255).toFixed(0)},${color[3].toFixed(3)}`;
  }
  static hex2StringToRGB(result, colorString) {
    result[0] = parseInt(colorString.substring(1, 3), 16) / 255;
    result[1] = parseInt(colorString.substring(3, 5), 16) / 255;
    result[2] = parseInt(colorString.substring(5, 7), 16) / 255;
    return result;
  }
  static hsvToRGB_Element(h, s, v2, baseElement) {
    return ((Maths.clamp(Math.abs(Maths.fract(h + baseElement / 3) * 6 - 3) - 1, 0, 1) - 1) * s + 1) * v2;
  }
  static hsvToRGB(out, h, s, v2) {
    out[0] = this.hsvToRGB_Element(h, s, v2, 0);
    out[1] = this.hsvToRGB_Element(h, s, v2, 2);
    out[2] = this.hsvToRGB_Element(h, s, v2, 1);
  }
  static hsvToRGBv(out, hsv) {
    this.hsvToRGB(out, hsv[0], hsv[1], hsv[2]);
  }
  static rgbToHSV(result, r2, g, b) {
    const Kx = 0;
    const Ky = -1 / 3;
    const Kz = 2 / 3;
    const Kw = -1;
    vec4.set(this.rgbToHSV_bgKwz, b, g, Kw, Kz);
    vec4.set(this.rgbToHSV_gbKxy, g, b, Kx, Ky);
    vec4.lerp(this.rgbToHSV_p, this.rgbToHSV_bgKwz, this.rgbToHSV_gbKxy, Maths.step(b, g));
    const px = this.rgbToHSV_p[0];
    const py = this.rgbToHSV_p[1];
    const pz = this.rgbToHSV_p[2];
    const pw = this.rgbToHSV_p[3];
    vec4.set(this.rgbToHSV_Pxywr, px, py, pw, r2);
    vec4.set(this.rgbToHSV_rPyzx, r2, py, pz, px);
    vec4.lerp(this.rgbToHSV_q, this.rgbToHSV_Pxywr, this.rgbToHSV_rPyzx, Maths.step(px, r2));
    const qx = this.rgbToHSV_q[0];
    const qy = this.rgbToHSV_q[1];
    const qz = this.rgbToHSV_q[2];
    const qw = this.rgbToHSV_q[3];
    const d = qx - Math.min(qw, qy);
    const e = 1e-10;
    result[0] = Math.abs(qz + (qw - qy) / (6 * d + e));
    result[1] = d / (qx + e);
    result[2] = qx;
  }
  static rgbToHSVv(out, rgb) {
    this.rgbToHSV(out, rgb[0], rgb[1], rgb[2]);
  }
}
ColorLogic.rgbToHSV_bgKwz = vec4.create();
ColorLogic.rgbToHSV_gbKxy = vec4.create();
ColorLogic.rgbToHSV_p = vec4.create();
ColorLogic.rgbToHSV_Pxywr = vec4.create();
ColorLogic.rgbToHSV_rPyzx = vec4.create();
ColorLogic.rgbToHSV_q = vec4.create();
class Lists {
  static addRange(destList, addList) {
    Array.prototype.push.apply(destList, addList);
  }
  static getRange(srcList, index2, length) {
    return srcList.slice(index2, index2 + length);
  }
  static getRangeToLast(srcList, index2) {
    return srcList.slice(index2, srcList.length);
  }
  static insertRangeToTop(destList, addList) {
    return [...addList, ...destList];
  }
  static insertAt(destList, index2, item) {
    destList.splice(index2, 0, item);
  }
  static removeAt(destList, index2) {
    destList.splice(index2, 1);
  }
  static clone(list) {
    return list.slice();
  }
  static reverse(list) {
    return list.reverse();
  }
  static cloneReversed(list) {
    return Lists.clone(list).reverse();
  }
}
class Strings {
  static isNullOrEmpty(str) {
    return str === null || str === void 0 || str === "";
  }
  static indexOf(str, searchString, startPosition) {
    if (startPosition == -1) {
      startPosition = void 0;
    }
    return str.indexOf(searchString, startPosition);
  }
  static lastIndexOf(str, searchString) {
    return str.lastIndexOf(searchString);
  }
  static substring(text, startIndex, length) {
    if (length) {
      if (length > 0) {
        if (length >= text.length) {
          return "";
        }
        return text.substring(startIndex, startIndex + length);
      } else if (length < 0) {
        if (-length >= text.length) {
          return "";
        }
        return text.substring(startIndex, text.length - 1 + length);
      } else {
        return "";
      }
    } else {
      return text.substring(startIndex);
    }
  }
  static startsWith(text, searchString) {
    return text.indexOf(searchString) == 0;
  }
  static endsWith(text, searchString) {
    return text.lastIndexOf(searchString) == text.length - searchString.length;
  }
  static contains(text, searchString) {
    return text.indexOf(searchString) != -1;
  }
  static replaceAll(text, removeString, replaceString) {
    return text.replace(new RegExp(removeString, "g"), replaceString);
  }
}
class RectangleLayoutArea {
  constructor(children) {
    this.index = -1;
    this.iconID = -1;
    this.marginTop = 0;
    this.marginRight = 0;
    this.marginBottom = 0;
    this.marginLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
    this.paddingLeft = 0;
    this.colSpan = 1;
    this.rowSpan = 1;
    this.width = 0;
    this.height = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.gridLayoutOptions = null;
    this.children = [];
    this.hover = false;
    this.hover_before = false;
    if (children) {
      this.children = children;
    }
  }
  setChildren(children) {
    this.children = children;
    return this;
  }
  setIndex(index2) {
    this.index = index2;
    return this;
  }
  setIcon(index2) {
    this.iconID = index2;
    return this;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  setPadding({ left, top, right, bottom }) {
    if (left) {
      this.paddingLeft = left;
    }
    if (top) {
      this.paddingTop = top;
    }
    if (right) {
      this.paddingRight = right;
    }
    if (bottom) {
      this.paddingBottom = bottom;
    }
    return this;
  }
  setCellSpan(colSpan, rowSpan) {
    this.colSpan = colSpan;
    this.rowSpan = rowSpan;
    return this;
  }
  setGridLayout(options) {
    this.gridLayoutOptions = { ...options };
    return this;
  }
  getWidth() {
    return this.right - this.left + 1;
  }
  getHeight() {
    return this.bottom - this.top + 1;
  }
  saveState() {
    this.hover_before = this.hover;
  }
  isChanged() {
    return this.hover_before != this.hover;
  }
  copyRectangle(canvasWindow) {
    this.left = 0;
    this.top = 0;
    this.right = canvasWindow.width - 1;
    this.bottom = canvasWindow.width - 1;
  }
}
class LayoutLogic {
  static calculateGridLayout(layoutArea, options) {
    if (layoutArea.children.length == 0) {
      return;
    }
    const style = {
      ...{
        columns: 1,
        columnGap: 0,
        rows: 1,
        rowGap: 0
      },
      ...options
    };
    const left = layoutArea.left + layoutArea.paddingLeft;
    const right = layoutArea.right - layoutArea.paddingRight;
    const top = layoutArea.top + layoutArea.paddingTop;
    const bottom = layoutArea.bottom - layoutArea.paddingBottom;
    const columnGaps = (style.columns - 1) * style.columnGap;
    const cellWidth = (right - left - columnGaps) / style.columns;
    const rowGaps = (style.rows - 1) * style.columnGap;
    const cellHeight = (bottom - top - rowGaps) / style.rows;
    const cells = [];
    let y2 = top;
    for (let row = 0; row < style.rows; row++) {
      const row2 = [];
      let x2 = left;
      for (let col = 0; col < style.columns; col++) {
        row2.push({
          layoutArea: null,
          left: x2,
          top: y2,
          right: x2 + cellWidth - 1,
          bottom: y2 + cellHeight - 1
        });
        x2 += style.columnGap + cellWidth;
      }
      cells.push(row2);
      y2 += cellHeight + style.rowGap;
    }
    let childIndex = 0;
    for (let rowIndex = 0; rowIndex < style.rows; rowIndex++) {
      if (childIndex >= layoutArea.children.length) {
        break;
      }
      for (let columnIndex = 0; columnIndex < style.columns; columnIndex++) {
        if (childIndex >= layoutArea.children.length) {
          break;
        }
        const cell = cells[rowIndex][columnIndex];
        const child = layoutArea.children[childIndex];
        if (cell.layoutArea == null) {
          child.left = cell.left;
          child.top = cell.top;
          for (let row = 0; row < child.rowSpan; row++) {
            for (let col = 0; col < child.colSpan; col++) {
              const span_cell = cells[rowIndex + row][columnIndex + col];
              child.right = span_cell.right;
              child.bottom = span_cell.bottom;
              span_cell.layoutArea = child;
            }
          }
          child.width = child.getWidth();
          child.height = child.getHeight();
          childIndex++;
        }
      }
    }
  }
  static hitTestLayout(areas, x2, y2) {
    if (areas instanceof Array) {
      for (const area of areas) {
        if (this.hitTestLayoutRectangle(area, x2, y2)) {
          return area;
        }
      }
    } else if (areas instanceof RectangleLayoutArea) {
      if (this.hitTestLayoutRectangle(areas, x2, y2)) {
        return areas;
      }
    }
    return null;
  }
  static hitTestLayoutRectangle(area, x2, y2) {
    if (x2 >= area.left && x2 <= area.right && y2 >= area.top && y2 <= area.bottom) {
      return true;
    } else {
      return false;
    }
  }
  static isChanged(area) {
    return area != null && area.isChanged();
  }
}
const _Logic_Points = class {
  static angle(fromPoint, ToPoint) {
    const vx = ToPoint[0] - fromPoint[0];
    const vy = ToPoint[1] - fromPoint[1];
    const angle = Math.atan2(vy, vx);
    return angle;
  }
  static angleOfCorner(firstPoint, centerPoint, lastPoint) {
    const ax = lastPoint[0] - centerPoint[0];
    const ay = lastPoint[1] - centerPoint[1];
    const bx = firstPoint[0] - centerPoint[0];
    const by = firstPoint[1] - centerPoint[1];
    const angle = Math.atan2(ax * by - bx * ay, ax * bx + ay * by);
    return angle;
  }
  static angleDistanceOfCorner(firstPoint, centerPoint, lastPoint) {
    const angle = _Logic_Points.angleOfCorner(firstPoint, centerPoint, lastPoint);
    let curvature = -angle + Math.PI;
    if (curvature >= Math.PI) {
      curvature = 2 * Math.PI - curvature;
    }
    return curvature;
  }
  static directionAngleDifferenceOfCorner(firstPoint, centerPoint, lastPoint) {
    const angle = _Logic_Points.angleOfCorner(firstPoint, centerPoint, lastPoint);
    let directionAngle = angle >= 0 ? Math.PI - angle : -Math.PI - angle;
    return directionAngle;
  }
  static isClockwise(firstPoint, centerPoint, lastPoint) {
    const ax = lastPoint[0] - centerPoint[0];
    const ay = lastPoint[1] - centerPoint[1];
    const bx = firstPoint[0] - centerPoint[0];
    const by = firstPoint[1] - centerPoint[1];
    const crossProduct = ax * by - ay * bx;
    return crossProduct > 0;
  }
  static segmentMat(result, locationFrom, locationTo) {
    vec3.subtract(this.segmentMat_DifferenceVec, locationTo, locationFrom);
    vec3.normalize(this.segmentMat_DifferenceVec, this.segmentMat_DifferenceVec);
    mat4.identity(result);
    result[0] = this.segmentMat_DifferenceVec[0];
    result[1] = this.segmentMat_DifferenceVec[1];
    result[4] = -this.segmentMat_DifferenceVec[1];
    result[5] = this.segmentMat_DifferenceVec[0];
    result[12] = locationFrom[0];
    result[13] = locationFrom[1];
  }
  static pointToPoint_DistanceSQ(point1, point2) {
    return Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2);
  }
  static pointToLineSegment_SorroundingDistanceSQ(point1, point2, targetPoint) {
    return Maths.pointToLineSegment_SorroundingDistance(
      targetPoint[0],
      targetPoint[1],
      point1[0],
      point1[1],
      point2[0],
      point2[1]
    );
  }
  static pointToLineSegment_SorroundingDistance(point1, point2, targetPoint) {
    const distanceSQ = this.pointToLineSegment_SorroundingDistanceSQ(point1, point2, targetPoint);
    return Math.sqrt(distanceSQ);
  }
  static pointToLineSegment_NormalizedPosition(segmentPoint1, segmentPoint2, targetPoint) {
    return Maths.pointToLine_NearestPointNormalizedPosition(
      targetPoint[0],
      targetPoint[1],
      segmentPoint1[0],
      segmentPoint1[1],
      segmentPoint2[0],
      segmentPoint2[1]
    );
  }
  static pointToLine_Distance(point1, point2, targetPoint) {
    return Maths.pointToLine_Distance(
      targetPoint[0],
      targetPoint[1],
      point1[0],
      point1[1],
      point2[0],
      point2[1]
    );
  }
  static pointToLine_NearestLocation(result, linePoint1, linePoint2, targetPoint) {
    return Maths.pointToLine_NearestPoint(
      result,
      targetPoint[0],
      targetPoint[1],
      linePoint1[0],
      linePoint1[1],
      linePoint2[0],
      linePoint2[1]
    ) != null;
  }
  static lineSegmentToLineSegment_CrossPoint(result, L1, L2, L3, L4) {
    return Maths.lineToLine_CrossPoint(
      result,
      L1[0],
      L1[1],
      L2[0],
      L2[1],
      L3[0],
      L3[1],
      L4[0],
      L4[1]
    );
  }
};
let Logic_Points = _Logic_Points;
Logic_Points.segmentMat_DifferenceVec = vec3.create();
const _RectangleArea = class {
  constructor() {
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.range = 0;
    this.centerLocation = vec3.fromValues(0, 0, 0);
  }
  static createMinumumValueRectangle() {
    return new _RectangleArea().setMinimumValue();
  }
  static calculateSurroundingRectangle(result, rectangle1, rectangle2) {
    result.left = Math.min(rectangle1.left, rectangle2.left);
    result.top = Math.min(rectangle1.top, rectangle2.top);
    result.right = Math.max(rectangle1.right, rectangle2.right);
    result.bottom = Math.max(rectangle1.bottom, rectangle2.bottom);
  }
  copyTo(destination) {
    destination.top = this.top;
    destination.right = this.right;
    destination.bottom = this.bottom;
    destination.left = this.left;
    destination.range = this.range;
    vec3.copy(destination.centerLocation, this.centerLocation);
  }
  calculateParams() {
    vec3.set(
      this.centerLocation,
      this.left + this.getWidth() / 2,
      this.top + this.getHeight() / 2,
      0
    );
    this.range = Math.sqrt(Math.pow(this.getWidth() / 2, 2) + Math.pow(this.getHeight() / 2, 2));
  }
  getWidth() {
    return Math.abs(this.right - this.left);
  }
  getHeight() {
    return Math.abs(this.bottom - this.top);
  }
  getBitmapWidth() {
    return Math.floor(this.getWidth() + 0.5);
  }
  getBitmapHeight() {
    return Math.floor(this.getHeight() + 0.5);
  }
  getMedianHrizontalPosition() {
    return this.left + this.getHeight() / 2;
  }
  getMedianVerticalPosition() {
    return this.top + this.getHeight() / 2;
  }
  getHorizontalPositionRate(x2) {
    const width = this.getWidth();
    if (width == 0) {
      return 0;
    }
    return (x2 - this.left) / width;
  }
  getVerticalPositionRate(y2) {
    const height = this.getHeight();
    if (height == 0) {
      return 0;
    }
    return (y2 - this.top) / height;
  }
  setMinimumValue() {
    this.left = _RectangleArea.INFINIT_POSITION_VALUE;
    this.top = _RectangleArea.INFINIT_POSITION_VALUE;
    this.right = -_RectangleArea.INFINIT_POSITION_VALUE;
    this.bottom = -_RectangleArea.INFINIT_POSITION_VALUE;
    return this;
  }
  isValidArea() {
    return this.left != _RectangleArea.INFINIT_POSITION_VALUE && this.top != _RectangleArea.INFINIT_POSITION_VALUE && this.right != -_RectangleArea.INFINIT_POSITION_VALUE && this.bottom != -_RectangleArea.INFINIT_POSITION_VALUE;
  }
  existsValidArea() {
    return this.isValidArea() && this.getBitmapWidth() > _RectangleArea.MINIMUM_POSITION_VALUE && this.getBitmapHeight() > _RectangleArea.MINIMUM_POSITION_VALUE;
  }
  expandByLocation(x2, y2) {
    this.left = Math.min(x2, this.left);
    this.top = Math.min(y2, this.top);
    this.right = Math.max(x2, this.right);
    this.bottom = Math.max(y2, this.bottom);
  }
  expandByRectangle(rectangle) {
    _RectangleArea.calculateSurroundingRectangle(this, this, rectangle);
  }
  hittestLocationWithRadius(location, radius) {
    return location[0] >= this.left - radius && location[0] <= this.right + radius && location[1] >= this.top - radius && location[1] <= this.bottom + radius;
  }
};
let RectangleArea = _RectangleArea;
RectangleArea.INFINIT_POSITION_VALUE = 999999;
RectangleArea.MINIMUM_POSITION_VALUE = 1e-4;
class PlatformPath {
  constructor() {
    this.platFormIndependentPathJoinLetter = "/";
  }
  getPlatformPathJoinLetter() {
    return "\\";
  }
  getPlatformOrientedPath(targetPath) {
    const joinLetter = this.getPlatformPathJoinLetter();
    if (joinLetter == "\\") {
      return Strings.replaceAll(targetPath, this.platFormIndependentPathJoinLetter, "\\");
    } else if (joinLetter == this.platFormIndependentPathJoinLetter) {
      return Strings.replaceAll(targetPath, "\\\\", this.platFormIndependentPathJoinLetter);
    } else {
      return targetPath;
    }
  }
  getPlatformIndependentPath(targetPath) {
    return Strings.replaceAll(targetPath, "\\\\", this.platFormIndependentPathJoinLetter);
  }
  getFileName(targetPath) {
    const piPath = this.getPlatformIndependentPath(targetPath);
    const lastIndex = Strings.lastIndexOf(piPath, this.platFormIndependentPathJoinLetter);
    if (lastIndex == -1) {
      return targetPath;
    } else {
      return Strings.substring(piPath, lastIndex + 1);
    }
  }
  getDirectoryPath(targetPath) {
    const piPath = this.getPlatformIndependentPath(targetPath);
    const lastIndex = Strings.lastIndexOf(piPath, this.platFormIndependentPathJoinLetter);
    if (lastIndex == -1) {
      return targetPath;
    } else {
      return Strings.substring(piPath, 0, lastIndex);
    }
  }
  isRelativePath(targetPath) {
    const piPath = this.getPlatformIndependentPath(targetPath);
    const lastIndex = Strings.lastIndexOf(piPath, this.platFormIndependentPathJoinLetter);
    if (lastIndex == -1) {
      return true;
    } else {
      return Strings.startsWith(targetPath, "./");
    }
  }
  getRelativePath(from, to) {
    return to;
  }
  resolveRelativePath(baseDirectoryPath, targetPath) {
    if (this.isRelativePath(targetPath)) {
      let localPath = targetPath;
      if (Strings.startsWith(targetPath, "./")) {
        localPath = Strings.substring(targetPath, 2);
      }
      return this.join(baseDirectoryPath, localPath);
    } else {
      return "";
    }
  }
  join(path1, path2) {
    return `${path1}${this.platFormIndependentPathJoinLetter}${path2}`;
  }
}
const _Platform = class {
  static supportsNative() {
    return typeof window.api != "undefined";
  }
  static getCurrentTime() {
    return performance.now();
  }
};
let Platform = _Platform;
Platform.clipboard = _Platform.supportsNative() ? window.api.clipboard : {
  async writeText(text) {
    window.localStorage.setItem("clipboard", text);
  },
  async readText() {
    return window.localStorage.getItem("clipboard");
  },
  async availableFormats() {
    return window.localStorage.getItem("clipboard") ? ["text/plain"] : null;
  }
};
Platform.path = new PlatformPath();
Platform.fileSystem = _Platform.supportsNative() ? window.api.fs : {
  async writeFile(filePath, data, format) {
    if (format == "base64") {
      const link = document.createElement("a");
      link.download = filePath;
      link.href = data;
      link.click();
    } else {
      const blob = new Blob([data], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.download = filePath;
      link.href = url;
      link.click();
    }
  },
  async getFileInfos(_directoryPath) {
    return [];
  },
  async getUserDefaultDocumentDirectory() {
    return "./";
  },
  async readUserDataFile(fileName) {
    return window.localStorage.getItem(fileName);
  },
  async writeUserDataFile(fileName, data) {
    window.localStorage.setItem(fileName, data);
  },
  async openFileDialog(defaultPath) {
    return null;
  }
};
class UserStorage {
  static async load(defaultData) {
    try {
      const text = await Platform.fileSystem.readUserDataFile(this.userDataFilePath);
      if (text == "" || text == null) {
        throw new Error("ERROR 0061:User data does not exists.");
      }
      this.data = JSON.parse(text);
      console.log("UserStrageData is loaded from native file.");
    } catch (e) {
      this.data = defaultData;
      console.log("UserStrageData is initialized by default.", e);
    }
  }
  static save() {
    Platform.fileSystem.writeUserDataFile(this.userDataFilePath, JSON.stringify(this.data)).then();
  }
  static setItem(key, value) {
    this.data[key] = value;
    this.save();
  }
  static getItem(key) {
    if (key in this.data) {
      return JSON.parse(JSON.stringify(this.data[key]));
    } else {
      return null;
    }
  }
}
UserStorage.userDataFilePath = "user-data.json";
UserStorage.data = {
  version: "0.0.0"
};
class CommandHistory {
  constructor() {
    this.maxHistory = 300;
    this.historyList = [];
    this.redoList = [];
  }
  executeCommand(command, ctx) {
    command.execute(ctx);
    command.defferedProcess.setFlags(ctx);
    this.addCommand(command);
  }
  addCommand(command) {
    this.historyList.push(command);
    if (this.historyList.length > this.maxHistory) {
      Lists.removeAt(this.historyList, 0);
    }
    if (this.redoList.length > 0) {
      this.redoList = [];
    }
  }
  getUndoCommand() {
    if (this.historyList.length == 0) {
      return null;
    }
    return this.historyList.at(-1);
  }
  getRedoCommand() {
    if (this.redoList.length == 0) {
      return null;
    }
    return this.redoList.at(-1);
  }
  undo(ctx) {
    let command = null;
    do {
      command = this.getUndoCommand();
      if (command == null) {
        return;
      }
      command.undo(ctx);
      command.defferedProcess.setFlags(ctx);
      this.redoList.push(command);
      this.historyList.pop();
    } while (command.isContinued);
  }
  redo(ctx) {
    let command = null;
    do {
      command = this.getRedoCommand();
      if (command == null) {
        return;
      }
      command.redo(ctx);
      command.defferedProcess.setFlags(ctx);
      this.redoList.pop();
      this.historyList.push(command);
      command = this.getRedoCommand();
    } while (command != null && command.isContinued);
  }
}
var OnionSkinMode = /* @__PURE__ */ ((OnionSkinMode2) => {
  OnionSkinMode2[OnionSkinMode2["none"] = 0] = "none";
  OnionSkinMode2[OnionSkinMode2["disabled"] = 1] = "disabled";
  OnionSkinMode2[OnionSkinMode2["showOnTopLayer"] = 2] = "showOnTopLayer";
  OnionSkinMode2[OnionSkinMode2["showOnLowestLayer"] = 3] = "showOnLowestLayer";
  return OnionSkinMode2;
})(OnionSkinMode || {});
class AnimationSettingData {
  constructor() {
    this.animationFrameParSecond = 24;
    this.loopStartFrame = 0;
    this.loopEndFrame = 24;
    this.maxFrame = 24;
    this.onionSkinMode = 1;
    this.onionSkinBackwardLevel = 1;
    this.onionSkinForwardLevel = 1;
    this.currentTimeFrame = 0;
    this.timeLineWindowScale = 1;
    this.timeLineWindowScaleMax = 10;
    this.timeLineWindowViewLocationX = 0;
  }
}
AnimationSettingData.MAX_ONION_SIKIN_FRAMES = 5;
var LayerTypeID = /* @__PURE__ */ ((LayerTypeID2) => {
  LayerTypeID2[LayerTypeID2["none"] = 0] = "none";
  LayerTypeID2[LayerTypeID2["rootLayer"] = 1] = "rootLayer";
  LayerTypeID2[LayerTypeID2["vectorLayer"] = 2] = "vectorLayer";
  LayerTypeID2[LayerTypeID2["groupLayer"] = 3] = "groupLayer";
  LayerTypeID2[LayerTypeID2["imageFileReferenceLayer"] = 4] = "imageFileReferenceLayer";
  LayerTypeID2[LayerTypeID2["posingLayer"] = 5] = "posingLayer";
  LayerTypeID2[LayerTypeID2["vectorLayerReferenceLayer"] = 6] = "vectorLayerReferenceLayer";
  LayerTypeID2[LayerTypeID2["autoFillLayer"] = 7] = "autoFillLayer";
  LayerTypeID2[LayerTypeID2["surroundingFillLayer"] = 8] = "surroundingFillLayer";
  LayerTypeID2[LayerTypeID2["pointBrushFillLayer"] = 9] = "pointBrushFillLayer";
  return LayerTypeID2;
})(LayerTypeID || {});
class Layer_RuntimeProperty {
  constructor() {
    this.needsPostUpdate = false;
    this.needsLazyUpdate = false;
    this.isHierarchicalVisible = true;
    this.isHierarchicalListVisible = true;
    this.parentLayer = null;
  }
}
const _Layer = class {
  constructor() {
    this.type = 0;
    this.name = null;
    this.isVisible = true;
    this.isSelected = false;
    this.isRenderTarget = true;
    this.isMaskedByBelowLayer = false;
    this.isListExpanded = true;
    this.childLayers = [];
    this.layerColor = vec4.fromValues(0, 0, 0, 1);
    this.runtime = new Layer_RuntimeProperty();
    this.hashID = _Layer.getHashID();
  }
  static getHashID() {
    return _Layer.hashIDCount++;
  }
  static isRootLayer(layer) {
    return layer != null && layer.type == 1;
  }
  static isEditTarget(layer) {
    return _Layer.isSelected(layer) && _Layer.isVisible(layer);
  }
  static isSelected(layer) {
    return layer.isSelected;
  }
  static isVisible(layer) {
    return layer != null && layer.isVisible && layer.runtime.isHierarchicalVisible;
  }
  static isListVisible(layer) {
    return layer != null && layer.isVisible && layer.runtime.isHierarchicalVisible;
  }
  static setLazyUpdateNeeded(layer) {
    layer.runtime.needsLazyUpdate = true;
  }
  static setPostUpdateNeeded(layer) {
    layer.runtime.needsPostUpdate = true;
  }
};
let Layer = _Layer;
Layer.hashIDCount = 1;
var FillAreaTypeID = /* @__PURE__ */ ((FillAreaTypeID2) => {
  FillAreaTypeID2[FillAreaTypeID2["none"] = 1] = "none";
  FillAreaTypeID2[FillAreaTypeID2["fillColor"] = 2] = "fillColor";
  FillAreaTypeID2[FillAreaTypeID2["paletteColor"] = 3] = "paletteColor";
  return FillAreaTypeID2;
})(FillAreaTypeID || {});
class GPULinePoint {
  constructor() {
    this.location = vec3.fromValues(0, 0, 0);
    this.width = 1;
    this.alpha = 1;
    this.isEndPoint = false;
    this.direction = vec3.fromValues(0, 0, 0);
    this.controlPointCF = vec3.fromValues(0, 0, 0);
    this.controlPointCB = vec3.fromValues(0, 0, 0);
    this.edgePointL = vec3.fromValues(0, 0, 0);
    this.controlPointLF = vec3.fromValues(0, 0, 0);
    this.controlPointLB = vec3.fromValues(0, 0, 0);
    this.edgePointR = vec3.fromValues(0, 0, 0);
    this.controlPointRF = vec3.fromValues(0, 0, 0);
    this.controlPointRB = vec3.fromValues(0, 0, 0);
    this.controlPointVertexLF = vec3.fromValues(0, 0, 0);
    this.controlPointVertexLB = vec3.fromValues(0, 0, 0);
    this.controlPointVertexRF = vec3.fromValues(0, 0, 0);
    this.controlPointVertexRB = vec3.fromValues(0, 0, 0);
    this.pointMat = mat4.create();
    this.invMat = mat4.create();
  }
  copyFrom(linePoint, lineWidthBiasRate, useAdjustingLocation) {
    if (useAdjustingLocation) {
      this.location[0] = linePoint.adjustingLocation[0];
      this.location[1] = linePoint.adjustingLocation[1];
      this.width = linePoint.adjustingLineWidth * lineWidthBiasRate;
      this.alpha = 1;
    } else {
      this.location[0] = linePoint.location[0];
      this.location[1] = linePoint.location[1];
      this.width = linePoint.lineWidth * lineWidthBiasRate;
      this.alpha = 1;
    }
    this.isEndPoint = false;
  }
}
class GPULine {
  constructor() {
    this.points = [];
  }
}
class GPUVertexBuffer {
  constructor() {
    this.pointCount = 0;
    this.recyclePoints = [];
    this.lines = [];
    this.dataArray = null;
    this.usedDataArraySize = 0;
    this.bufferSize = 0;
    this.buffer = null;
    this.isStored = false;
  }
}
class Logic_GPULine {
  constructor() {
    this.solidLinePolygonMap = [
      { cur: 1, loc: 2 },
      { cur: 2, loc: 2 },
      { cur: 1, loc: 5 },
      { cur: 1, loc: 5 },
      { cur: 2, loc: 2 },
      { cur: 2, loc: 5 }
    ];
    this.bezierPolygonMap = [
      { lr: 1, cur: 1, loc: 1 },
      { lr: 1, cur: 1, loc: 2 },
      { lr: 1, cur: 1, loc: 3 },
      { lr: 1, cur: 1, loc: 3 },
      { lr: 1, cur: 2, loc: 4 },
      { lr: 1, cur: 1, loc: 1 },
      { lr: 1, cur: 1, loc: 1 },
      { lr: 1, cur: 2, loc: 4 },
      { lr: 1, cur: 2, loc: 1 },
      { lr: 1, cur: 2, loc: 1 },
      { lr: 1, cur: 2, loc: 4 },
      { lr: 1, cur: 2, loc: 2 },
      { lr: 2, cur: 1, loc: 5 },
      { lr: 2, cur: 1, loc: 1 },
      { lr: 2, cur: 1, loc: 6 },
      { lr: 2, cur: 1, loc: 6 },
      { lr: 2, cur: 1, loc: 1 },
      { lr: 2, cur: 2, loc: 7 },
      { lr: 2, cur: 2, loc: 7 },
      { lr: 2, cur: 1, loc: 1 },
      { lr: 2, cur: 2, loc: 1 },
      { lr: 2, cur: 2, loc: 1 },
      { lr: 2, cur: 2, loc: 5 },
      { lr: 2, cur: 2, loc: 7 }
    ];
    this.vec = vec3.create();
    this.scale = vec3.create();
    this.direction = vec3.create();
    this.controlPointVec = vec3.create();
    this.normal = vec3.create();
    this.invMat = mat4.create();
    this.tempMat = mat4.create();
    this.calculateSegmentMat_Direction = vec3.create();
    this.relativeVecA = vec3.create();
    this.relativeVecB = vec3.create();
    this.relativeVecC = vec3.create();
    this.relativeVecD = vec3.create();
    this.relativeEdgePointVecA = vec3.create();
    this.relativeEdgePointVecB = vec3.create();
    this.relativeVecCenterFrom = vec3.create();
    this.relativeVecCenterTo = vec3.create();
    this.relativeVecEdgeFrom = vec3.create();
    this.relativeVecEdgeTo = vec3.create();
    this.minimumSegmentDistance = 1e-3;
  }
  copyGroupPointDataToBuffer(group, lineWidthBiasRate, useAdjustingLocation) {
    const vertexBuffer = group.runtime.buffer;
    let pointCount = 0;
    vertexBuffer.lines = [];
    for (const line of group.lines) {
      const gpuLine = new GPULine();
      let lastLinePoint = null;
      for (const linePoint of line.points) {
        let gpuPoint;
        if (lastLinePoint != null && vec3.distance(lastLinePoint.location, linePoint.location) < this.minimumSegmentDistance) {
          continue;
        }
        if (pointCount < vertexBuffer.recyclePoints.length) {
          gpuPoint = vertexBuffer.recyclePoints[pointCount];
        } else {
          gpuPoint = new GPULinePoint();
          vertexBuffer.recyclePoints.push(gpuPoint);
        }
        gpuPoint.copyFrom(linePoint, lineWidthBiasRate, useAdjustingLocation);
        gpuLine.points.push(gpuPoint);
        pointCount++;
        lastLinePoint = linePoint;
      }
      if (gpuLine.points.length < 2) {
        continue;
      }
      vertexBuffer.lines.push(gpuLine);
    }
    vertexBuffer.pointCount = pointCount;
  }
  allocateBuffer(vertexBuffer, vertexCount, vertexUnitSize, render) {
    const bufferSize = vertexCount * vertexUnitSize;
    if (vertexBuffer.buffer == null) {
      vertexBuffer.buffer = render.createBuffer();
      vertexBuffer.dataArray = new Float32Array(bufferSize);
    } else if (bufferSize > vertexBuffer.bufferSize) {
      vertexBuffer.dataArray = new Float32Array(bufferSize);
    }
    vertexBuffer.bufferSize = bufferSize;
  }
  calculateLinePointEdges(vertexBuffer) {
    const direction = this.direction;
    const normal = this.normal;
    for (const line of vertexBuffer.lines) {
      const gpuPoints = line.points;
      for (let index2 = 0; index2 < gpuPoints.length; index2++) {
        const gpuPoint = gpuPoints[index2];
        let gpuPointPrev;
        let gpuPointNext;
        let width;
        if (index2 == 0) {
          gpuPointPrev = gpuPoints[index2];
          gpuPointNext = gpuPoints[index2 + 1];
          width = gpuPointPrev.width;
        } else if (index2 == gpuPoints.length - 1) {
          gpuPointPrev = gpuPoints[index2 - 1];
          gpuPointNext = gpuPoints[index2];
          width = gpuPointNext.width;
          gpuPoint.isEndPoint = true;
        } else {
          gpuPointPrev = gpuPoints[index2 - 1];
          gpuPointNext = gpuPoints[index2 + 1];
          width = gpuPoint.width;
        }
        vec3.subtract(gpuPoint.direction, gpuPointNext.location, gpuPointPrev.location);
        vec3.normalize(gpuPoint.direction, gpuPoint.direction);
        vec3.set(normal, gpuPoint.direction[1], -gpuPoint.direction[0], 0);
        vec3.scale(normal, normal, width * 0.5);
        vec3.subtract(gpuPoint.edgePointL, gpuPoint.location, normal);
        vec3.add(gpuPoint.edgePointR, gpuPoint.location, normal);
      }
      if (gpuPoints.length >= 2) {
        {
          const point = gpuPoints[0];
          const pointTo = gpuPoints[1];
          vec3.subtract(direction, pointTo.location, point.location);
          vec3.scale(direction, direction, 0.33);
          vec3.add(point.controlPointCF, point.location, direction);
          vec3.add(point.controlPointLF, point.edgePointL, direction);
          vec3.add(point.controlPointRF, point.edgePointR, direction);
        }
        {
          const point = gpuPoints[gpuPoints.length - 1];
          const pointTo = gpuPoints[gpuPoints.length - 2];
          vec3.subtract(direction, pointTo.location, point.location);
          vec3.scale(direction, direction, 0.33);
          vec3.add(point.controlPointCB, point.location, direction);
          vec3.add(point.controlPointLB, point.edgePointL, direction);
          vec3.add(point.controlPointRB, point.edgePointR, direction);
        }
      }
    }
  }
  calculateLinePointBezierLocation(vertexBuffer) {
    for (const line of vertexBuffer.lines) {
      const gpuPoints = line.points;
      for (let index2 = 0; index2 < gpuPoints.length - 1; index2++) {
        const linePoint = gpuPoints[index2];
        if (index2 + 1 < gpuPoints.length) {
          const linePointNext = gpuPoints[index2 + 1];
          this.calculateSegmentMat(linePoint.pointMat, linePoint.location, linePointNext.location);
          mat4.invert(linePoint.invMat, linePoint.pointMat);
        }
        if (index2 - 1 >= 0 && index2 + 1 < gpuPoints.length) {
          const linePointPrev = gpuPoints[index2 - 1];
          const linePointNext = gpuPoints[index2 + 1];
          this.calculateControlPoint(
            linePoint.controlPointCF,
            linePoint.controlPointCB,
            linePoint.direction,
            linePoint.location,
            linePointPrev.location,
            linePointNext.location
          );
          this.calculateControlPoint(
            linePoint.controlPointLF,
            linePoint.controlPointLB,
            linePoint.direction,
            linePoint.edgePointL,
            linePointPrev.edgePointL,
            linePointNext.edgePointL
          );
          this.calculateControlPoint(
            linePoint.controlPointRF,
            linePoint.controlPointRB,
            linePoint.direction,
            linePoint.edgePointR,
            linePointPrev.edgePointR,
            linePointNext.edgePointR
          );
        }
      }
      if (gpuPoints.length > 2) {
        const linePoint = gpuPoints[0];
        const linePointNext = gpuPoints[1];
        this.calculateMirroredPoint(
          linePoint.controlPointCF,
          null,
          linePoint.location,
          linePoint.location,
          linePoint.width,
          linePointNext.location,
          linePointNext.location,
          linePointNext.controlPointCB,
          linePoint.pointMat,
          linePoint.invMat
        );
        this.calculateMirroredPoint(
          linePoint.controlPointLF,
          linePoint.edgePointL,
          linePoint.location,
          linePoint.edgePointL,
          linePoint.width,
          linePointNext.location,
          linePointNext.edgePointL,
          linePointNext.controlPointLB,
          linePoint.pointMat,
          linePoint.invMat
        );
        this.calculateMirroredPoint(
          linePoint.controlPointRF,
          linePoint.edgePointR,
          linePoint.location,
          linePoint.edgePointR,
          linePoint.width,
          linePointNext.location,
          linePointNext.edgePointR,
          linePointNext.controlPointRB,
          linePoint.pointMat,
          linePoint.invMat
        );
      }
      if (gpuPoints.length > 2) {
        const linePoint = gpuPoints[gpuPoints.length - 1];
        const linePointNext = gpuPoints[gpuPoints.length - 2];
        this.calculateMirroredPoint(
          linePoint.controlPointCB,
          null,
          linePoint.location,
          linePoint.location,
          linePoint.width,
          linePointNext.location,
          linePointNext.location,
          linePointNext.controlPointCF,
          linePointNext.pointMat,
          linePointNext.invMat
        );
        this.calculateMirroredPoint(
          linePoint.controlPointLB,
          linePoint.edgePointL,
          linePoint.location,
          linePoint.edgePointL,
          linePoint.width,
          linePointNext.location,
          linePointNext.edgePointL,
          linePointNext.controlPointLF,
          linePointNext.pointMat,
          linePointNext.invMat
        );
        this.calculateMirroredPoint(
          linePoint.controlPointRB,
          linePoint.edgePointR,
          linePoint.location,
          linePoint.edgePointR,
          linePoint.width,
          linePointNext.location,
          linePointNext.edgePointR,
          linePointNext.controlPointRF,
          linePointNext.pointMat,
          linePointNext.invMat
        );
      }
    }
  }
  calculateSegmentMat(result, locationFrom, locationTo) {
    vec3.subtract(this.calculateSegmentMat_Direction, locationTo, locationFrom);
    vec3.normalize(this.calculateSegmentMat_Direction, this.calculateSegmentMat_Direction);
    mat4.identity(result);
    result[0] = this.calculateSegmentMat_Direction[0];
    result[1] = this.calculateSegmentMat_Direction[1];
    result[4] = -this.calculateSegmentMat_Direction[1];
    result[5] = this.calculateSegmentMat_Direction[0];
    result[10] = 1;
    result[12] = locationFrom[0];
    result[13] = locationFrom[1];
  }
  calculateControlPoint(resultF, resultB, direction, edgePointC, edgePointB, edgePointF) {
    const distanceF = vec3.distance(edgePointF, edgePointC);
    vec3.scale(this.controlPointVec, direction, distanceF * 0.33);
    vec3.add(resultF, edgePointC, this.controlPointVec);
    const distanceB = vec3.distance(edgePointB, edgePointC);
    vec3.scale(this.controlPointVec, direction, -distanceB * 0.33);
    vec3.add(resultB, edgePointC, this.controlPointVec);
  }
  calculateMirroredPoint(resultControlPoint, resultEdgePoint, centerPointFrom, edgePointfrom, radiusFrom, centerPointTo, edgePointTo, controlPointTo, pointMat, invMat) {
    if (resultEdgePoint != null) {
      vec3.transformMat4(this.relativeVecCenterTo, centerPointTo, invMat);
      vec3.transformMat4(this.relativeVecCenterFrom, centerPointFrom, invMat);
      vec3.transformMat4(this.relativeVecA, edgePointTo, invMat);
      vec3.subtract(this.relativeVecB, this.relativeVecA, this.relativeVecCenterTo);
      const length = vec3.length(this.relativeVecB);
      if (length > 0) {
        vec3.scale(this.relativeVecB, this.relativeVecB, radiusFrom / length);
      } else {
        vec3.set(this.relativeVecB, 0, 0, 0);
      }
      this.relativeVecB[0] = this.relativeVecB[0] * -1 + this.relativeVecCenterFrom[0];
      this.relativeVecB[1] = this.relativeVecB[1] + this.relativeVecCenterFrom[1];
      this.relativeVecB[2] = 0;
      vec3.transformMat4(resultEdgePoint, this.relativeVecB, pointMat);
    }
    if (resultControlPoint != null) {
      vec3.transformMat4(this.relativeVecEdgeTo, edgePointTo, invMat);
      vec3.transformMat4(this.relativeVecEdgeFrom, edgePointfrom, invMat);
      vec3.transformMat4(this.relativeVecA, controlPointTo, invMat);
      this.relativeVecB[0] = (this.relativeVecA[0] - this.relativeVecEdgeTo[0]) * -1 + this.relativeVecEdgeFrom[0];
      this.relativeVecB[1] = this.relativeVecA[1] - this.relativeVecEdgeTo[1] + this.relativeVecEdgeFrom[1];
      this.relativeVecB[2] = 0;
      vec3.transformMat4(resultControlPoint, this.relativeVecB, pointMat);
    }
  }
  calculateControlPointVertexLocations(vertexBuffer) {
    for (const line of vertexBuffer.lines) {
      for (let index2 = 0; index2 < line.points.length - 1; index2++) {
        const linePoint = line.points[index2];
        const linePointNext = line.points[index2 + 1];
        this.calculateControlPointVertexLocation(
          linePoint.controlPointVertexLF,
          linePoint.edgePointL,
          linePoint.controlPointLF,
          linePointNext.edgePointL,
          linePointNext.controlPointLB,
          1
        );
        this.calculateControlPointVertexLocation(
          linePoint.controlPointVertexRF,
          linePoint.edgePointR,
          linePoint.controlPointRF,
          linePointNext.edgePointR,
          linePointNext.controlPointRB,
          -1
        );
      }
      for (let index2 = 1; index2 < line.points.length; index2++) {
        const linePoint = line.points[index2];
        const linePointPrev = line.points[index2 - 1];
        this.calculateControlPointVertexLocation(
          linePoint.controlPointVertexLB,
          linePoint.edgePointL,
          linePoint.controlPointLB,
          linePointPrev.edgePointL,
          linePointPrev.controlPointLF,
          -1
        );
        this.calculateControlPointVertexLocation(
          linePoint.controlPointVertexRB,
          linePoint.edgePointR,
          linePoint.controlPointRB,
          linePointPrev.edgePointR,
          linePointPrev.controlPointRF,
          1
        );
      }
    }
  }
  calculateControlPointVertexLocation(controlPointVertexLF, edgePointFrom, controlPointFrom, edgePointTo, controlPointTo, flipY) {
    this.calculateSegmentMat(this.tempMat, edgePointFrom, edgePointTo);
    mat4.invert(this.invMat, this.tempMat);
    vec3.transformMat4(this.relativeEdgePointVecA, edgePointFrom, this.invMat);
    vec3.transformMat4(this.relativeVecA, controlPointFrom, this.invMat);
    vec3.transformMat4(this.relativeVecB, controlPointTo, this.invMat);
    if (this.relativeVecB[1] * flipY < 0) {
      vec3.transformMat4(this.relativeVecB, edgePointTo, this.invMat);
    }
    const tiltX = this.relativeVecB[0] - this.relativeEdgePointVecA[0];
    const tiltY = this.relativeVecB[1] - this.relativeEdgePointVecA[1];
    if (tiltX == 0) {
      return;
    }
    const deltaX = this.relativeVecA[0] - this.relativeEdgePointVecA[0];
    const localY = tiltY / tiltX * deltaX + this.relativeEdgePointVecA[1];
    if (this.relativeVecA[1] * flipY < localY * flipY) {
      controlPointVertexLF[0] = this.relativeVecA[0];
      controlPointVertexLF[1] = localY;
      controlPointVertexLF[2] = 0;
      vec3.transformMat4(controlPointVertexLF, controlPointVertexLF, this.tempMat);
    } else {
      vec3.copy(controlPointVertexLF, controlPointFrom);
    }
  }
  calculateBufferData_PloyLine(vertexBuffer) {
    const data = vertexBuffer.dataArray;
    let offset = 0;
    for (const line of vertexBuffer.lines) {
      for (let index2 = 0; index2 < line.points.length - 1; index2++) {
        const linePoint = line.points[index2];
        const linePointNext = line.points[index2 + 1];
        if (linePoint.isEndPoint) {
          continue;
        }
        for (const map of this.solidLinePolygonMap) {
          let point;
          if (map.cur == 1) {
            point = linePoint;
          } else {
            point = linePointNext;
          }
          let vec;
          if (map.loc == 1) {
            vec = point.location;
          } else if (map.loc == 2) {
            vec = point.edgePointL;
          } else if (map.loc == 5) {
            vec = point.edgePointR;
          }
          data[offset++] = vec[0];
          data[offset++] = vec[1];
        }
      }
    }
    vertexBuffer.usedDataArraySize = offset;
  }
  calculateBufferData_BezierLine(vertexBuffer) {
    const data = vertexBuffer.dataArray;
    let offset = 0;
    for (const line of vertexBuffer.lines) {
      {
        const linePoint = line.points[0];
        const linePointNext = line.points[1];
        offset = this.calculateBufferData_AddBezierCapPoints(data, offset, linePoint, linePointNext, true);
      }
      {
        const linePoint = line.points[line.points.length - 2];
        const linePointNext = line.points[line.points.length - 1];
        offset = this.calculateBufferData_AddBezierCapPoints(data, offset, linePoint, linePointNext, false);
      }
      for (let index2 = 0; index2 < line.points.length - 1; index2++) {
        const linePoint = line.points[index2];
        const linePointNext = line.points[index2 + 1];
        for (const map of this.bezierPolygonMap) {
          let point;
          if (map.cur == 1) {
            point = linePoint;
          } else {
            point = linePointNext;
          }
          let vec;
          if (map.loc == 1) {
            vec = point.location;
          } else if (map.loc == 2) {
            vec = point.edgePointL;
          } else if (map.loc == 3) {
            vec = point.controlPointVertexLF;
          } else if (map.loc == 4) {
            vec = point.controlPointVertexLB;
          } else if (map.loc == 5) {
            vec = point.edgePointR;
          } else if (map.loc == 6) {
            vec = point.controlPointVertexRF;
          } else if (map.loc == 7) {
            vec = point.controlPointVertexRB;
          }
          offset = this.calculateBufferData_AddBezierPoint(
            data,
            offset,
            vec,
            linePoint,
            linePointNext,
            1,
            linePoint.width,
            linePointNext.width
          );
        }
      }
    }
    vertexBuffer.usedDataArraySize = offset;
  }
  calculateBufferData_AddBezierPoint(data, offset, vec, linePoint, linePointNext, flipY, widthFrom, widthTo) {
    data[offset++] = vec[0];
    data[offset++] = vec[1];
    vec3.transformMat4(this.relativeVecA, vec, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1] * flipY;
    const length = vec3.distance(linePoint.location, linePointNext.location);
    data[offset++] = this.relativeVecA[0] / length;
    vec3.transformMat4(this.relativeVecA, linePoint.location, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePoint.controlPointCF, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePointNext.controlPointCB, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePointNext.location, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePoint.edgePointR, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePoint.controlPointRF, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePointNext.controlPointRB, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    vec3.transformMat4(this.relativeVecA, linePointNext.edgePointR, linePoint.invMat);
    data[offset++] = this.relativeVecA[0];
    data[offset++] = this.relativeVecA[1];
    data[offset++] = widthFrom * 0.5;
    data[offset++] = widthTo * 0.5;
    return offset;
  }
  calculateBufferData_AddBezierCapPoints(data, offset, linePoint, linePointNext, isTopCap) {
    const capPoint = isTopCap ? linePoint : linePointNext;
    const direction = isTopCap ? 1 : -1;
    const capTopRelativeX = -(capPoint.edgePointL[1] - capPoint.location[1]) * direction;
    const capTopRelativeY = (capPoint.edgePointL[0] - capPoint.location[0]) * direction;
    const leftTopX = capPoint.edgePointL[0] + capTopRelativeX;
    const leftTopY = capPoint.edgePointL[1] + capTopRelativeY;
    const rightTopX = capPoint.edgePointR[0] + capTopRelativeX;
    const rightTopY = capPoint.edgePointR[1] + capTopRelativeY;
    const width = isTopCap ? linePoint.width : linePointNext.width;
    vec3.set(this.vec, leftTopX, leftTopY, 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    vec3.set(this.vec, capPoint.edgePointL[0], capPoint.edgePointL[1], 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    vec3.set(this.vec, capPoint.edgePointR[0], capPoint.edgePointR[1], 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    vec3.set(this.vec, capPoint.edgePointR[0], capPoint.edgePointR[1], 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    vec3.set(this.vec, rightTopX, rightTopY, 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    vec3.set(this.vec, leftTopX, leftTopY, 0);
    offset = this.calculateBufferData_AddBezierPoint(data, offset, this.vec, linePoint, linePointNext, 1, width, width);
    return offset;
  }
  bufferData(vertexBuffer, render) {
    render.bufferDataOnce(vertexBuffer.buffer, vertexBuffer.dataArray);
    vertexBuffer.isStored = true;
  }
}
class CanvasWindow {
  constructor() {
    this.canvas = null;
    this.context = null;
    this.devicePixelRatio = 1;
    this.width = 0;
    this.height = 0;
    this.viewLocation = vec3.fromValues(0, 0, 0);
    this.centerLocationRate = vec3.fromValues(0, 0, 0);
    this.viewScale = 1;
    this.viewRotation = 0;
    this.mirrorX = false;
    this.mirrorY = false;
    this.maxViewScale = 50;
    this.minViewScale = 0.01;
    this.transformMatrix = mat4.create();
    this.tempVec3 = vec3.create();
    this.tmpMatrix = mat4.create();
  }
  createCanvas(width, height, willReadFrequently = false) {
    this.attachCanvas(document.createElement("canvas"));
    if (width && height) {
      this.setCanvasSize(width, height);
      this.initializeContext(willReadFrequently);
    }
  }
  attachCanvas(canvas) {
    this.canvas = canvas;
    this.devicePixelRatio = window.devicePixelRatio;
    this.width = canvas.width;
    this.height = canvas.height;
  }
  releaseCanvas() {
    const canvas = this.canvas;
    this.canvas = null;
    return canvas;
  }
  setCanvasSize(width, height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width;
    this.height = height;
  }
  initializeContext(willReadFrequently = false) {
    this.context = this.canvas.getContext("2d", { willReadFrequently });
  }
  isInitialized() {
    return this.canvas != null && this.context != null;
  }
  isSameMetrics(targetWindow) {
    return this.isInitialized() && targetWindow.isInitialized() && targetWindow.width == this.width && targetWindow.height == this.height;
  }
  copyTransformTo(targetWindow) {
    vec3.copy(targetWindow.viewLocation, this.viewLocation);
    vec3.copy(targetWindow.centerLocationRate, this.centerLocationRate);
    targetWindow.viewScale = this.viewScale;
    targetWindow.viewRotation = this.viewRotation;
    targetWindow.mirrorX = this.mirrorX;
    targetWindow.mirrorY = this.mirrorY;
    mat4.copy(targetWindow.transformMatrix, this.transformMatrix);
  }
  addViewScale(addScale) {
    this.viewScale *= addScale;
    this.fixViewScale();
  }
  fixViewRotation() {
    if (this.viewRotation >= 360) {
      this.viewRotation -= 360;
    }
    if (this.viewRotation <= 0) {
      this.viewRotation += 360;
    }
  }
  fixViewScale() {
    if (this.viewScale >= this.maxViewScale) {
      this.viewScale = this.maxViewScale;
    }
    if (this.viewScale <= this.minViewScale) {
      this.viewScale = this.minViewScale;
    }
  }
  updateViewMatrix() {
    this.caluclateViewMatrix(this.transformMatrix);
  }
  caluclateViewMatrix(result) {
    mat4.identity(result);
    mat4.translate(result, result, vec3.set(this.tempVec3, this.width * this.centerLocationRate[0], this.height * this.centerLocationRate[0], 0));
    mat4.scale(result, result, vec3.set(this.tempVec3, this.viewScale, this.viewScale, 1));
    if (this.mirrorX) {
      mat4.scale(result, result, vec3.set(this.tempVec3, -1, 1, 1));
    }
    if (this.mirrorY) {
      mat4.scale(result, result, vec3.set(this.tempVec3, 1, -1, 1));
    }
    mat4.rotateZ(result, result, this.viewRotation * Math.PI / 180);
    mat4.translate(result, result, vec3.set(this.tempVec3, -this.viewLocation[0], -this.viewLocation[1], 0));
  }
  caluclateGLViewMatrix(result) {
    const viewScale = this.viewScale;
    const aspect = this.height / this.width;
    const real2DViewHalfWidth = this.width / 2 / viewScale;
    const real2DViewHalfHeight = this.height / 2 / viewScale;
    const viewOffsetX = -this.viewLocation[0] / real2DViewHalfWidth;
    const viewOffsetY = this.viewLocation[1] / real2DViewHalfHeight;
    mat4.identity(this.tmpMatrix);
    mat4.scale(this.tmpMatrix, this.tmpMatrix, vec3.set(this.tempVec3, aspect, 1, 1));
    if (this.mirrorX) {
      mat4.scale(this.tmpMatrix, this.tmpMatrix, vec3.set(this.tempVec3, -1, 1, 1));
    }
    if (this.mirrorY) {
      mat4.scale(this.tmpMatrix, this.tmpMatrix, vec3.set(this.tempVec3, 1, -1, 1));
    }
    mat4.rotateZ(this.tmpMatrix, this.tmpMatrix, -this.viewRotation * Math.PI / 180);
    mat4.translate(result, this.tmpMatrix, vec3.set(this.tempVec3, viewOffsetX / aspect, viewOffsetY, 0));
  }
  calculateViewUnitMatrix(result) {
    mat4.identity(result);
    mat4.scale(result, result, vec3.set(this.tempVec3, this.viewScale, this.viewScale, 1));
    mat4.rotateZ(result, result, this.viewRotation * Math.PI / 180);
  }
  getViewScaledLength(length) {
    return length / this.viewScale;
  }
}
var CanvasRenderBlendMode = /* @__PURE__ */ ((CanvasRenderBlendMode2) => {
  CanvasRenderBlendMode2[CanvasRenderBlendMode2["default"] = 0] = "default";
  CanvasRenderBlendMode2[CanvasRenderBlendMode2["alphaOver"] = 1] = "alphaOver";
  CanvasRenderBlendMode2[CanvasRenderBlendMode2["add"] = 2] = "add";
  CanvasRenderBlendMode2[CanvasRenderBlendMode2["sourceAtop"] = 3] = "sourceAtop";
  CanvasRenderBlendMode2[CanvasRenderBlendMode2["destinationIn"] = 4] = "destinationIn";
  return CanvasRenderBlendMode2;
})(CanvasRenderBlendMode || {});
var CanvasRenderLineCap = /* @__PURE__ */ ((CanvasRenderLineCap2) => {
  CanvasRenderLineCap2[CanvasRenderLineCap2["butt"] = 0] = "butt";
  CanvasRenderLineCap2[CanvasRenderLineCap2["round"] = 1] = "round";
  CanvasRenderLineCap2[CanvasRenderLineCap2["square"] = 2] = "square";
  return CanvasRenderLineCap2;
})(CanvasRenderLineCap || {});
class CanvasRender {
  constructor() {
    this.context = null;
    this.canvasWindow = null;
    this.currentTransform = mat4.create();
    this.tempMat = mat4.create();
    this.lastFontHeight = 0;
    this.strokeDashEmpty = [];
  }
  get transformMatrix() {
    return this.canvasWindow.transformMatrix;
  }
  get canvasWidth() {
    return this.canvasWindow.width;
  }
  get canvasHeight() {
    return this.canvasWindow.height;
  }
  setContext(canvasWindow) {
    this.context = canvasWindow.context;
    this.canvasWindow = canvasWindow;
    this.lastFontHeight = 0;
    canvasWindow.updateViewMatrix();
    this.copyTransformFromWindow(canvasWindow);
  }
  getViewScale() {
    return this.canvasWindow.viewScale;
  }
  getViewScaledSize(size) {
    return size / this.canvasWindow.viewScale;
  }
  resetTransform() {
    mat4.identity(this.tempMat);
    this.setTransformFromMatrix(this.tempMat);
  }
  copyTransformFromWindow(canvasWindow) {
    mat4.copy(this.currentTransform, canvasWindow.transformMatrix);
    this.setTransformFromMatrix(canvasWindow.transformMatrix);
  }
  setTransformFromMatrix(matrix) {
    CanvasRender.setTransformMat4(this.context, matrix);
  }
  static setTransformMat4(context, matrix) {
    context.setTransform(
      matrix[0],
      matrix[1],
      matrix[4],
      matrix[5],
      matrix[12],
      matrix[13]
    );
  }
  setLocalTransform(matrix) {
    mat4.multiply(this.tempMat, this.currentTransform, matrix);
    this.setTransformFromMatrix(this.tempMat);
  }
  cancelLocalTransform() {
    this.setTransformFromMatrix(this.currentTransform);
  }
  isInViewRectangle(location, range) {
    const centerX = this.canvasWindow.viewLocation[0];
    const centerY = this.canvasWindow.viewLocation[0];
    const distance = Math.sqrt(Math.pow(location[0] - centerX, 2) + Math.pow(location[1] - centerY, 2));
    const rangeX = Math.max(centerX, this.canvasWidth - centerX);
    const rangeY = Math.max(centerY, this.canvasHeight - centerY);
    const viewRange = Math.sqrt(rangeX * rangeX + rangeY * rangeY) / this.canvasWindow.viewScale;
    return distance - range < viewRange;
  }
  getColorStyleText(r2, g, b, a) {
    return "rgba(" + (r2 * 255).toFixed(0) + "," + (g * 255).toFixed(0) + "," + (b * 255).toFixed(0) + "," + a.toFixed(2) + ")";
  }
  getColorStyleTextV(color) {
    return this.getColorStyleText(color[0], color[1], color[2], color[3]);
  }
  setFillColor(r2, g, b, a) {
    this.context.fillStyle = this.getColorStyleText(r2, g, b, a);
  }
  setFillColorV(color) {
    this.setFillColor(color[0], color[1], color[2], color[3]);
  }
  createRadialGradient(x2, y2, radius) {
    return this.context.createRadialGradient(x2, y2, 0, x2, y2, radius);
  }
  setFillGradiaent(gradient) {
    this.context.fillStyle = gradient;
  }
  setFillLinearGradient(x0, y0, x1, y1, color1, color2) {
    const grad = this.context.createLinearGradient(x0, y0, x1, y1);
    grad.addColorStop(0, this.getColorStyleTextV(color1));
    grad.addColorStop(1, this.getColorStyleTextV(color2));
    this.context.fillStyle = grad;
  }
  setFillRadialGradient(x2, y2, r1, r2, color1, color2) {
    const grad = this.context.createRadialGradient(x2, y2, r1, x2, y2, r2);
    grad.addColorStop(0, this.getColorStyleTextV(color1));
    grad.addColorStop(1, this.getColorStyleTextV(color2));
    this.context.fillStyle = grad;
  }
  setStrokeWidth(width) {
    this.context.lineWidth = width;
  }
  setStrokeColor(r2, g, b, a) {
    this.context.strokeStyle = this.getColorStyleText(r2, g, b, a);
  }
  setStrokeColorV(color) {
    this.setStrokeColor(color[0], color[1], color[2], color[3]);
  }
  setLineDash(segments) {
    this.context.setLineDash(segments);
  }
  clearLineDash() {
    this.context.setLineDash(this.strokeDashEmpty);
  }
  setGlobalAlpha(a) {
    this.context.globalAlpha = a;
  }
  setBlendMode(blendMode) {
    switch (blendMode) {
      case 0:
      case 1:
        this.context.globalCompositeOperation = "source-over";
        break;
      case 3:
        this.context.globalCompositeOperation = "source-atop";
        break;
      case 4:
        this.context.globalCompositeOperation = "destination-in";
        break;
      case 2:
        this.context.globalCompositeOperation = "lighter";
        break;
    }
  }
  setLineCap(lineCap) {
    this.context.lineCap = CanvasRenderLineCap[lineCap];
  }
  beginPath() {
    this.context.beginPath();
  }
  closePath() {
    this.context.closePath();
  }
  beginPathPoints(pathPoints) {
    this.beginPath();
    this.pathPoints(pathPoints);
  }
  pathPoints(pathPoints) {
    this.moveToV(pathPoints[0]);
    for (const point of pathPoints) {
      this.lineToV(point);
    }
  }
  strokePath(pathPoints) {
    this.beginPathPoints(pathPoints);
    this.stroke();
  }
  fillPath(pathPoints) {
    this.beginPathPoints(pathPoints);
    this.fill();
  }
  stroke() {
    this.context.stroke();
  }
  fill() {
    this.context.fill();
  }
  moveTo(x2, y2) {
    this.context.moveTo(x2, y2);
  }
  moveToV(location) {
    this.context.moveTo(location[0], location[1]);
  }
  lineTo(x2, y2) {
    this.context.lineTo(x2, y2);
  }
  lineToV(location) {
    this.context.lineTo(location[0], location[1]);
  }
  clear() {
    mat4.copy(this.tempMat, this.canvasWindow.transformMatrix);
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvasWindow.width, this.canvasWindow.height);
    this.setTransformFromMatrix(this.tempMat);
  }
  clearRect(left, top, width, height) {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(left, top, width, height);
    this.cancelLocalTransform();
  }
  strokeRect(left, top, width, height) {
    this.context.strokeRect(left, top, width, height);
  }
  fillRect(left, top, width, height) {
    this.context.fillRect(left, top, width, height);
  }
  strokeRoundRect(x2, y2, width, height, rounded) {
    this.pathRoundRect(x2, y2, width, height, rounded);
    this.context.stroke();
  }
  fillRoundRect(x2, y2, width, height, rounded) {
    this.pathRoundRect(x2, y2, width, height, rounded);
    this.context.fill();
  }
  pathRoundRect(x2, y2, width, height, rounded) {
    const halfRadians = 2 * Math.PI / 2;
    const quarterRadians = 2 * Math.PI / 4;
    this.context.beginPath();
    this.context.arc(rounded + x2, rounded + y2, rounded, -quarterRadians, halfRadians, true);
    this.context.lineTo(x2, y2 + height - rounded);
    this.context.arc(rounded + x2, height - rounded + y2, rounded, halfRadians, quarterRadians, true);
    this.context.lineTo(x2 + width - rounded, y2 + height);
    this.context.arc(x2 + width - rounded, y2 + height - rounded, rounded, quarterRadians, 0, true);
    this.context.lineTo(x2 + width, y2 + rounded);
    this.context.arc(x2 + width - rounded, y2 + rounded, rounded, 0, -quarterRadians, true);
    this.context.closePath();
  }
  drawLine(x1, y1, x2, y2) {
    this.context.beginPath();
    this.context.moveTo(x1, y1);
    this.context.lineTo(x2, y2);
    this.context.stroke();
  }
  circle(x2, y2, radius) {
    this.context.arc(x2, y2, radius, 0, Math.PI * 2);
  }
  drawImage(image, srcX, srcY, srcW, srcH, dstX, detY, dstW, dstH) {
    this.context.drawImage(image, srcX, srcY, srcW, srcH, dstX, detY, dstW, dstH);
  }
  putImageData(imageData, destX, destY) {
    this.context.putImageData(imageData, destX, destY);
  }
  setFontSize(height) {
    if (height != this.lastFontHeight) {
      this.context.font = `${height.toFixed(0)}px 'MS Gothic', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Osaka-Mono', 'Noto Sans JP', monospace`;
    }
  }
  fillText(text, x2, y2, horizontalCenter = false, verticalCenter = false) {
    this.strokeOrFillText(true, text, x2, y2, horizontalCenter, verticalCenter);
  }
  strokeText(text, x2, y2, horizontalCenter = false, verticalCenter = false) {
    this.strokeOrFillText(false, text, x2, y2, horizontalCenter, verticalCenter);
  }
  strokeOrFillText(fill, text, x2, y2, horizontalCenter = false, verticalCenter = false) {
    if (verticalCenter || horizontalCenter) {
      const metrics = this.context.measureText(text);
      if (horizontalCenter) {
        x2 -= metrics.width / 2;
      }
      if (verticalCenter) {
        y2 += (metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent) / 2;
      }
    }
    if (fill) {
      this.context.fillText(text, x2, y2);
    } else {
      this.context.lineJoin = "round";
      this.context.strokeText(text, x2, y2);
      this.context.lineJoin = "miter";
    }
  }
  pickColor(outColor, x2, y2) {
    const imageData = this.context.getImageData(Math.floor(x2), Math.floor(y2), 1, 1);
    vec4.set(
      outColor,
      imageData.data[0] / 255,
      imageData.data[1] / 255,
      imageData.data[2] / 255,
      imageData.data[3] / 255
    );
  }
}
class RenderModel {
  constructor() {
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.vertexData = null;
    this.indexData = null;
    this.indexCount = 0;
    this.vertexDataStride = 0;
  }
}
class RenderImage {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.texture = null;
    this.imageData = null;
  }
}
class RenderShader {
  constructor() {
    this.floatPrecisionDefinitionCode = "";
    this.vertexShaderSourceCode = "";
    this.fragmentShaderSourceCode = "";
    this.vertexShader = null;
    this.fragmentShader = null;
    this.program = null;
    this.attribLocationList = [];
    this.vertexAttribPointerOffset = 0;
    this.uPMatrix = null;
    this.uMVMatrix = null;
  }
  isAvailable() {
    return this.gl != null;
  }
  isDisabled() {
    return this.gl == null;
  }
  initializeSourceCode(precisionText) {
    this.floatPrecisionDefinitionCode = "#ifdef GL_ES\n precision " + precisionText + " float;\n #endif\n";
    this.initializeVertexSourceCode();
    this.initializeFragmentSourceCode();
  }
  initializeVertexSourceCode() {
  }
  initializeFragmentSourceCode() {
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
  }
  initializeAttributes_RenderShader() {
    if (this.isDisabled()) {
      return;
    }
    this.uPMatrix = this.getUniformLocation("uPMatrix");
    this.uMVMatrix = this.getUniformLocation("uMVMatrix");
  }
  getAttribLocation(name) {
    if (this.isDisabled()) {
      return;
    }
    const attribLocation = this.gl.getAttribLocation(this.program, name);
    this.attribLocationList.push(attribLocation);
    return attribLocation;
  }
  getUniformLocation(name) {
    if (this.isDisabled()) {
      return;
    }
    return this.gl.getUniformLocation(this.program, name);
  }
  enableVertexAttributes() {
    if (this.isDisabled()) {
      return;
    }
    for (const attribLocation of this.attribLocationList) {
      this.gl.enableVertexAttribArray(attribLocation);
    }
  }
  disableVertexAttributes() {
    if (this.isDisabled()) {
      return;
    }
    for (const attribLocation of this.attribLocationList) {
      this.gl.disableVertexAttribArray(attribLocation);
    }
  }
  resetVertexAttribPointerOffset() {
    this.vertexAttribPointerOffset = 0;
  }
  vertexAttribPointer(indx, size, type, stride) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (type == gl.FLOAT || type == gl.INT) {
      gl.vertexAttribPointer(indx, size, type, false, stride, this.vertexAttribPointerOffset);
      this.vertexAttribPointerOffset += 4 * size;
    }
  }
  skipVertexAttribPointer(type, size) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (type == gl.FLOAT || type == gl.INT) {
      this.vertexAttribPointerOffset += 4 * size;
    }
  }
  setProjectionMatrix(matrix) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.uniformMatrix4fv(this.uPMatrix, false, matrix);
  }
  setModelViewMatrix(matrix) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.uniformMatrix4fv(this.uMVMatrix, false, matrix);
  }
}
var WebGLRenderBlendType = /* @__PURE__ */ ((WebGLRenderBlendType2) => {
  WebGLRenderBlendType2[WebGLRenderBlendType2["blend"] = 1] = "blend";
  WebGLRenderBlendType2[WebGLRenderBlendType2["add"] = 2] = "add";
  WebGLRenderBlendType2[WebGLRenderBlendType2["src"] = 3] = "src";
  return WebGLRenderBlendType2;
})(WebGLRenderBlendType || {});
class WebGLRender {
  constructor() {
    this.gl = null;
    this.floatPrecisionText = "";
    this.currentShader = null;
  }
  isAvailable() {
    return this.gl != null;
  }
  isDisabled() {
    return this.gl == null;
  }
  initializeWebGL(canvas, antialias) {
    try {
      const option = { preserveDrawingBuffer: true, antialias };
      const gl = canvas.getContext("webgl", option) || canvas.getContext("experimental-webgl", option);
      if (gl != null) {
        this.attach(gl);
      } else {
        throw new Error("ERROR-0701:Faild to initialize WebGL.");
      }
    } catch (e) {
      return true;
    }
    return false;
  }
  attach(gl) {
    this.gl = gl;
    const format = this.gl.getShaderPrecisionFormat(this.gl.FRAGMENT_SHADER, this.gl.HIGH_FLOAT);
    this.floatPrecisionText = format.precision != 0 ? "highp" : "mediump";
    this.resetBasicParameters();
  }
  initializeModelBuffer(model, vertexData, indexData, vertexDataStride) {
    if (this.isDisabled()) {
      return;
    }
    model.vertexBuffer = this.createVertexBuffer(vertexData, this.gl);
    model.indexBuffer = this.createIndexBuffer(indexData, this.gl);
    model.vertexData = vertexData;
    model.indexData = indexData;
    model.indexCount = indexData.length;
    model.vertexDataStride = vertexDataStride;
  }
  createBuffer() {
    if (this.isDisabled()) {
      return;
    }
    return this.gl.createBuffer();
  }
  deleteBuffer(buffer) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.deleteBuffer(buffer);
  }
  bufferDataOnce(buffer, dataArray) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, dataArray, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  createVertexBuffer(data, gl) {
    const glBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return glBuffer;
  }
  createIndexBuffer(data, gl) {
    const glBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return glBuffer;
  }
  releaseModelBuffer(model) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (model.vertexBuffer != null) {
      this.gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.deleteBuffer(model.vertexBuffer);
      model.vertexBuffer = null;
    }
    if (model.indexBuffer != null) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.deleteBuffer(model.indexBuffer);
      model.indexBuffer = null;
    }
  }
  initializeImageTexture(image) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    const glTexture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image.imageData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.bindTexture(gl.TEXTURE_2D, null);
    image.texture = glTexture;
    image.width = image.imageData.width;
    image.height = image.imageData.height;
  }
  releaseImageTexture(image) {
    if (this.isDisabled()) {
      return;
    }
    if (image.texture == null) {
      return;
    }
    const gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.deleteTexture(image.texture);
    image.texture = null;
  }
  setTextureImageFromCanvas(image, canvas) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, image.texture);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  initializeShader(shader) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    shader.gl = gl;
    shader.initializeSourceCode(this.floatPrecisionText);
    const program = gl.createProgram();
    const vertexShader = this.createShader(String(shader.vertexShaderSourceCode), true, gl);
    const fragmentShader = this.createShader(shader.fragmentShaderSourceCode, false, gl);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
      shader.program = program;
      shader.vertexShader = vertexShader;
      shader.fragmentShader = fragmentShader;
      shader.initializeAttributes();
    } else {
      throw new Error("ERROR-0702:" + gl.getProgramInfoLog(program));
    }
  }
  createShader(glslSourceCode, isVertexShader, gl) {
    let shader;
    if (isVertexShader) {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    }
    gl.shaderSource(shader, glslSourceCode);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      return shader;
    } else {
      alert(gl.getShaderInfoLog(shader));
    }
  }
  releaseShader(shader) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (shader.program != null) {
      gl.useProgram(null);
      gl.detachShader(shader.program, shader.vertexShader);
      gl.deleteShader(shader.vertexShader);
      shader.vertexShader = null;
      gl.detachShader(shader.program, shader.fragmentShader);
      gl.deleteShader(shader.fragmentShader);
      shader.fragmentShader = null;
      gl.deleteShader(shader.program);
      shader.program = null;
    }
  }
  setShader(shader) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    const lastShader = this.currentShader;
    gl.useProgram(shader.program);
    this.currentShader = shader;
    if (lastShader != null && lastShader.attribLocationList.length != this.currentShader.attribLocationList.length) {
      lastShader.disableVertexAttributes();
    }
  }
  clearColorBufferDepthBuffer(r2, g, b, a) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.clearColor(r2, g, b, a);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
  }
  clearDepthBuffer() {
    if (this.isDisabled()) {
      return;
    }
    this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
  }
  setTextureFilterNearest() {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }
  setTextureFilterLinear() {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  }
  activeTexture(image) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, image.texture);
  }
  resetBasicParameters() {
    this.setDepthTest(true);
    this.setDepthMask(true);
    this.setCulling(true);
    this.setBlendType(1);
  }
  setViewport(x2, y2, width, height) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.viewport(x2, y2, width, height);
  }
  setDepthTest(enable) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (enable) {
      gl.enable(gl.DEPTH_TEST);
    } else {
      gl.disable(gl.DEPTH_TEST);
    }
    return this;
  }
  setDepthMask(enable) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.depthMask(enable);
  }
  setCulling(enable) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (enable) {
      gl.enable(gl.CULL_FACE);
    } else {
      gl.disable(gl.CULL_FACE);
    }
  }
  setCullingBackFace(cullBackFace) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    if (cullBackFace) {
      gl.cullFace(gl.BACK);
    } else {
      gl.cullFace(gl.FRONT);
    }
  }
  setBlendType(blendType) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.enable(gl.BLEND);
    if (blendType == 2) {
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    } else if (blendType == 3) {
      gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    } else {
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  drawElements(model) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.drawElements(this.gl.TRIANGLES, model.indexCount, this.gl.UNSIGNED_SHORT, 0);
  }
  drawArrayTriangles(tryangleCount) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.drawArrays(this.gl.TRIANGLES, 0, tryangleCount);
  }
}
class GPULineShader extends RenderShader {
  getVertexUnitSize() {
    return -1;
  }
  getVertexCount(_pointCount, _lineCount) {
    return -1;
  }
  setBuffers(_buffer, _color) {
  }
  calculateBufferData(_buffer, _logic_GPULine) {
  }
  getDrawArrayTryanglesCount(bufferSize) {
    return bufferSize / this.getVertexUnitSize();
  }
}
class PolyLineShader extends GPULineShader {
  constructor() {
    super(...arguments);
    this.uColor = null;
    this.aPosition = -1;
  }
  getVertexUnitSize() {
    return 2;
  }
  getVertexCount(pointCount, _lineCount) {
    return (pointCount - 1) * (2 + 2) * 3;
  }
  initializeVertexSourceCode() {
    this.vertexShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

attribute vec2 aPosition;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

void main(void) {

	   gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 0.5, 1.0);
}
`;
  }
  initializeFragmentSourceCode() {
    this.fragmentShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

uniform vec4 uColor;

void main(void) {

    gl_FragColor = uColor;
}
`;
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
    this.initializeAttributes_PolyLineShader();
  }
  initializeAttributes_PolyLineShader() {
    this.uColor = this.getUniformLocation("uColor");
    this.aPosition = this.getAttribLocation("aPosition");
  }
  setBuffers(buffer, color) {
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    this.enableVertexAttributes();
    this.resetVertexAttribPointerOffset();
    gl.uniform4fv(this.uColor, color);
    const vertexDataStride = 4 * this.getVertexUnitSize();
    this.vertexAttribPointer(this.aPosition, 2, gl.FLOAT, vertexDataStride);
  }
  calculateBufferData(buffer, logic_GPULine) {
    logic_GPULine.calculateLinePointEdges(buffer);
    logic_GPULine.calculateBufferData_PloyLine(buffer);
  }
}
class BezierLineShader extends GPULineShader {
  constructor() {
    super(...arguments);
    this.uColor = null;
    this.aPosition = -1;
    this.aLocalPosition = -1;
    this.aLinePoint1 = -1;
    this.aControlPoint1 = -1;
    this.aLinePoint2 = -1;
    this.aControlPoint2 = -1;
    this.aLinePoint1R = -1;
    this.aControlPoint1R = -1;
    this.aLinePoint2R = -1;
    this.aControlPoint2R = -1;
    this.aWidth = -1;
  }
  getVertexUnitSize() {
    return 2 + 3 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2;
  }
  getVertexCount(pointCount, _lineCount) {
    return (pointCount - 1) * (4 + 4) * 3;
  }
  initializeVertexSourceCode() {
    this.vertexShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

attribute vec2 aPosition;
attribute vec3 aLocalPosition;

attribute vec2 aLinePoint1;
attribute vec2 aControlPoint1;
attribute vec2 aControlPoint2;
attribute vec2 aLinePoint2;

attribute vec2 aLinePoint1R;
attribute vec2 aControlPoint1R;
attribute vec2 aControlPoint2R;
attribute vec2 aLinePoint2R;

attribute vec2 aWidth;
// attribute vec2 aAlpha;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

varying vec3 vLocalPosition;

varying vec2 vLinePoint1;
varying vec2 vControlPoint1;
varying vec2 vControlPoint2;
varying vec2 vLinePoint2;

varying vec2 vLinePoint1R;
varying vec2 vControlPoint1R;
varying vec2 vControlPoint2R;
varying vec2 vLinePoint2R;

varying vec2 vWidth;
// varying vec2 vAlpha;

void main(void) {

    gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 0.5, 1.0);

    vLocalPosition = aLocalPosition;

    vLinePoint1 = aLinePoint1;
    vControlPoint1 = aControlPoint1;
    vControlPoint2 = aControlPoint2;
    vLinePoint2 = aLinePoint2;

    vLinePoint1R = aLinePoint1R;
    vControlPoint1R = aControlPoint1R;
    vControlPoint2R = aControlPoint2R;
    vLinePoint2R = aLinePoint2R;

    vWidth = aWidth;
    // vAlpha = aAlpha;
}
`;
  }
  initializeFragmentSourceCode() {
    this.fragmentShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

float cubeRoot(float x) {

    float res = pow(abs(x), 1.0 / 3.0);
    return (x >= 0.0) ? res : -res;
}

void solveQuadraticEquation(out vec3 solution, float a, float b, float c) {

    float d;
    float x1;
    float x2;

    if (a == 0.0) {

        solution[0] = -c / b;
        solution[1] = -1.0;
        return;
    }

    d = b * b - 4.0 * a * c;

    if (d > 0.0) {

        if (b < 0.0) {

            x1 = (-b - sqrt(d)) / 2.0 / a;
            x2 = -b / a - x1;
        }
        else {

            x1 = (-b + sqrt(d)) / 2.0 / a;
            x2 = -b / a - x1;
        }

        solution[0] = x1;
        solution[1]= x2;
    }
    else if (d == 0.0) {

        solution[0] = -b / 2.0 / a;
        solution[1] = -1.0;
    }
    else {

        // imaginary root
    }
}

void solveCubicEquation(out vec3 solution, float a, float b, float c, float d) {

    float PI = 3.14159265358979323846264;
    float p;
    float q;
    float t;
    float a3;
    float b3;

    if (a == 0.0) {;
        solveQuadraticEquation(solution, b, c, d);
        return;
    }

    b /= 3.0 * a;
    c /= a;
    d /= a;
    p = b * b - c / 3.0;
    q = (b * (c - 2.0 * b * b) - d) / 2.0;

    a = q * q - p * p * p;

    if (a == 0.0) {

        q = cubeRoot(q);
        solution[0] = 2.0 * q - b;
        solution[1] = -q - b;
        solution[2] = -1.0;
    }
    else if (a > 0.0) {

        float sign = 1.0;
        if (q <= 0.0) { sign = -1.0; }
        a3 = cubeRoot(q + (sign) * sqrt(a));
        b3 = p / a3;
        solution[0] = a3 + b3 - b;
        solution[1] = -1.0;
        solution[2] = -1.0;
    }
    else {

        a = 2.0 * sqrt(p);
        t = acos(q / (p * a / 2.0));
        solution[0] = a * cos(t / 3.0) - b;
        solution[1] = a * cos((t + 2.0 * PI) / 3.0) - b;
        solution[2] = a * cos((t + 4.0 * PI) / 3.0) - b;
    }
}

float calcBezierTimeInSection(float x1, float x2, float x3, float x4, float targetX) {

    vec3 solution = vec3(0.0, 0.0, 0.0);
    float a = x4 - 3.0 * (x3 - x2) - x1;
    float b = 3.0 * (x3 - 2.0 * x2 + x1);
    float c = 3.0 * (x2 - x1);
    float d = x1 - targetX;

    solveCubicEquation(solution, a, b, c, d);

    if (solution[0] >= -0.1 && solution[0] <= 1.0) {

        return solution[0];
    }
    else if (solution[1] >= 0.0 && solution[1] <= 1.0) {

        return solution[1];
    }
    else if (solution[2] >= 0.0 && solution[2] <= 1.0) {

        return solution[2];
    }
    else {

        return -1.0;
    }
}

float calcInterpolationBezier(float x1, float x2, float x3, float x4, float t) {

    return (1.0 - t) * (1.0 - t) * (1.0 - t) * x1 +
        3.0 * (1.0 - t) * (1.0 - t) * t * x2 +
        3.0 * (1.0 - t) * t * t * x3 +
        t * t * t * x4;
}

uniform vec4 uColor;

varying vec3 vLocalPosition;

varying vec2 vLinePoint1;
varying vec2 vControlPoint1;
varying vec2 vControlPoint2;
varying vec2 vLinePoint2;

varying vec2 vLinePoint1R;
varying vec2 vControlPoint1R;
varying vec2 vControlPoint2R;
varying vec2 vLinePoint2R;

varying vec2 vWidth;
// varying vec2 vAlpha;

void main(void) {

    float t1 = calcBezierTimeInSection(
        vLinePoint1.x,
        vControlPoint1.x,
        vControlPoint2.x,
        vLinePoint2.x,
        vLocalPosition.x
    );

    float y1;

    if (t1 >= 0.0) {

        y1 = calcInterpolationBezier(
            vLinePoint1.y,
            vControlPoint1.y,
            vControlPoint2.y,
            vLinePoint2.y,
            t1
        );
    }
    else {

        y1 = vLocalPosition.y + 1.0;
    }

    float t2 = calcBezierTimeInSection(
        vLinePoint1R.x,
        vControlPoint1R.x,
        vControlPoint2R.x,
        vLinePoint2R.x,
        vLocalPosition.x
    );

    float y2;

    if (t2 >= 0.0) {

        y2 = calcInterpolationBezier(
            vLinePoint1R.y,
            vControlPoint1R.y,
            vControlPoint2R.y,
            vLinePoint2R.y,
            t2
        );
    }
    else {

        y2 = vLocalPosition.y - 1.0;
    }

    float col = (vLocalPosition.y <= y1 && vLocalPosition.y >= y2)? 1.0 : 0.0;

    gl_FragColor = vec4(uColor.rgb, col * uColor.a);
//    gl_FragColor = vec4(0.0, 0.0, 0.0, col * mix(vAlpha[0], vAlpha[1], vLocalPosition.z));
//    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}
`;
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
    this.initializeAttributes_PolyLineShader();
  }
  initializeAttributes_PolyLineShader() {
    this.uColor = this.getUniformLocation("uColor");
    this.aPosition = this.getAttribLocation("aPosition");
    this.aLocalPosition = this.getAttribLocation("aLocalPosition");
    this.aLinePoint1 = this.getAttribLocation("aLinePoint1");
    this.aControlPoint1 = this.getAttribLocation("aControlPoint1");
    this.aControlPoint2 = this.getAttribLocation("aControlPoint2");
    this.aLinePoint2 = this.getAttribLocation("aLinePoint2");
    this.aLinePoint1R = this.getAttribLocation("aLinePoint1R");
    this.aControlPoint1R = this.getAttribLocation("aControlPoint1R");
    this.aControlPoint2R = this.getAttribLocation("aControlPoint2R");
    this.aLinePoint2R = this.getAttribLocation("aLinePoint2R");
    this.aWidth = this.getAttribLocation("aWidth");
  }
  setBuffers(buffer, color) {
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    this.enableVertexAttributes();
    this.resetVertexAttribPointerOffset();
    gl.uniform4fv(this.uColor, color);
    const vertexDataStride = 4 * this.getVertexUnitSize();
    this.vertexAttribPointer(this.aPosition, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLocalPosition, 3, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint1, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint1, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint2, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint2, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint1R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint1R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint2R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint2R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aWidth, 2, gl.FLOAT, vertexDataStride);
  }
  calculateBufferData(buffer, logic_GPULine) {
    logic_GPULine.calculateLinePointEdges(buffer);
    logic_GPULine.calculateLinePointBezierLocation(buffer);
    logic_GPULine.calculateControlPointVertexLocations(buffer);
    logic_GPULine.calculateBufferData_BezierLine(buffer);
  }
}
class BezierDistanceLineShader extends GPULineShader {
  constructor() {
    super(...arguments);
    this.uColor = null;
    this.aPosition = -1;
    this.aLocalPosition = -1;
    this.aLinePoint1 = -1;
    this.aControlPoint1 = -1;
    this.aLinePoint2 = -1;
    this.aControlPoint2 = -1;
    this.aLinePoint1R = -1;
    this.aControlPoint1R = -1;
    this.aLinePoint2R = -1;
    this.aControlPoint2R = -1;
    this.aWidth = -1;
  }
  getVertexUnitSize() {
    return 2 + 3 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2;
  }
  getVertexCount(pointCount, lineCount) {
    return (pointCount - 1) * (4 + 4) * 3 + lineCount * (2 + 2) * 3;
  }
  initializeVertexSourceCode() {
    this.vertexShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

attribute vec2 aPosition;
attribute vec3 aLocalPosition;

attribute vec2 aLinePoint1;
attribute vec2 aControlPoint1;
attribute vec2 aControlPoint2;
attribute vec2 aLinePoint2;

attribute vec2 aLinePoint1R;
attribute vec2 aControlPoint1R;
attribute vec2 aControlPoint2R;
attribute vec2 aLinePoint2R;

attribute vec2 aWidth;
// attribute vec2 aAlpha;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

varying vec3 vLocalPosition;

varying vec2 vLinePoint1;
varying vec2 vControlPoint1;
varying vec2 vControlPoint2;
varying vec2 vLinePoint2;

varying vec2 vLinePoint1R;
varying vec2 vControlPoint1R;
varying vec2 vControlPoint2R;
varying vec2 vLinePoint2R;

varying vec2 vWidth;
// varying vec2 vAlpha;

void main(void) {

    gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 0.5, 1.0);

    vLocalPosition = aLocalPosition;

    vLinePoint1 = aLinePoint1;
    vControlPoint1 = aControlPoint1;
    vControlPoint2 = aControlPoint2;
    vLinePoint2 = aLinePoint2;

    vLinePoint1R = aLinePoint1R;
    vControlPoint1R = aControlPoint1R;
    vControlPoint2R = aControlPoint2R;
    vLinePoint2R = aLinePoint2R;

    vWidth = aWidth;
    // vAlpha = aAlpha;
}
`;
  }
  initializeFragmentSourceCode() {
    this.fragmentShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

// From https://www.shadertoy.com/view/4sXyDr

#define CLAMP

float distanceBezier(vec2 p, vec2 P0, vec2 P1, vec2 P2, vec2 P3, out float t)
{
    // Cubic Bezier curve
    vec2 A = -P0 + 3.0 * P1 - 3.0 * P2 + P3;
    vec2 B = 3.0 * (P0 - 2.0 * P1 + P2);
    vec2 C = 3.0 * (P1 - P0);
    vec2 D = P0;

    float a5 =  6.0 * dot(A, A);
    float a4 = 10.0 * dot(A, B);
    float a3 =  8.0 * dot(A, C)     + 4.0 * dot(B, B);
    float a2 =  6.0 * dot(A, D - p) + 6.0 * dot(B, C);
    float a1 =  4.0 * dot(B, D - p) + 2.0 * dot(C, C);
    float a0 =  2.0 * dot(C, D - p);

    // calculate distances to the control points
    float d0 = length(p - P0);
    float d1 = length(p - P1);
    float d2 = length(p - P2);
    float d3 = length(p - P3);
    float d = min(d0, min(d1, min(d2, d3)));

    // Choose initial value of t
    //float t;
    if (abs(d3 - d) < 1.0e-5) {
        t = 1.0;
    }
    else if (abs(d0 - d) < 1.0e-5) {
        t = 0.0;
    }
    else {
        t = 0.5;
    }

	// iteration
    for (int i = 0; i < 10; i++) {

        float t2 = t*t;
        float t3 = t2*t;
        float t4 = t3*t;
        float t5 = t4*t;

        float f = a5*t5 + a4*t4 + a3*t3 + a2*t2 + a1*t + a0;
        float df = 5.0*a5*t4 + 4.0*a4*t3 + 3.0*a3*t2 + 2.0*a2*t + a1;

        t = t - f/df;
    }

    // clamp to edge of bezier segment
#ifdef CLAMP
    t = clamp(t, 0.0, 1.0);
#endif

    // get the point on the curve
    vec2 P = A*t*t*t + B*t*t + C*t + D;

    // return distance to the point on the curve
    return min(length(p - P), min(d0, d3));
}

uniform vec4 uColor;

varying vec3 vLocalPosition;

varying vec2 vLinePoint1;
varying vec2 vControlPoint1;
varying vec2 vControlPoint2;
varying vec2 vLinePoint2;

varying vec2 vLinePoint1R;
varying vec2 vControlPoint1R;
varying vec2 vControlPoint2R;
varying vec2 vLinePoint2R;

varying vec2 vWidth;
// varying vec2 vAlpha;

void main(void) {

	vec2 p  = vLocalPosition.xy;
  vec2 P0 = vLinePoint1;
  vec2 P1 = vControlPoint1;
  vec2 P2 = vControlPoint2;
  vec2 P3 = vLinePoint2;

  float t;
  float distance = distanceBezier(p, P0, P1, P2, P3, t);
  float width = mix(vWidth.x, vWidth.y, t);

  if (distance > width) {

    // gl_FragColor = vec4(1.0, 0.5, 0.0, 0.1);
  	discard;
  }
	else {

      float col = 1.0 - smoothstep(width - 0.08, width, distance);
      //float col = distance * 0.1;

      //gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
      //gl_FragColor = vec4(vLocalPosition.z, 0.0, 0.0, col);
      //gl_FragColor = vec4(vWidth.y, 0.0, 0.0, col * uColor.a * 0.9 + 0.1);
      gl_FragColor = vec4(uColor.rgb, col * uColor.a * 0.9 + 0.1);
  }
}
`;
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
    this.initializeAttributes_PolyLineShader();
  }
  initializeAttributes_PolyLineShader() {
    this.uColor = this.getUniformLocation("uColor");
    this.aPosition = this.getAttribLocation("aPosition");
    this.aLocalPosition = this.getAttribLocation("aLocalPosition");
    this.aLinePoint1 = this.getAttribLocation("aLinePoint1");
    this.aControlPoint1 = this.getAttribLocation("aControlPoint1");
    this.aControlPoint2 = this.getAttribLocation("aControlPoint2");
    this.aLinePoint2 = this.getAttribLocation("aLinePoint2");
    this.aLinePoint1R = this.getAttribLocation("aLinePoint1R");
    this.aControlPoint1R = this.getAttribLocation("aControlPoint1R");
    this.aControlPoint2R = this.getAttribLocation("aControlPoint2R");
    this.aLinePoint2R = this.getAttribLocation("aLinePoint2R");
    this.aWidth = this.getAttribLocation("aWidth");
  }
  setBuffers(buffer, color) {
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    this.enableVertexAttributes();
    this.resetVertexAttribPointerOffset();
    gl.uniform4fv(this.uColor, color);
    const vertexDataStride = 4 * this.getVertexUnitSize();
    this.vertexAttribPointer(this.aPosition, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLocalPosition, 3, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint1, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint1, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint2, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint2, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint1R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint1R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aControlPoint2R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aLinePoint2R, 2, gl.FLOAT, vertexDataStride);
    this.vertexAttribPointer(this.aWidth, 2, gl.FLOAT, vertexDataStride);
  }
  calculateBufferData(buffer, logic_GPULine) {
    logic_GPULine.calculateLinePointEdges(buffer);
    logic_GPULine.calculateLinePointBezierLocation(buffer);
    logic_GPULine.calculateControlPointVertexLocations(buffer);
    logic_GPULine.calculateBufferData_BezierLine(buffer);
  }
}
class ToolClipboard {
  constructor() {
    this.copy_VectorGroup = null;
  }
}
var EditModeID = /* @__PURE__ */ ((EditModeID2) => {
  EditModeID2[EditModeID2["editMode"] = 1] = "editMode";
  EditModeID2[EditModeID2["drawMode"] = 2] = "drawMode";
  return EditModeID2;
})(EditModeID || {});
var OperationUnitID = /* @__PURE__ */ ((OperationUnitID2) => {
  OperationUnitID2[OperationUnitID2["none"] = 0] = "none";
  OperationUnitID2[OperationUnitID2["strokePoint"] = 1] = "strokePoint";
  OperationUnitID2[OperationUnitID2["strokeSegment"] = 2] = "strokeSegment";
  OperationUnitID2[OperationUnitID2["stroke"] = 3] = "stroke";
  OperationUnitID2[OperationUnitID2["layer"] = 4] = "layer";
  OperationUnitID2[OperationUnitID2["countOfID"] = 5] = "countOfID";
  return OperationUnitID2;
})(OperationUnitID || {});
var OperationOriginTypeID = /* @__PURE__ */ ((OperationOriginTypeID2) => {
  OperationOriginTypeID2[OperationOriginTypeID2["none"] = 0] = "none";
  OperationOriginTypeID2[OperationOriginTypeID2["medianCenter"] = 1] = "medianCenter";
  OperationOriginTypeID2[OperationOriginTypeID2["pivot"] = 2] = "pivot";
  return OperationOriginTypeID2;
})(OperationOriginTypeID || {});
var SubToolID = /* @__PURE__ */ ((SubToolID2) => {
  SubToolID2[SubToolID2["none"] = 0] = "none";
  SubToolID2[SubToolID2["noOperation"] = 1] = "noOperation";
  SubToolID2[SubToolID2["drawLine"] = 2] = "drawLine";
  SubToolID2[SubToolID2["scratchLine"] = 3] = "scratchLine";
  SubToolID2[SubToolID2["extrudeLine"] = 4] = "extrudeLine";
  SubToolID2[SubToolID2["overWriteLineWidth"] = 5] = "overWriteLineWidth";
  SubToolID2[SubToolID2["scratchLineWidth"] = 6] = "scratchLineWidth";
  SubToolID2[SubToolID2["deletePointBrush"] = 7] = "deletePointBrush";
  SubToolID2[SubToolID2["editLinePointWidth_BrushSelect"] = 8] = "editLinePointWidth_BrushSelect";
  SubToolID2[SubToolID2["drawPointBrush"] = 9] = "drawPointBrush";
  SubToolID2[SubToolID2["pointBrush_extrudeLine"] = 10] = "pointBrush_extrudeLine";
  SubToolID2[SubToolID2["editModeMain"] = 11] = "editModeMain";
  SubToolID2[SubToolID2["locateOperatorCursor"] = 12] = "locateOperatorCursor";
  SubToolID2[SubToolID2["brushSelect"] = 13] = "brushSelect";
  SubToolID2[SubToolID2["resampleSegment"] = 14] = "resampleSegment";
  SubToolID2[SubToolID2["edit_GrabMove"] = 15] = "edit_GrabMove";
  SubToolID2[SubToolID2["edit_Rotate"] = 16] = "edit_Rotate";
  SubToolID2[SubToolID2["edit_Scale"] = 17] = "edit_Scale";
  SubToolID2[SubToolID2["editDocumentFrame"] = 18] = "editDocumentFrame";
  SubToolID2[SubToolID2["addAutoFillPoint"] = 19] = "addAutoFillPoint";
  SubToolID2[SubToolID2["deleteAutoFillPoint"] = 20] = "deleteAutoFillPoint";
  SubToolID2[SubToolID2["image_GrabMove"] = 21] = "image_GrabMove";
  SubToolID2[SubToolID2["image_Rotate"] = 22] = "image_Rotate";
  SubToolID2[SubToolID2["image_Scale"] = 23] = "image_Scale";
  SubToolID2[SubToolID2["p3d_locateHead"] = 24] = "p3d_locateHead";
  SubToolID2[SubToolID2["p3d_rotateHead"] = 25] = "p3d_rotateHead";
  SubToolID2[SubToolID2["p3d_locateBody"] = 26] = "p3d_locateBody";
  SubToolID2[SubToolID2["p3d_locateHips"] = 27] = "p3d_locateHips";
  SubToolID2[SubToolID2["p3d_locateLeftShoulder"] = 28] = "p3d_locateLeftShoulder";
  SubToolID2[SubToolID2["p3d_locateLeftArm1"] = 29] = "p3d_locateLeftArm1";
  SubToolID2[SubToolID2["p3d_locateLeftArm2"] = 30] = "p3d_locateLeftArm2";
  SubToolID2[SubToolID2["p3d_locateRightShoulder"] = 31] = "p3d_locateRightShoulder";
  SubToolID2[SubToolID2["p3d_locateRightArm1"] = 32] = "p3d_locateRightArm1";
  SubToolID2[SubToolID2["p3d_locateRightArm2"] = 33] = "p3d_locateRightArm2";
  SubToolID2[SubToolID2["p3d_locateLeftLeg1"] = 34] = "p3d_locateLeftLeg1";
  SubToolID2[SubToolID2["p3d_locateLeftLeg2"] = 35] = "p3d_locateLeftLeg2";
  SubToolID2[SubToolID2["p3d_locateRightLeg1"] = 36] = "p3d_locateRightLeg1";
  SubToolID2[SubToolID2["p3d_locateRightLeg2"] = 37] = "p3d_locateRightLeg2";
  SubToolID2[SubToolID2["p3d_twistHead"] = 38] = "p3d_twistHead";
  return SubToolID2;
})(SubToolID || {});
var PointerTypeID = /* @__PURE__ */ ((PointerTypeID2) => {
  PointerTypeID2[PointerTypeID2["none"] = 0] = "none";
  PointerTypeID2[PointerTypeID2["brush"] = 1] = "brush";
  PointerTypeID2[PointerTypeID2["circularRange"] = 2] = "circularRange";
  PointerTypeID2[PointerTypeID2["brushWithCircularRange"] = 3] = "brushWithCircularRange";
  return PointerTypeID2;
})(PointerTypeID || {});
var PointerParameterID = /* @__PURE__ */ ((PointerParameterID2) => {
  PointerParameterID2[PointerParameterID2["none"] = 0] = "none";
  PointerParameterID2[PointerParameterID2["extrudeLine"] = 1] = "extrudeLine";
  PointerParameterID2[PointerParameterID2["eracer"] = 2] = "eracer";
  PointerParameterID2[PointerParameterID2["scratchLine"] = 3] = "scratchLine";
  PointerParameterID2[PointerParameterID2["setLineWidth"] = 4] = "setLineWidth";
  PointerParameterID2[PointerParameterID2["scratchLineWidth"] = 5] = "scratchLineWidth";
  PointerParameterID2[PointerParameterID2["brushSelect"] = 6] = "brushSelect";
  return PointerParameterID2;
})(PointerParameterID || {});
var BrushParameterID = /* @__PURE__ */ ((BrushParameterID2) => {
  BrushParameterID2[BrushParameterID2["none"] = 0] = "none";
  BrushParameterID2[BrushParameterID2["solidStroke"] = 1] = "solidStroke";
  BrushParameterID2[BrushParameterID2["pointBrush"] = 2] = "pointBrush";
  return BrushParameterID2;
})(BrushParameterID || {});
var BrushTypeID = /* @__PURE__ */ ((BrushTypeID2) => {
  BrushTypeID2[BrushTypeID2["none"] = 0] = "none";
  BrushTypeID2[BrushTypeID2["solidBrushStroke"] = 1] = "solidBrushStroke";
  BrushTypeID2[BrushTypeID2["radialBrush"] = 2] = "radialBrush";
  BrushTypeID2[BrushTypeID2["bitmapBrush"] = 3] = "bitmapBrush";
  return BrushTypeID2;
})(BrushTypeID || {});
var SubToolParameterID = /* @__PURE__ */ ((SubToolParameterID2) => {
  SubToolParameterID2[SubToolParameterID2["none"] = 0] = "none";
  SubToolParameterID2[SubToolParameterID2["drawLine"] = 1] = "drawLine";
  SubToolParameterID2[SubToolParameterID2["extrudeLine"] = 2] = "extrudeLine";
  SubToolParameterID2[SubToolParameterID2["eracer"] = 3] = "eracer";
  SubToolParameterID2[SubToolParameterID2["scratchLine"] = 4] = "scratchLine";
  SubToolParameterID2[SubToolParameterID2["setLineWidth"] = 5] = "setLineWidth";
  SubToolParameterID2[SubToolParameterID2["scratchLineWidth"] = 6] = "scratchLineWidth";
  SubToolParameterID2[SubToolParameterID2["brushSelect"] = 7] = "brushSelect";
  SubToolParameterID2[SubToolParameterID2["drawPointBrush"] = 8] = "drawPointBrush";
  SubToolParameterID2[SubToolParameterID2["pointBrush_extrudeLine"] = 9] = "pointBrush_extrudeLine";
  return SubToolParameterID2;
})(SubToolParameterID || {});
class SubTool {
  constructor() {
    this.isEditTool = false;
    this.usesOperatorCursor = false;
    this.usesHitTestToSelect = false;
    this.helpText = "";
    this.subtoolID = 0;
    this.subToolParameterID = 0;
    this.subToolParameter = null;
    this.toolBarImage = null;
    this.toolBarImageIndex = 0;
    this.inputOptionButtonCount = 0;
  }
  isAvailable(_ctx) {
    return true;
  }
  onActivated(_ctx) {
  }
  getOptionButtonState(_buttonIndex, _ctx) {
    return InputSideID.none;
  }
  optionButton_Click(_buttonIndex, _ctx) {
    return false;
  }
  mouseDown(_e, _ctx) {
  }
  mouseMove(_e, _ctx) {
  }
  mouseUp(_e, _ctx) {
  }
  keydown(_key, _commandID, _ctx) {
    return false;
  }
  onDrawEditor(_ctx, _drawing) {
  }
  toolWindowItemClick(_ctx) {
  }
}
class Tool_None extends SubTool {
}
class ModalToolBase extends SubTool {
  prepareModal(_e, _ctx) {
    return true;
  }
  startModal(ctx) {
    ctx.setRedrawEditorWindow();
  }
  endModal(ctx) {
    ctx.setRedrawEditorWindow();
  }
  cancelModal(ctx) {
    ctx.setRedrawMainWindowEditorWindow();
  }
}
var MainToolID = /* @__PURE__ */ ((MainToolID2) => {
  MainToolID2[MainToolID2["none"] = 0] = "none";
  MainToolID2[MainToolID2["group"] = 1] = "group";
  MainToolID2[MainToolID2["vector"] = 2] = "vector";
  MainToolID2[MainToolID2["posing3D"] = 3] = "posing3D";
  MainToolID2[MainToolID2["imageFileReference"] = 4] = "imageFileReference";
  MainToolID2[MainToolID2["autoFill"] = 5] = "autoFill";
  MainToolID2[MainToolID2["pointBrushFill"] = 6] = "pointBrushFill";
  return MainToolID2;
})(MainToolID || {});
var MainToolTabID = /* @__PURE__ */ ((MainToolTabID2) => {
  MainToolTabID2[MainToolTabID2["none"] = 0] = "none";
  MainToolTabID2[MainToolTabID2["group"] = 1] = "group";
  MainToolTabID2[MainToolTabID2["drawing"] = 2] = "drawing";
  MainToolTabID2[MainToolTabID2["imageFileReference"] = 3] = "imageFileReference";
  MainToolTabID2[MainToolTabID2["autoFill"] = 4] = "autoFill";
  MainToolTabID2[MainToolTabID2["pointBrushFill"] = 5] = "pointBrushFill";
  MainToolTabID2[MainToolTabID2["posing"] = 6] = "posing";
  MainToolTabID2[MainToolTabID2["edit"] = 7] = "edit";
  MainToolTabID2[MainToolTabID2["edit_disabled"] = 8] = "edit_disabled";
  MainToolTabID2[MainToolTabID2["document"] = 9] = "document";
  MainToolTabID2[MainToolTabID2["layer"] = 10] = "layer";
  MainToolTabID2[MainToolTabID2["view"] = 11] = "view";
  return MainToolTabID2;
})(MainToolTabID || {});
var MainToolTabTypeID = /* @__PURE__ */ ((MainToolTabTypeID2) => {
  MainToolTabTypeID2[MainToolTabTypeID2["none"] = 0] = "none";
  MainToolTabTypeID2[MainToolTabTypeID2["manipulatingTool"] = 1] = "manipulatingTool";
  MainToolTabTypeID2[MainToolTabTypeID2["editingTool"] = 2] = "editingTool";
  return MainToolTabTypeID2;
})(MainToolTabTypeID || {});
class MainToolTab {
  constructor() {
    this.type = 1;
    this.default_SubToolID = SubToolID.none;
    this.disabled = false;
    this.current_SubTool = null;
  }
  isAvailable(_ctx) {
    return false;
  }
  keydown(_key, _commandID, _ctx) {
    return false;
  }
  buttonClick(_id, _ctx) {
    return false;
  }
  processSubToolKeyDown(commands, commandID, ctx) {
    for (const command of commands) {
      if (commandID == command.commandID) {
        ctx.tool.changeCurrentSubToolForSubtoolID(command.subToolID);
        return true;
      }
    }
    return false;
  }
  processToggleSubTool(targetCommandID, changeTo_SubToolID, returnTo_SubToolID, commandID, ctx) {
    if (commandID == targetCommandID) {
      if (ctx.currentSubtoolID != changeTo_SubToolID) {
        ctx.tool.changeCurrentSubToolForSubtoolID(changeTo_SubToolID);
      } else {
        ctx.tool.changeCurrentSubToolForSubtoolID(returnTo_SubToolID);
      }
      return true;
    }
    return false;
  }
}
class MainToolCommonTabSet {
}
class MainTool {
  constructor() {
    this.mainToolID = 0;
    this.mainToolTabs = [];
    this.drawMode_MainToolTab = null;
  }
}
class ToolPointerEventProvider {
  constructor() {
    this.event = null;
  }
  attach(wnd) {
    this.event = wnd.pointerEvent;
    return this;
  }
  get location() {
    return this.event.location;
  }
  get offsetX() {
    return this.event.offsetX;
  }
  get offsetY() {
    return this.event.offsetY;
  }
  get isLeftButtonPressing() {
    return this.event.isLeftButtonPressing();
  }
  get isRightButtonPressing() {
    return this.event.isRightButtonPressing();
  }
  get isCenterButtonPressing() {
    return this.event.isCenterButtonPressing();
  }
  get isLeftButtonReleased() {
    return this.event.isLeftButtonReleased();
  }
  get isRightButtonReleased() {
    return this.event.isRightButtonReleased();
  }
  get isCenterButtonReleased() {
    return this.event.isCenterButtonReleased();
  }
  get isPointerMoved() {
    return this.event.isPointerMoved;
  }
}
class DrawingVectorLayerLogic {
  constructor() {
    this.canvasRender = null;
    this.drawStyle = null;
    this.drawingStroke = null;
    this.drawingPointBrush = null;
    this.editorDrawer = null;
    this.strokeColor = vec4.fromValues(0, 0, 0, 1);
    this.fillColor = vec4.fromValues(0, 0, 0, 1);
    this.tempColor = vec4.fromValues(0, 0, 0, 1);
  }
  link(canvasRender, drawStyle, drawingStroke, drawingPointBrush, editorDrawer) {
    this.canvasRender = canvasRender;
    this.drawStyle = drawStyle;
    this.drawingStroke = drawingStroke;
    this.drawingPointBrush = drawingPointBrush;
    this.editorDrawer = editorDrawer;
  }
  getStrokeColor(result, drawable, documentData, isEditMode, hideWhenEditMode) {
    let color;
    if (drawable.drawLineType == DrawLineTypeID.layerColor) {
      color = drawable.layerColor;
    } else if (drawable.drawLineType == DrawLineTypeID.paletteColor) {
      const paletteColor = documentData.paletteColors[drawable.line_PaletteColorIndex];
      color = paletteColor.color;
    } else {
      color = drawable.layerColor;
    }
    if (hideWhenEditMode && isEditMode) {
      vec4.copy(this.tempColor, color);
      this.tempColor[3] *= this.drawStyle.editModeOtherLayerAlphaAdjustRate;
      color = this.tempColor;
    }
    vec4.copy(result, color);
    return color;
  }
  getOnionSkinStrokeColor(result, onionSkinLevel, maxOnionSkinLevel) {
    vec4.copy(result, onionSkinLevel > 0 ? this.drawStyle.onionSkinForwardLineColor : this.drawStyle.onionSkinBackwardLineColor);
    result[3] *= 1 - Math.abs(onionSkinLevel) / maxOnionSkinLevel * 0.3;
    return result;
  }
  getFillColor(result, drawable, documentData, isEditMode, hideWhenEditMode) {
    let color;
    if (drawable.fillAreaType == FillAreaTypeID.fillColor) {
      color = drawable.fillColor;
    } else if (drawable.fillAreaType == FillAreaTypeID.paletteColor) {
      const paletteColor = documentData.paletteColors[drawable.fill_PaletteColorIndex];
      color = paletteColor.color;
    } else {
      color = drawable.fillColor;
    }
    if (hideWhenEditMode && isEditMode) {
      vec4.copy(this.tempColor, color);
      this.tempColor[3] *= this.drawStyle.editModeOtherLayerAlphaAdjustRate;
      color = this.tempColor;
    }
    vec4.copy(result, color);
    return result;
  }
  getWidthRate(drawable, documentData) {
    return drawable.lineWidthBiasRate * documentData.lineWidthBiasRate;
  }
  drawForeground(render, drawable, geometry, renderCache, documentData, isEditMode, isExporting, isModalToolRunning, onionSkinLevel, maxOnionSkinLevel) {
    if (drawable.drawLineType == DrawLineTypeID.none) {
      return;
    }
    if (!render.isInViewRectangle(geometry.runtime.area.centerLocation, geometry.runtime.area.range)) {
      return;
    }
    const useAdjustingLocation = isModalToolRunning;
    const widthRate = this.getWidthRate(drawable, documentData);
    if (onionSkinLevel == 0) {
      this.getStrokeColor(this.strokeColor, drawable, documentData, isEditMode, true);
    } else {
      this.getOnionSkinStrokeColor(this.strokeColor, onionSkinLevel, maxOnionSkinLevel);
    }
    if (renderCache.isInitialized()) {
      renderCache.clearMaskData();
    }
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        if (!render.isInViewRectangle(group.runtime.area.centerLocation, group.runtime.area.range)) {
          continue;
        }
        if (VectorLayerGeometry.isStrokeDraw(geometry)) {
          for (const stroke of group.lines) {
            this.drawingStroke.drawVectorStroke(render, stroke, this.strokeColor, widthRate, 0, useAdjustingLocation, isExporting);
          }
        } else if (VectorLayerGeometry.isPointBrushFill(geometry)) {
          if (renderCache.isInitialized()) {
            for (const stroke of group.lines) {
              this.drawingPointBrush.drawPointBrushStroke(render, stroke, this.strokeColor, useAdjustingLocation, renderCache);
            }
            this.drawingPointBrush.drawRenderResult(render, renderCache);
          }
        } else if (VectorLayerGeometry.isSurroundingFill(geometry)) {
          this.drawingStroke.beginStroke(this.strokeColor, widthRate, 0, useAdjustingLocation, isExporting);
          for (const stroke of group.lines) {
            this.drawingStroke.processStroke(render, stroke);
          }
          this.drawingStroke.finishStroke(render);
        }
      }
    }
  }
  drawBackground(render, drawable, geometry, documentData, isSelectedLayer, isEditMode, isExporting, isModalToolRunning) {
    if (drawable.fillAreaType == FillAreaTypeID.none) {
      return;
    }
    const useAdjustingLocation = isModalToolRunning;
    this.getFillColor(this.fillColor, drawable, documentData, isEditMode, !isSelectedLayer);
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        if (!render.isInViewRectangle(group.runtime.area.centerLocation, group.runtime.area.range)) {
          continue;
        }
        if (VectorLayerGeometry.isStrokeDraw(geometry)) {
          for (const line of group.lines) {
            this.drawingStroke.beginFill(this.fillColor, useAdjustingLocation);
            this.drawingStroke.processFill(render, line);
            this.drawingStroke.finishFill(render);
          }
        } else if (VectorLayerGeometry.isSurroundingFill(geometry)) {
          this.drawingStroke.beginFill(this.fillColor, useAdjustingLocation);
          for (const line of group.lines) {
            this.drawingStroke.processFill(render, line);
          }
          this.drawingStroke.finishFill(render);
        }
      }
    }
  }
  drawForegroundForEditMode(render, layer, geometry, documentData, operationUnitID, isEditMode, isSelectedLayer, drawStrokes, drawPoints, isModalToolRunning) {
    const widthRate = this.getWidthRate(layer, documentData);
    this.getStrokeColor(this.strokeColor, layer, documentData, isEditMode, !isSelectedLayer);
    const useAdjustingLocation = isModalToolRunning;
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        if (!render.isInViewRectangle(group.runtime.area.centerLocation, group.runtime.area.range)) {
          continue;
        }
        for (const stroke of group.lines) {
          if (!isSelectedLayer) {
            if (layer.drawLineType != DrawLineTypeID.none) {
              this.drawingStroke.drawVectorStroke(render, stroke, this.strokeColor, widthRate, 0, useAdjustingLocation, false);
            }
          } else {
            if (operationUnitID == OperationUnitID.strokePoint) {
              if (drawStrokes) {
                this.drawingStroke.drawVectorStroke(render, stroke, this.strokeColor, widthRate, 0, useAdjustingLocation, false);
              }
              if (drawPoints) {
                this.editorDrawer.drawVectorLinePoints(stroke, this.strokeColor, useAdjustingLocation);
              }
            } else if (operationUnitID == OperationUnitID.strokeSegment) {
              if (drawStrokes) {
                this.drawingStroke.drawVectorStrokeSegment(this.canvasRender, stroke, this.strokeColor, this.drawStyle.selectedVectorLineColor, widthRate, useAdjustingLocation);
              }
            } else if (operationUnitID == OperationUnitID.stroke) {
              if (drawStrokes) {
                let color;
                if (stroke.isSelected && stroke.runtime.modifyFlag != VectorStrokeModifyFlagID.selectedToUnselected || stroke.runtime.modifyFlag == VectorStrokeModifyFlagID.unselectedToSelected) {
                  color = this.drawStyle.selectedVectorLineColor;
                } else {
                  color = this.strokeColor;
                }
                const lineWidthBolding = this.editorDrawer.getCurrentViewScaleLineWidth(stroke.runtime.isCloseToMouse ? 2 : 0);
                this.drawingStroke.drawVectorStroke(render, stroke, color, widthRate, lineWidthBolding, useAdjustingLocation, false);
              }
            }
          }
        }
      }
    }
  }
  drawBackgroundExtra(render, drawable, geometry, isSelectedLayer, isEditMode, isModalToolRunning) {
    if (drawable.fillAreaType == FillAreaTypeID.none) {
      return;
    }
    if (!isSelectedLayer && isEditMode) {
      return;
    }
    const useAdjustingLocation = isModalToolRunning;
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        if (!render.isInViewRectangle(group.runtime.area.centerLocation, group.runtime.area.range)) {
          continue;
        }
        for (const connectionInfo of group.runtime.connectionInfos) {
          this.editorDrawer.drawVectorStrokeConnectionInfo(render, connectionInfo, useAdjustingLocation);
        }
      }
    }
  }
}
class RenderingVectorLayerLogic {
  constructor() {
    this.drawGPURender = new WebGLRender();
    this.lineShader = new GPULineShader();
    this.drawingVectorLayer = new DrawingVectorLayerLogic();
    this.logic_GPULine = new Logic_GPULine();
    this.strokeColor = vec4.fromValues(0, 0, 0, 1);
    this.tempMat4 = mat4.create();
    this.eyeLocation = vec3.create();
    this.lookatLocation = vec3.create();
    this.upVector = vec3.create();
    this.modelLocation = vec3.create();
    this.modelMatrix = mat4.create();
    this.viewMatrix = mat4.create();
    this.modelViewMatrix = mat4.create();
    this.projectionMatrix = mat4.create();
  }
  link(drawGPURender, lineShader, drawingVectorLayer, logic_GPULine) {
    this.drawGPURender = drawGPURender;
    this.lineShader = lineShader;
    this.drawingVectorLayer = drawingVectorLayer;
    this.logic_GPULine = logic_GPULine;
  }
  renderClearBuffer(wnd) {
    const render = this.drawGPURender;
    render.setViewport(0, 0, wnd.width, wnd.height);
    render.setDepthTest(true);
    render.setCulling(true);
    render.clearColorBufferDepthBuffer(0, 0, 0, 0);
  }
  renderForeground_VectorLayer(wnd, viewKeyFrameLayer, documentData, isEditMode, useAdjustingLocation) {
    const render = this.drawGPURender;
    const shader = this.lineShader;
    const keyframe = viewKeyFrameLayer.vectorLayerKeyframe;
    const layer = viewKeyFrameLayer.layer;
    render.setViewport(0, 0, wnd.width, wnd.height);
    vec3.set(this.lookatLocation, 0, 0, 0);
    vec3.set(this.upVector, 0, 1, 0);
    vec3.set(this.eyeLocation, 0, 0, 1);
    mat4.lookAt(this.viewMatrix, this.eyeLocation, this.lookatLocation, this.upVector);
    const aspect = wnd.height / wnd.width;
    const orthoWidth = wnd.width / 2 / wnd.viewScale * aspect;
    mat4.ortho(this.projectionMatrix, -orthoWidth, orthoWidth, orthoWidth, -orthoWidth, 0.1, 1);
    wnd.caluclateGLViewMatrix(this.tempMat4);
    mat4.multiply(this.projectionMatrix, this.tempMat4, this.projectionMatrix);
    render.setDepthTest(false);
    render.setCulling(false);
    render.setShader(shader);
    vec3.set(this.modelLocation, 0, 0, 0);
    mat4.identity(this.modelMatrix);
    mat4.translate(this.modelMatrix, this.modelMatrix, this.modelLocation);
    mat4.multiply(this.modelViewMatrix, this.viewMatrix, this.modelMatrix);
    shader.setModelViewMatrix(this.modelViewMatrix);
    shader.setProjectionMatrix(this.projectionMatrix);
    this.drawingVectorLayer.getStrokeColor(this.strokeColor, layer, documentData, isEditMode, false);
    for (const unit of keyframe.geometry.units) {
      for (const group of unit.groups) {
        if (!group.runtime.buffer.isStored) {
          this.logic_GPULine.copyGroupPointDataToBuffer(group, documentData.lineWidthBiasRate, useAdjustingLocation);
          const vertexUnitSize = shader.getVertexUnitSize();
          const vertexCount = shader.getVertexCount(group.runtime.buffer.pointCount, group.runtime.buffer.lines.length);
          this.logic_GPULine.allocateBuffer(group.runtime.buffer, vertexCount, vertexUnitSize, render);
          shader.calculateBufferData(group.runtime.buffer, this.logic_GPULine);
          if (group.runtime.buffer.usedDataArraySize > 0) {
            this.logic_GPULine.bufferData(group.runtime.buffer, render);
          }
        }
        if (group.runtime.buffer.isStored) {
          this.lineShader.setBuffers(group.runtime.buffer.buffer, this.strokeColor);
          const drawCount = this.lineShader.getDrawArrayTryanglesCount(group.runtime.buffer.usedDataArraySize);
          render.drawArrayTriangles(drawCount);
        }
      }
    }
  }
}
var DrawLineTypeID = /* @__PURE__ */ ((DrawLineTypeID2) => {
  DrawLineTypeID2[DrawLineTypeID2["none"] = 1] = "none";
  DrawLineTypeID2[DrawLineTypeID2["layerColor"] = 2] = "layerColor";
  DrawLineTypeID2[DrawLineTypeID2["paletteColor"] = 3] = "paletteColor";
  return DrawLineTypeID2;
})(DrawLineTypeID || {});
var VectorPointModifyFlagID = /* @__PURE__ */ ((VectorPointModifyFlagID2) => {
  VectorPointModifyFlagID2[VectorPointModifyFlagID2["none"] = 0] = "none";
  VectorPointModifyFlagID2[VectorPointModifyFlagID2["selectedToUnselected"] = 1] = "selectedToUnselected";
  VectorPointModifyFlagID2[VectorPointModifyFlagID2["unselectedToSelected"] = 2] = "unselectedToSelected";
  VectorPointModifyFlagID2[VectorPointModifyFlagID2["delete"] = 3] = "delete";
  VectorPointModifyFlagID2[VectorPointModifyFlagID2["edit"] = 4] = "edit";
  return VectorPointModifyFlagID2;
})(VectorPointModifyFlagID || {});
class VectorPoint {
  constructor() {
    this.location = vec3.fromValues(0, 0, 0);
    this.lineWidth = 1;
    this.isSelected = false;
    this.modifyFlag = 0;
    this.tempLocation = vec3.fromValues(0, 0, 0);
    this.adjustingLocation = vec3.fromValues(0, 0, 0);
    this.adjustingLineWidth = 0;
    this.adjustingLengthFrom = 1;
    this.adjustingLengthTo = 0;
    this.totalLength = 0;
    this.curvature = 0;
    this.location3D = vec3.fromValues(0, 0, 0);
  }
  static clone(srcPoint) {
    const point = new VectorPoint();
    vec3.copy(point.location, srcPoint.location);
    point.lineWidth = srcPoint.lineWidth;
    vec3.copy(point.adjustingLocation, point.location);
    point.adjustingLineWidth = point.lineWidth;
    return point;
  }
}
var VectorStrokeModifyFlagID = /* @__PURE__ */ ((VectorStrokeModifyFlagID2) => {
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["none"] = 0] = "none";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["selectedToUnselected"] = 1] = "selectedToUnselected";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["unselectedToSelected"] = 2] = "unselectedToSelected";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["delete"] = 3] = "delete";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["deletePoints"] = 4] = "deletePoints";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["deleteLine"] = 5] = "deleteLine";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["edit"] = 6] = "edit";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["transform"] = 7] = "transform";
  VectorStrokeModifyFlagID2[VectorStrokeModifyFlagID2["resampling"] = 8] = "resampling";
  return VectorStrokeModifyFlagID2;
})(VectorStrokeModifyFlagID || {});
class VectorStroke_RuntimeProperty {
  constructor() {
    this.modifyFlag = 0;
    this.isCloseToMouse = false;
    this.area = new RectangleArea();
    this.innerArea = new RectangleArea();
    this.totalLength = 0;
  }
}
class VectorStroke {
  constructor() {
    this.points = [];
    this.isSelected = false;
    this.runtime = new VectorStroke_RuntimeProperty();
  }
}
class VectorStrokeConnectionInfo {
  constructor() {
    this.from_Stroke = null;
    this.from_Position = 0;
    this.to_Stroke = null;
    this.to_Position = 0;
  }
}
var VectorStrokeGroupModifyFlagID = /* @__PURE__ */ ((VectorStrokeGroupModifyFlagID2) => {
  VectorStrokeGroupModifyFlagID2[VectorStrokeGroupModifyFlagID2["none"] = 0] = "none";
  VectorStrokeGroupModifyFlagID2[VectorStrokeGroupModifyFlagID2["modifyLines"] = 1] = "modifyLines";
  VectorStrokeGroupModifyFlagID2[VectorStrokeGroupModifyFlagID2["deleteLines"] = 2] = "deleteLines";
  VectorStrokeGroupModifyFlagID2[VectorStrokeGroupModifyFlagID2["delete"] = 3] = "delete";
  VectorStrokeGroupModifyFlagID2[VectorStrokeGroupModifyFlagID2["edit"] = 4] = "edit";
  return VectorStrokeGroupModifyFlagID2;
})(VectorStrokeGroupModifyFlagID || {});
class VectorStrokeGroup_RuntimeProperty {
  constructor() {
    this.modifyFlag = 0;
    this.linePointModifyFlag = 0;
    this.buffer = new GPUVertexBuffer();
    this.connectionInfos = [];
    this.needsPostUpdate = false;
    this.needsLazyUpdate = false;
    this.area = new RectangleArea();
  }
}
class VectorStrokeGroup {
  constructor() {
    this.lines = [];
    this.isSelected = false;
    this.runtime = new VectorStrokeGroup_RuntimeProperty();
  }
  static setPostUpdateNeeded(group) {
    group.runtime.needsPostUpdate = true;
  }
  static setLazyUpdateNeeded(group) {
    group.runtime.needsPostUpdate = true;
    group.runtime.needsLazyUpdate = true;
    group.runtime.buffer.isStored = false;
  }
}
var VectorStrokeDrawingUnitModifyFlagID = /* @__PURE__ */ ((VectorStrokeDrawingUnitModifyFlagID2) => {
  VectorStrokeDrawingUnitModifyFlagID2[VectorStrokeDrawingUnitModifyFlagID2["none"] = 0] = "none";
  VectorStrokeDrawingUnitModifyFlagID2[VectorStrokeDrawingUnitModifyFlagID2["delete"] = 1] = "delete";
  VectorStrokeDrawingUnitModifyFlagID2[VectorStrokeDrawingUnitModifyFlagID2["edit"] = 2] = "edit";
  return VectorStrokeDrawingUnitModifyFlagID2;
})(VectorStrokeDrawingUnitModifyFlagID || {});
class VectorStrokeDrawingUnit {
  constructor() {
    this.groups = [];
    this.modifyFlag = 0;
  }
}
var VectorLayerGeometryModifyFlagID = /* @__PURE__ */ ((VectorLayerGeometryModifyFlagID2) => {
  VectorLayerGeometryModifyFlagID2[VectorLayerGeometryModifyFlagID2["none"] = 0] = "none";
  VectorLayerGeometryModifyFlagID2[VectorLayerGeometryModifyFlagID2["delete"] = 1] = "delete";
  VectorLayerGeometryModifyFlagID2[VectorLayerGeometryModifyFlagID2["edit"] = 2] = "edit";
  return VectorLayerGeometryModifyFlagID2;
})(VectorLayerGeometryModifyFlagID || {});
class VectorLayerGeometry_RuntimeProperty {
  constructor() {
    this.modifyFlag = 0;
    this.needsPostUpdate = false;
    this.area = new RectangleArea();
  }
}
var VectorLayerGeometryTypeID = /* @__PURE__ */ ((VectorLayerGeometryTypeID2) => {
  VectorLayerGeometryTypeID2[VectorLayerGeometryTypeID2["none"] = 0] = "none";
  VectorLayerGeometryTypeID2[VectorLayerGeometryTypeID2["strokes"] = 1] = "strokes";
  VectorLayerGeometryTypeID2[VectorLayerGeometryTypeID2["surroundingFill"] = 2] = "surroundingFill";
  VectorLayerGeometryTypeID2[VectorLayerGeometryTypeID2["pointBrushFill"] = 3] = "pointBrushFill";
  return VectorLayerGeometryTypeID2;
})(VectorLayerGeometryTypeID || {});
class VectorLayerGeometry {
  constructor(type) {
    this.type = 0;
    this.units = [];
    this.runtime = new VectorLayerGeometry_RuntimeProperty();
    this.type = type;
  }
  static initialize(geometry) {
    const unit = new VectorStrokeDrawingUnit();
    unit.groups.push(new VectorStrokeGroup());
    geometry.units.push(unit);
  }
  static isStrokeDraw(geometry) {
    return geometry.type == 1;
  }
  static isSurroundingFill(geometry) {
    return geometry.type == 2;
  }
  static isPointBrushFill(geometry) {
    return geometry.type == 3;
  }
  static getGeometryTypeForLayer(layer) {
    if (VectorLayer.isPointBrushFillLayer(layer)) {
      return 3;
    } else if (VectorLayer.isSurroundingFillLayer(layer)) {
      return 2;
    } else {
      return 1;
    }
  }
  static forEachGroup(geometry, loopBodyFunction) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        loopBodyFunction(group, unit);
      }
    }
  }
  static forEachStroke(geometry, loopBodyFunction) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        for (const stroke of group.lines) {
          loopBodyFunction(stroke, group, unit);
        }
      }
    }
  }
  static forEachSegment(geometry, loopBodyFunction) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        for (const stroke of group.lines) {
          for (let index2 = 0; index2 < stroke.points.length - 1; index2++) {
            const from_point = stroke.points[index2];
            const to_point = stroke.points[index2 + 1];
            loopBodyFunction(from_point, to_point, stroke, group, unit);
          }
        }
      }
    }
  }
  static forEachPoint(geometry, loopBodyFunction) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        for (const stroke of group.lines) {
          for (const point of stroke.points) {
            loopBodyFunction(point, stroke, group, unit);
          }
        }
      }
    }
  }
  static setPostUpdateNeeded(geometry) {
    geometry.runtime.needsPostUpdate = true;
  }
}
class VectorLayerKeyframe {
  constructor(geometryType) {
    this.frame = 0;
    this.geometry = new VectorLayerGeometry(geometryType);
  }
  static createWithDefaultGeometry(geometryType) {
    const keyframe = new VectorLayerKeyframe(geometryType);
    VectorLayerGeometry.initialize(keyframe.geometry);
    return keyframe;
  }
}
var EyesSymmetryInputSideID = /* @__PURE__ */ ((EyesSymmetryInputSideID2) => {
  EyesSymmetryInputSideID2[EyesSymmetryInputSideID2["none"] = 0] = "none";
  EyesSymmetryInputSideID2[EyesSymmetryInputSideID2["left"] = 1] = "left";
  EyesSymmetryInputSideID2[EyesSymmetryInputSideID2["right"] = 2] = "right";
  return EyesSymmetryInputSideID2;
})(EyesSymmetryInputSideID || {});
class VectorLayer_RuntimeProperty extends Layer_RuntimeProperty {
  constructor() {
    super(...arguments);
    this.eyesSymmetryGeometry = null;
    this.posingLayer = null;
  }
}
class VectorLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.vectorLayer;
    this.keyframes = [];
    this.drawLineType = DrawLineTypeID.paletteColor;
    this.line_PaletteColorIndex = 0;
    this.lineWidthBiasRate = 1;
    this.fillAreaType = FillAreaTypeID.none;
    this.fillColor = vec4.fromValues(1, 1, 1, 1);
    this.fill_PaletteColorIndex = 1;
    this.eyesSymmetryEnabled = false;
    this.eyesSymmetryInputSide = 1;
    this.runtime = new VectorLayer_RuntimeProperty();
  }
  static isVectorLayer(layer) {
    return layer != null && (layer.type == LayerTypeID.vectorLayer || layer.type == LayerTypeID.vectorLayerReferenceLayer || layer.type == LayerTypeID.surroundingFillLayer || layer.type == LayerTypeID.pointBrushFillLayer);
  }
  static isVectorLayerWithOwnData(layer) {
    return layer != null && (layer.type == LayerTypeID.vectorLayer || layer.type == LayerTypeID.surroundingFillLayer || layer.type == LayerTypeID.pointBrushFillLayer);
  }
  static isVectorStrokeLayer(layer) {
    return layer != null && (layer.type == LayerTypeID.vectorLayer || layer.type == LayerTypeID.vectorLayerReferenceLayer);
  }
  static isSingleGroupVectorLayer(layer) {
    return this.isVectorLayerWithOwnData(layer) && (layer.type == LayerTypeID.vectorLayer || layer.type == LayerTypeID.pointBrushFillLayer);
  }
  static isSurroundingFillLayer(layer) {
    return layer != null && layer.type == LayerTypeID.surroundingFillLayer;
  }
  static isPointBrushFillLayer(layer) {
    return layer != null && layer.type == LayerTypeID.pointBrushFillLayer;
  }
}
class SurroundingFillLayer extends VectorLayer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.surroundingFillLayer;
  }
}
class PointBrushFillLayer extends VectorLayer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.pointBrushFillLayer;
  }
}
class AutoFillPoint {
  constructor() {
    this.location = vec3.fromValues(0, 0, 0);
    this.lookDirection = vec3.fromValues(0, 0, 0);
    this.positionInStartStroke = 0;
    this.minDistanceRange = 15;
  }
}
class AutoFillPointGroup {
  constructor() {
    this.fillPoints = [];
  }
}
class AutoFillLayerKeyframe {
  constructor() {
    this.frame = 0;
    this.groups = [];
    this.geometry = new VectorLayerGeometry(VectorLayerGeometryTypeID.surroundingFill);
    const group = new AutoFillPointGroup();
    this.groups.push(group);
    VectorLayerGeometry.initialize(this.geometry);
  }
}
class AutoFillLayer extends Layer {
  constructor() {
    super();
    this.type = LayerTypeID.autoFillLayer;
    this.keyframes = [];
    this.fillAreaType = FillAreaTypeID.paletteColor;
    this.fillColor = vec4.fromValues(1, 1, 1, 1);
    this.fill_PaletteColorIndex = 1;
    const keyframe = new AutoFillLayerKeyframe();
    this.keyframes.push(keyframe);
  }
  static isAutoFillLayer(layer) {
    return layer != null && layer.type == LayerTypeID.autoFillLayer;
  }
  static forEachFillPoint(keyframe, loopBodyFunction) {
    const looping = { break: false };
    for (const group of keyframe.groups) {
      for (const fillPoint of group.fillPoints) {
        loopBodyFunction(group, fillPoint, looping);
        if (looping.break) {
          break;
        }
      }
      if (looping.break) {
        break;
      }
    }
  }
}
class PaletteColor {
  constructor() {
    this.color = vec4.fromValues(1, 1, 1, 1);
    this.isSelected = false;
  }
}
var DocumentFileType = /* @__PURE__ */ ((DocumentFileType2) => {
  DocumentFileType2[DocumentFileType2["none"] = 0] = "none";
  DocumentFileType2[DocumentFileType2["json"] = 1] = "json";
  DocumentFileType2[DocumentFileType2["ora"] = 2] = "ora";
  return DocumentFileType2;
})(DocumentFileType || {});
var ImageFileTypeID = /* @__PURE__ */ ((ImageFileTypeID2) => {
  ImageFileTypeID2[ImageFileTypeID2["png"] = 1] = "png";
  ImageFileTypeID2[ImageFileTypeID2["jpeg"] = 2] = "jpeg";
  return ImageFileTypeID2;
})(ImageFileTypeID || {});
var DocumentBackGroundTypeID = /* @__PURE__ */ ((DocumentBackGroundTypeID2) => {
  DocumentBackGroundTypeID2[DocumentBackGroundTypeID2["lastPaletteColor"] = 1] = "lastPaletteColor";
  DocumentBackGroundTypeID2[DocumentBackGroundTypeID2["transparent"] = 2] = "transparent";
  return DocumentBackGroundTypeID2;
})(DocumentBackGroundTypeID || {});
class ExportImageSetting {
  constructor() {
    this.fileName = "";
    this.exportDirectory = "";
    this.imageFileType = 1;
    this.backGroundType = 1;
    this.exportingCount = 1;
    this.autoNumberingEnabled = false;
    this.scale = 1;
  }
}
const _DocumentData = class {
  constructor() {
    this.version = _DocumentData.versionString;
    this.rootLayer = new Layer();
    this.paletteColors = [];
    this.documentFrame = vec4.fromValues(-500, -500, 499, 499);
    this.documentFrame_HideOuterArea = true;
    this.animationSettingData = new AnimationSettingData();
    this.defaultViewScale = 1;
    this.lineWidthBiasRate = 1;
    this.exportImageSetting = new ExportImageSetting();
    this.loaded = false;
    this.hasErrorOnLoading = false;
    _DocumentData.initializeDefaultPaletteColors(this);
  }
  static initializeDefaultPaletteColors(documentData) {
    documentData.paletteColors = [];
    for (const color of _DocumentData.defaultColors) {
      const paletteColor = new PaletteColor();
      vec4.copy(paletteColor.color, color);
      documentData.paletteColors.push(paletteColor);
    }
    while (documentData.paletteColors.length < _DocumentData.maxPaletteColors) {
      const paletteColor = new PaletteColor();
      vec4.set(paletteColor.color, 1, 1, 1, 1);
      documentData.paletteColors.push(paletteColor);
    }
  }
  static getDocumentLayout(documentData, scale) {
    const frameLeft = Math.floor(documentData.documentFrame[0]);
    const frameTop = Math.floor(documentData.documentFrame[1]);
    const frameWidth = Math.floor(documentData.documentFrame[2]) - frameLeft + 1;
    const frameHeight = Math.floor(documentData.documentFrame[3]) - frameTop + 1;
    const scaledWidth = Math.floor(frameWidth * scale);
    const scaledHeight = Math.floor(frameHeight * scale);
    return { left: frameLeft, top: frameTop, width: scaledWidth, height: scaledHeight };
  }
};
let DocumentData = _DocumentData;
DocumentData.maxPaletteColors = 50;
DocumentData.versionString = "0.1.3";
DocumentData.defaultColors = [
  vec4.fromValues(0, 0, 0, 1),
  vec4.fromValues(1, 1, 1, 1),
  vec4.fromValues(0.5, 0, 0, 1),
  vec4.fromValues(0, 0.5, 0, 1),
  vec4.fromValues(0.3, 0.3, 0.8, 1),
  vec4.fromValues(250 / 255, 221 / 255, 189 / 255, 1),
  vec4.fromValues(220 / 255, 167 / 255, 125 / 255, 1),
  vec4.fromValues(249 / 255, 239 / 255, 229 / 255, 1),
  vec4.fromValues(216 / 255, 177 / 255, 170 / 255, 1),
  vec4.fromValues(198 / 255, 155 / 255, 148 / 255, 1)
];
class GroupLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.groupLayer;
  }
  static isGroupLayer(layer) {
    return layer != null && layer.type == LayerTypeID.groupLayer;
  }
}
class Posing3DLogic {
  constructor() {
    this.inputLocation = vec3.create();
    this.upVector = vec3.create();
    this.tmpMatrix = mat4.create();
    this.invMatrix = mat4.create();
    this.tmpVec3 = vec3.create();
    this.vecX = vec3.create();
    this.vecY = vec3.create();
    this.vecZ = vec3.create();
    this.eyeLocation = vec3.create();
    this.headMatrix = mat4.create();
    this.bodyRootMatrix = mat4.create();
    this.relativeInputLocation = vec3.create();
    this.relativeRotationMatrix = mat4.create();
    this.rootLocation = vec3.create();
    this.originVector = vec3.create();
    this.bodyMatrix = mat4.create();
    this.yawRotationMatrix = mat4.create();
    this.pitchRotationMatrix = mat4.create();
    this.hitTestResultLocation = mat4.create();
    this.tempTargetLocation = vec3.create();
    this.tempCenterLocation = vec3.create();
    this.tempLocalLocation = vec3.create();
    this.tempResultLocation = vec3.create();
  }
  hittest_sphere(result, x2, y2, sphereRadius) {
    const r2 = sphereRadius;
    const dist = r2 * r2 - x2 * x2 - y2 * y2;
    let z2 = 0;
    let hited;
    if (dist >= 0) {
      z2 = Math.sqrt(dist);
      hited = true;
    } else {
      hited = false;
    }
    result[0] = x2;
    result[1] = y2;
    result[2] = z2;
    return hited;
  }
  calculateInputLocation3D(result, location2D, inputSideID, targetData, posingData, posing3DView) {
    Maths.copyTranslation(this.tempCenterLocation, targetData.parentMatrix);
    return this.calculateInputLocation3DForDoubleSide(
      inputSideID == InputSideID.front ? result : null,
      inputSideID == InputSideID.back ? result : null,
      location2D,
      this.tempCenterLocation,
      targetData.hitTestSphereRadius,
      posingData,
      posing3DView
    );
  }
  calculateInputLocation3DForDoubleSide(resultFront, resultBack, location2D, centerLocation, sphereRadius, posingData, posing3DView) {
    posing3DView.calculate3DLocationFrom2DLocation(
      this.tempTargetLocation,
      location2D,
      posingData.real3DModelDistance,
      posingData
    );
    vec3.transformMat4(this.tempLocalLocation, this.tempTargetLocation, posing3DView.viewMatrix);
    vec3.transformMat4(this.tempCenterLocation, centerLocation, posing3DView.viewMatrix);
    const x2 = this.tempLocalLocation[0] - this.tempCenterLocation[0];
    const y2 = this.tempLocalLocation[1] - this.tempCenterLocation[1];
    const hited = this.hittest_sphere(this.hitTestResultLocation, x2, y2, sphereRadius);
    this.tempResultLocation[0] = this.tempCenterLocation[0] + this.hitTestResultLocation[0];
    this.tempResultLocation[1] = this.tempCenterLocation[1] + this.hitTestResultLocation[1];
    if (resultFront != null) {
      this.tempResultLocation[2] = this.tempCenterLocation[2] + this.hitTestResultLocation[2];
      vec3.transformMat4(resultFront, this.tempResultLocation, posing3DView.cameraMatrix);
    }
    if (resultBack != null) {
      this.tempResultLocation[2] = this.tempCenterLocation[2] - this.hitTestResultLocation[2];
      vec3.transformMat4(resultBack, this.tempResultLocation, posing3DView.cameraMatrix);
    }
    return hited;
  }
  calculateBodyPartDirection(inputData, rootMatrix, mode, posingData, posing3DView) {
    if (!inputData.directionInputDone) {
      mat4.copy(inputData.matrix, rootMatrix);
      return;
    }
    this.calculateInputLocation3D(
      this.inputLocation,
      inputData.inputLocation2D,
      inputData.inputSideID,
      inputData,
      posingData,
      posing3DView
    );
    mat4.copy(this.bodyRootMatrix, rootMatrix);
    mat4.invert(this.tmpMatrix, this.bodyRootMatrix);
    vec3.transformMat4(this.relativeInputLocation, this.inputLocation, this.tmpMatrix);
    vec3.normalize(this.relativeInputLocation, this.relativeInputLocation);
    if (mode == 1) {
      vec3.set(this.upVector, 1, 0, 0);
      vec3.set(this.originVector, 0, 0, 0);
      mat4.lookAt(this.relativeRotationMatrix, this.originVector, this.relativeInputLocation, this.upVector);
      mat4.invert(this.relativeRotationMatrix, this.relativeRotationMatrix);
      mat4.multiply(this.bodyMatrix, rootMatrix, this.relativeRotationMatrix);
      mat4.rotateZ(this.bodyMatrix, this.bodyMatrix, Math.PI / 2);
    } else {
      vec3.set(this.vecZ, 0, 0, 1);
      vec3.set(this.tmpVec3, this.relativeInputLocation[0], this.relativeInputLocation[1], 0);
      vec3.normalize(this.vecY, this.tmpVec3);
      vec3.cross(this.vecX, this.vecY, this.vecZ);
      mat4.identity(this.yawRotationMatrix);
      Maths.mat4SetVectors(this.yawRotationMatrix, this.vecX, this.vecY, this.vecZ);
      mat4.invert(this.invMatrix, this.yawRotationMatrix);
      vec3.transformMat4(this.vecY, this.relativeInputLocation, this.invMatrix);
      vec3.set(this.vecX, 1, 0, 0);
      vec3.cross(this.vecZ, this.vecX, this.vecY);
      mat4.identity(this.pitchRotationMatrix);
      Maths.mat4SetVectors(this.pitchRotationMatrix, this.vecX, this.vecY, this.vecZ);
      mat4.multiply(this.bodyMatrix, rootMatrix, this.yawRotationMatrix);
      mat4.multiply(this.bodyMatrix, this.bodyMatrix, this.pitchRotationMatrix);
      mat4.rotateX(this.bodyMatrix, this.bodyMatrix, Math.PI / 2);
    }
    mat4.copy(inputData.matrix, this.bodyMatrix);
    if (!inputData.rollInputDone)
      ;
    else {
      mat4.rotateZ(inputData.matrix, inputData.matrix, inputData.rollInputAngle);
    }
  }
  calculateAll(posingData, posingModel, posing3DView) {
    mat4.identity(posingData.rootMatrix);
    if (posingData.headLocationInputData.inputDone) {
      this.calculateHeadLocation(posingData, posingModel);
    }
    if (posingData.headRotationInputData.inputDone) {
      this.calculateHeadRotation(posingData, posingModel, posing3DView);
    }
    if (posingData.bodyLocationInputData.inputDone) {
      this.calculateBodyLocation(posingData, posingModel, posing3DView);
    }
    if (posingData.bodyRotationInputData.inputDone) {
      this.calculateBodyRotation(posingData, posingModel);
    }
    this.calculateLeftShoulderDirection(posingData, posingModel, posing3DView);
    this.calculateRightShoulderDirection(posingData, posingModel, posing3DView);
    if (posingData.hipsLocationInputData.inputDone) {
      this.calculateHipsLocation(posingData, posingModel, posing3DView);
    }
    if (posingData.leftArm1LocationInputData.inputDone) {
      this.calculateLeftArm1Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.leftArm2LocationInputData.inputDone) {
      this.calculateLeftArm2Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.rightArm1LocationInputData.inputDone) {
      this.calculateRightArm1Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.rightArm2LocationInputData.inputDone) {
      this.calculateRightArm2Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.leftLeg1LocationInputData.inputDone) {
      this.calculateLeftLeg1Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.leftLeg2LocationInputData.inputDone) {
      this.calculateLeftLeg2Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.rightLeg1LocationInputData.inputDone) {
      this.calculateRightLeg1Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.rightLeg2LocationInputData.inputDone) {
      this.calculateRightLeg2Direction(posingData, posingModel, posing3DView);
    }
    if (posingData.headTwistInputData.inputDone) {
      this.calculateHeadTwist(posingData, posing3DView);
    }
  }
  calculateHeadLocation(posingData, posingModel) {
    const headLocationInputData = posingData.headLocationInputData;
    mat4.identity(posingData.rootMatrix);
    if (headLocationInputData.inputDone) {
      mat4.translate(posingData.rootMatrix, posingData.rootMatrix, headLocationInputData.center);
    }
    vec3.scale(this.tmpVec3, posingModel.headCenterLocation, -1);
    mat4.translate(posingData.headMatrix, posingData.rootMatrix, this.tmpVec3);
    mat4.translate(posingData.headTopMatrix, posingData.headMatrix, posingModel.headTopLocation);
    mat4.translate(posingData.neckSphereMatrix, posingData.headMatrix, posingModel.neckSphereLocation);
    this.calculateHeadSubLocations(posingData, posingModel);
  }
  calculateHeadRotation(posingData, posingModel, posing3DView) {
    const headRotationInputData = posingData.headRotationInputData;
    if (headRotationInputData.inputDone) {
      this.calculateBodyPartDirection(
        headRotationInputData,
        posingData.neckSphereMatrix,
        1,
        posingData,
        posing3DView
      );
    } else {
      mat4.copy(headRotationInputData.matrix, posingData.neckSphereMatrix);
    }
    mat4.translate(posingData.headMatrix, headRotationInputData.matrix, posingModel.neckSphereLocation);
    mat4.rotateX(posingData.headMatrix, posingData.headMatrix, Math.PI);
    this.calculateHeadSubLocations(posingData, posingModel);
  }
  calculateHeadTwist(posingData, posing3DView) {
    const headTwistInputData = posingData.headTwistInputData;
    const headLocationInputData = posingData.headLocationInputData;
    const headRotationInputData = posingData.headRotationInputData;
    if (headTwistInputData.inputDone) {
      mat4.invert(this.invMatrix, posingData.neckSphereMatrix);
      vec3.transformMat4(this.relativeInputLocation, headTwistInputData.tempInputLocation, this.invMatrix);
      vec3.scale(this.relativeInputLocation, this.relativeInputLocation, -1);
      vec3.transformMat4(headTwistInputData.inputLocation, this.relativeInputLocation, posingData.neckSphereMatrix);
      this.calculateBodyPartDirection(
        headTwistInputData,
        posingData.neckSphereMatrix,
        1,
        posingData,
        posing3DView
      );
      mat4.multiply(this.tmpMatrix, this.invMatrix, headRotationInputData.matrix);
      mat4.multiply(headTwistInputData.matrix, headTwistInputData.matrix, this.tmpMatrix);
    } else {
      mat4.copy(headTwistInputData.matrix, posingData.headRotationInputData.matrix);
    }
    mat4.copy(headLocationInputData.headMatrix, headTwistInputData.matrix);
  }
  calculateHeadSubLocations(posingData, posingModel) {
    mat4.translate(posingData.chestRootMatrix, posingData.headMatrix, posingModel.neckSphereLocation);
  }
  calculateBodyLocation(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.bodyLocationInputData,
      posingData.chestRootMatrix,
      1,
      posingData,
      posing3DView
    );
    mat4.copy(posingData.chestMatrix, posingData.bodyLocationInputData.matrix);
    this.calculateBodySubLocations(posingData, posingModel);
  }
  calculateBodyRotation(posingData, posingModel) {
    const bodyRotationInputData = posingData.bodyRotationInputData;
    if (posingData.bodyRotationInputData.inputDone) {
      vec3.copy(this.inputLocation, bodyRotationInputData.inputLocation);
      mat4.invert(this.tmpMatrix, posingData.bodyRotationCenterMatrix);
      vec3.transformMat4(this.relativeInputLocation, this.inputLocation, this.tmpMatrix);
      this.relativeInputLocation[2] = 0;
      vec3.normalize(this.relativeInputLocation, this.relativeInputLocation);
      vec3.set(this.vecZ, 0, 0, 1);
      vec3.cross(this.vecX, this.relativeInputLocation, this.vecZ);
      mat4.identity(this.relativeRotationMatrix);
      Maths.mat4SetVectors(this.relativeRotationMatrix, this.vecX, this.relativeInputLocation, this.vecZ);
      mat4.multiply(bodyRotationInputData.matrix, posingData.bodyLocationInputData.matrix, this.relativeRotationMatrix);
    } else {
      mat4.copy(bodyRotationInputData.matrix, posingData.bodyLocationInputData.matrix);
    }
    this.calculateBodySubLocations(posingData, posingModel);
  }
  calculateHipsLocation(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.hipsLocationInputData,
      posingData.hipsRootMatrix,
      1,
      posingData,
      posing3DView
    );
    mat4.copy(posingData.hipsMatrix, posingData.hipsLocationInputData.matrix);
    this.calculateBodySubLocations(posingData, posingModel);
  }
  calculateBodySubLocations(posingData, posingModel) {
    mat4.translate(
      posingData.bodyRotationCenterMatrix,
      posingData.bodyLocationInputData.matrix,
      posingModel.bodyRotationSphereLocation
    );
    mat4.translate(
      posingData.shoulderRootMatrix,
      posingData.chestMatrix,
      posingModel.shoulderSphereLocation
    );
    mat4.translate(
      posingData.hipsRootMatrix,
      posingData.chestMatrix,
      posingModel.bodyRotationSphereLocation
    );
    mat4.translate(
      posingData.leftLeg1RootMatrix,
      posingData.hipsMatrix,
      posingModel.leftLeg1Location
    );
    mat4.translate(
      posingData.rightLeg1RootMatrix,
      posingData.hipsMatrix,
      posingModel.rightLeg1Location
    );
  }
  calculateLeftShoulderDirection(posingData, posingModel, posing3DView) {
    if (!posingData.leftShoulderLocationInputData.directionInputDone) {
      mat4.translate(
        this.tmpMatrix,
        posingData.chestMatrix,
        posingModel.leftArm1Location
      );
      Maths.copyTranslation(posingData.leftShoulderLocationInputData.inputLocation, this.tmpMatrix);
      posingData.leftShoulderLocationInputData.directionInputDone = true;
    }
    this.calculateBodyPartDirection(
      posingData.leftShoulderLocationInputData,
      posingData.shoulderRootMatrix,
      1,
      posingData,
      posing3DView
    );
    vec3.set(this.tmpVec3, 0, 0, -vec3.length(posingModel.leftArm1Location));
    mat4.translate(posingData.leftArm1RootMatrix, posingData.leftShoulderLocationInputData.matrix, this.tmpVec3);
  }
  calculateRightShoulderDirection(posingData, posingModel, posing3DView) {
    if (!posingData.rightShoulderLocationInputData.directionInputDone) {
      mat4.translate(
        this.tmpMatrix,
        posingData.chestMatrix,
        posingModel.rightArm1Location
      );
      Maths.copyTranslation(posingData.rightShoulderLocationInputData.inputLocation, this.tmpMatrix);
      posingData.rightShoulderLocationInputData.directionInputDone = true;
    }
    this.calculateBodyPartDirection(
      posingData.rightShoulderLocationInputData,
      posingData.shoulderRootMatrix,
      1,
      posingData,
      posing3DView
    );
    vec3.set(this.tmpVec3, 0, 0, -vec3.length(posingModel.rightArm1Location));
    mat4.translate(posingData.rightArm1RootMatrix, posingData.rightShoulderLocationInputData.matrix, this.tmpVec3);
  }
  calculateLeftArm1Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.leftArm1LocationInputData,
      posingData.leftArm1RootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.leftArm1LocationInputData, posingModel.leftArm1HeadLocation);
  }
  calculateRightArm1Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.rightArm1LocationInputData,
      posingData.rightArm1RootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.rightArm1LocationInputData, posingModel.rightArm1HeadLocation);
  }
  calculateLeftLeg1Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.leftLeg1LocationInputData,
      posingData.leftLeg1RootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.leftLeg1LocationInputData, posingModel.leftLeg1HeadLocation);
    if (!posingData.leftLeg2LocationInputData.inputDone) {
      const frontDirectionValue = posingData.leftLeg1LocationInputData.matrix[5];
      if (frontDirectionValue > 0) {
        posingData.leftLeg2LocationInputData.inputSideID = InputSideID.back;
      } else {
        posingData.leftLeg2LocationInputData.inputSideID = InputSideID.front;
      }
    }
  }
  calculateRightLeg1Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.rightLeg1LocationInputData,
      posingData.rightLeg1RootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.rightLeg1LocationInputData, posingModel.rightLeg1HeadLocation);
    if (!posingData.rightLeg2LocationInputData.inputDone) {
      const frontDirectionValue = posingData.rightLeg1LocationInputData.matrix[5];
      if (frontDirectionValue > 0) {
        posingData.rightLeg2LocationInputData.inputSideID = InputSideID.back;
      } else {
        posingData.rightLeg2LocationInputData.inputSideID = InputSideID.front;
      }
    }
  }
  calculateLeftArm2Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.leftArm2LocationInputData,
      posingData.leftArm1LocationInputData.childJointRootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.leftArm2LocationInputData, posingModel.leftArm2HeadLocation);
  }
  calculateRightArm2Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.rightArm2LocationInputData,
      posingData.rightArm1LocationInputData.childJointRootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.rightArm2LocationInputData, posingModel.rightArm2HeadLocation);
  }
  calculateLeftLeg2Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.leftLeg2LocationInputData,
      posingData.leftLeg1LocationInputData.childJointRootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.leftLeg2LocationInputData, posingModel.leftLeg2HeadLocation);
  }
  calculateRightLeg2Direction(posingData, posingModel, posing3DView) {
    this.calculateBodyPartDirection(
      posingData.rightLeg2LocationInputData,
      posingData.rightLeg1LocationInputData.childJointRootMatrix,
      1,
      posingData,
      posing3DView
    );
    this.calculateArmLegSubLocations(posingData.rightLeg2LocationInputData, posingModel.rightLeg2HeadLocation);
  }
  calculateArmLegSubLocations(parent, childLocation) {
    mat4.translate(
      parent.childJointRootMatrix,
      parent.matrix,
      childLocation
    );
  }
  getEyeSphereLocation(result, posingData, eyesSymmetryInputSide) {
    const side = eyesSymmetryInputSide == EyesSymmetryInputSideID.left ? 1 : -1;
    const horizontalPos = 0.023;
    const verticalPos = 0.074;
    const forwardPos = 0.04;
    vec3.set(this.eyeLocation, horizontalPos * side, forwardPos, verticalPos);
    vec3.transformMat4(result, this.eyeLocation, posingData.headMatrix);
  }
  getEyeSphereSize() {
    const eyeSize = 0.045;
    return eyeSize;
  }
}
class Posing3DModelLogic {
  constructor() {
    this.tempVec3 = vec3.create();
    this.fromLocation = vec3.create();
    this.toLocation = vec3.create();
    this.upVector = vec3.create();
    this.tempMat4 = mat4.create();
    this.chestInvMat4 = mat4.create();
    this.hipsInvMat4 = mat4.create();
  }
  createPosingModel(modelData) {
    const posingModel = new PosingModel();
    for (let index2 = 0; index2 < modelData.bones.length; index2++) {
      const bone = modelData.bones[index2];
      bone.worldMat = mat4.create();
      if (bone.parent == -1) {
        mat4.copy(bone.worldMat, bone.matrix);
      } else {
        mat4.multiply(bone.worldMat, modelData.bones[bone.parent].worldMat, bone.matrix);
      }
      bone.invMat = mat4.create();
      mat4.invert(bone.invMat, bone.worldMat);
    }
    const head = this.findBone(modelData.bones, "head");
    const headCenter = this.findBone(modelData.bones, "headCenter");
    const headTop = this.findBone(modelData.bones, "headTop");
    const chest = this.findBone(modelData.bones, "chest");
    const hips = this.findBone(modelData.bones, "hips");
    const hipsTop = this.findBone(modelData.bones, "hipsTop");
    const hipL = this.findBone(modelData.bones, "hip.L");
    const neck1 = this.findBone(modelData.bones, "neck1");
    const neck2 = this.findBone(modelData.bones, "neck2");
    Maths.copyTranslation(this.toLocation, headCenter.worldMat);
    vec3.transformMat4(posingModel.headCenterLocation, this.toLocation, head.invMat);
    mat4.multiply(this.tempMat4, headTop.worldMat, head.invMat);
    Maths.copyTranslation(posingModel.headTopLocation, this.tempMat4);
    Maths.copyTranslation(this.toLocation, neck2.worldMat);
    vec3.transformMat4(posingModel.neckSphereLocation, this.toLocation, head.invMat);
    Maths.copyTranslation(this.fromLocation, headTop.worldMat);
    Maths.copyTranslation(this.toLocation, neck2.worldMat);
    vec3.subtract(posingModel.headTopToNeckVector, this.fromLocation, this.toLocation);
    Maths.copyTranslation(this.fromLocation, neck2.worldMat);
    Maths.copyTranslation(this.toLocation, chest.worldMat);
    vec3.set(this.upVector, 0, 0, 1);
    mat4.lookAt(this.chestInvMat4, this.fromLocation, this.toLocation, this.upVector);
    mat4.multiply(posingModel.chestModelConvertMatrix, this.chestInvMat4, chest.worldMat);
    Maths.copyTranslation(this.toLocation, hips.worldMat);
    vec3.transformMat4(posingModel.bodyRotationSphereLocation, this.toLocation, this.chestInvMat4);
    vec3.subtract(this.tempVec3, this.fromLocation, this.toLocation);
    posingModel.bodySphereSize = vec3.length(this.tempVec3);
    Maths.copyTranslation(this.fromLocation, hips.worldMat);
    Maths.copyTranslation(this.toLocation, hipL.worldMat);
    vec3.set(this.upVector, 0, 0, 1);
    mat4.lookAt(this.hipsInvMat4, this.fromLocation, this.toLocation, this.upVector);
    mat4.multiply(posingModel.hipsModelConvertMatrix, this.hipsInvMat4, hips.worldMat);
    mat4.rotateY(posingModel.hipsModelConvertMatrix, posingModel.hipsModelConvertMatrix, Math.PI);
    Maths.copyTranslation(this.fromLocation, hips.worldMat);
    Maths.copyTranslation(this.toLocation, hipsTop.worldMat);
    vec3.subtract(this.tempVec3, this.fromLocation, this.toLocation);
    posingModel.hipsSphereSize = vec3.length(this.tempVec3);
    Maths.copyTranslation(this.toLocation, neck1.worldMat);
    vec3.transformMat4(posingModel.shoulderSphereLocation, this.toLocation, this.chestInvMat4);
    const arm1L = this.findBone(modelData.bones, "arm1.L");
    Maths.copyTranslation(this.toLocation, arm1L.worldMat);
    vec3.transformMat4(posingModel.leftArm1Location, this.toLocation, this.chestInvMat4);
    const arm1R = this.findBone(modelData.bones, "arm1.R");
    Maths.copyTranslation(this.toLocation, arm1R.worldMat);
    vec3.transformMat4(posingModel.rightArm1Location, this.toLocation, this.chestInvMat4);
    const arm2L = this.findBone(modelData.bones, "arm2.L");
    posingModel.leftArm1HeadLocation[2] = -arm2L.matrix[13];
    const arm2R = this.findBone(modelData.bones, "arm2.R");
    posingModel.rightArm1HeadLocation[2] = -arm2R.matrix[13];
    const leg1L = this.findBone(modelData.bones, "leg1.L");
    Maths.copyTranslation(this.toLocation, leg1L.worldMat);
    vec3.transformMat4(posingModel.leftLeg1Location, this.toLocation, this.hipsInvMat4);
    const leg1R = this.findBone(modelData.bones, "leg1.R");
    Maths.copyTranslation(this.toLocation, leg1R.worldMat);
    vec3.transformMat4(posingModel.rightLeg1Location, this.toLocation, this.hipsInvMat4);
    const leg2L = this.findBone(modelData.bones, "leg2.L");
    posingModel.leftLeg1HeadLocation[2] = -leg2L.matrix[13];
    const leg2R = this.findBone(modelData.bones, "leg2.R");
    posingModel.rightLeg1HeadLocation[2] = -leg2R.matrix[13];
    return posingModel;
  }
  findBone(bones, boneName) {
    for (const bone of bones) {
      if (bone.name == boneName) {
        return bone;
      }
    }
    return null;
  }
}
class ImageResource {
  constructor() {
    this.filePath = "";
    this.image = new RenderImage();
    this.isGLTexture = false;
    this.cssImageClassName = "";
    this.loaded = false;
    this.error = false;
  }
  set({ filePath, cssImageClassName, isGLTexture }) {
    this.filePath = filePath;
    if (cssImageClassName) {
      this.cssImageClassName = cssImageClassName;
    }
    if (isGLTexture) {
      this.isGLTexture = isGLTexture;
    }
    return this;
  }
}
class ModelResource {
  constructor() {
    this.modelName = null;
    this.model = new RenderModel();
  }
}
class ModelFile {
  constructor() {
    this.fileName = null;
    this.modelResources = [];
    this.modelResourceDictionary = /* @__PURE__ */ new Map();
    this.posingModelDictionary = /* @__PURE__ */ new Map();
    this.loaded = false;
    this.error = false;
  }
  file(fileName) {
    this.fileName = fileName;
    return this;
  }
}
class Posing3DView {
  constructor() {
    this.render = null;
    this.webglWindow = null;
    this.posingFigureShader = new PosingFigureShader();
    this.depthShader = new DepthShader();
    this.imageResurces = [];
    this.axisModel = null;
    this.zTestShpereModel = null;
    this.zTestShpereEdgeModel = null;
    this.headModel = null;
    this.chestModel = null;
    this.leftSholderModel = null;
    this.rightSholderModel = null;
    this.hipsModel = null;
    this.leftArm1Model = null;
    this.leftArm2Model = null;
    this.rightArm1Model = null;
    this.rightArm2Model = null;
    this.leftLeg1Model = null;
    this.leftLeg2Model = null;
    this.rightLeg1Model = null;
    this.rightLeg2Model = null;
    this.eyeLocation = vec3.create();
    this.lookatLocation = vec3.create();
    this.upVector = vec3.create();
    this.modelMatrix = mat4.create();
    this.normalMatrix = mat4.create();
    this.viewMatrix = mat4.create();
    this.modelViewMatrix = mat4.create();
    this.projectionMatrix = mat4.create();
    this.projectionInvMatrix = mat4.create();
    this.cameraMatrix = mat4.create();
    this.real3DProjectionMatrix = mat4.create();
    this.locationMatrix = mat4.create();
    this.tempVec3 = vec3.create();
    this.invProjectedVec3 = vec3.create();
    this.tmpMatrix = mat4.create();
    this.screenLocation = vec3.create();
  }
  initialize(render, webglWindow) {
    this.render = render;
    this.webglWindow = webglWindow;
    this.render.initializeShader(this.posingFigureShader);
    this.render.initializeShader(this.depthShader);
    this.render.setShader(this.depthShader);
  }
  storeResources(modelFile, imageResurces) {
    this.axisModel = modelFile.modelResourceDictionary.get("Axis");
    this.zTestShpereModel = modelFile.modelResourceDictionary.get("ZTestSphere");
    this.zTestShpereEdgeModel = modelFile.modelResourceDictionary.get("ZTestSphereEdge");
    this.headModel = modelFile.modelResourceDictionary.get("Head02");
    this.chestModel = modelFile.modelResourceDictionary.get("Chest");
    this.leftSholderModel = modelFile.modelResourceDictionary.get("LeftShoulder");
    this.rightSholderModel = modelFile.modelResourceDictionary.get("LeftShoulder");
    this.hipsModel = modelFile.modelResourceDictionary.get("Hips");
    this.leftArm1Model = modelFile.modelResourceDictionary.get("Arm1");
    this.leftArm2Model = modelFile.modelResourceDictionary.get("Arm1");
    this.rightArm1Model = modelFile.modelResourceDictionary.get("Arm1");
    this.rightArm2Model = modelFile.modelResourceDictionary.get("Arm1");
    this.leftLeg1Model = modelFile.modelResourceDictionary.get("Leg1");
    this.leftLeg2Model = modelFile.modelResourceDictionary.get("Leg2");
    this.rightLeg1Model = modelFile.modelResourceDictionary.get("Leg1");
    this.rightLeg2Model = modelFile.modelResourceDictionary.get("Leg2");
    this.imageResurces.push(imageResurces[0]);
  }
  buildDrawingStructures(posingLayer) {
    const posingData = posingLayer.posingData;
    const posingModel = posingLayer.posingModel;
    const drawingUnits = [];
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "headLocationInputData";
      unit.targetData = posingData.headRotationInputData;
      unit.dependentInputData = posingData.headLocationInputData;
      unit.subToolID = SubToolID.p3d_rotateHead;
      unit.modelResource = this.headModel;
      unit.drawModel = false;
      unit.targetData.parentMatrix = posingData.neckSphereMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.headTopToNeckVector);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "bodyLocationInputData";
      unit.targetData = posingData.bodyLocationInputData;
      unit.dependentInputData = posingData.headLocationInputData;
      unit.modelConvertMatrix = posingModel.chestModelConvertMatrix;
      unit.subToolID = SubToolID.p3d_locateBody;
      unit.modelResource = this.chestModel;
      unit.targetData.parentMatrix = posingData.chestRootMatrix;
      unit.targetData.hitTestSphereRadius = posingModel.bodySphereSize;
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "hipsLocationInputData";
      unit.targetData = posingData.hipsLocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.modelConvertMatrix = posingModel.hipsModelConvertMatrix;
      unit.subToolID = SubToolID.p3d_locateHips;
      unit.modelResource = this.hipsModel;
      unit.targetData.parentMatrix = posingData.hipsRootMatrix;
      unit.targetData.hitTestSphereRadius = posingModel.hipsSphereSize;
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "leftShoulderLocationInputData";
      unit.targetData = posingData.leftShoulderLocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateLeftShoulder;
      unit.modelResource = this.leftSholderModel;
      unit.targetData.parentMatrix = posingData.shoulderRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.leftArm1Location);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "leftArm1LocationInputData";
      unit.targetData = posingData.leftArm1LocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateLeftArm1;
      unit.modelResource = this.leftArm1Model;
      unit.targetData.parentMatrix = posingData.leftArm1RootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.leftArm1HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "leftArm2LocationInputData";
      unit.targetData = posingData.leftArm2LocationInputData;
      unit.dependentInputData = posingData.leftArm1LocationInputData;
      unit.subToolID = SubToolID.p3d_locateLeftArm2;
      unit.modelResource = this.leftArm2Model;
      unit.targetData.parentMatrix = posingData.leftArm1LocationInputData.childJointRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.leftArm2HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightShoulderLocationInputData";
      unit.targetData = posingData.rightShoulderLocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateRightShoulder;
      unit.modelResource = this.rightSholderModel;
      unit.targetData.parentMatrix = posingData.shoulderRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.rightArm1Location);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightArm1LocationInputData";
      unit.targetData = posingData.rightArm1LocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateRightArm1;
      unit.modelResource = this.rightArm1Model;
      unit.targetData.parentMatrix = posingData.rightArm1RootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.rightArm1HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightArm2LocationInputData";
      unit.targetData = posingData.rightArm2LocationInputData;
      unit.dependentInputData = posingData.rightArm1LocationInputData;
      unit.subToolID = SubToolID.p3d_locateRightArm2;
      unit.modelResource = this.rightArm2Model;
      unit.targetData.parentMatrix = posingData.rightArm1LocationInputData.childJointRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.rightArm2HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "leftLeg1LocationInputData";
      unit.targetData = posingData.leftLeg1LocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateLeftLeg1;
      unit.modelResource = this.leftLeg1Model;
      unit.targetData.parentMatrix = posingData.leftLeg1RootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.leftLeg1HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightLeg2LocationInputData";
      unit.targetData = posingData.leftLeg2LocationInputData;
      unit.dependentInputData = posingData.leftLeg1LocationInputData;
      unit.subToolID = SubToolID.p3d_locateLeftLeg2;
      unit.modelResource = this.leftLeg2Model;
      unit.targetData.parentMatrix = posingData.leftLeg1LocationInputData.childJointRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.leftLeg2HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightLeg1LocationInputData";
      unit.targetData = posingData.rightLeg1LocationInputData;
      unit.dependentInputData = posingData.bodyLocationInputData;
      unit.subToolID = SubToolID.p3d_locateRightLeg1;
      unit.modelResource = this.rightLeg1Model;
      unit.targetData.parentMatrix = posingData.rightLeg1RootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.rightLeg1HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "rightLeg2LocationInputData";
      unit.targetData = posingData.rightLeg2LocationInputData;
      unit.dependentInputData = posingData.rightLeg1LocationInputData;
      unit.subToolID = SubToolID.p3d_locateRightLeg2;
      unit.modelResource = this.rightLeg2Model;
      unit.targetData.parentMatrix = posingData.rightLeg1LocationInputData.childJointRootMatrix;
      unit.targetData.hitTestSphereRadius = vec3.length(posingModel.rightLeg2HeadLocation);
      drawingUnits.push(unit);
    }
    {
      const unit = new JointPartDrawingUnit();
      unit.name = "headTwistInputData";
      unit.targetData = posingData.headTwistInputData;
      unit.dependentInputData = posingData.headRotationInputData;
      unit.subToolID = SubToolID.p3d_twistHead;
      unit.drawModel = false;
      unit.targetData.parentMatrix = posingData.neckSphereMatrix;
      unit.targetData.hitTestSphereRadius = posingModel.headTwistSphereSize;
      drawingUnits.push(unit);
    }
    posingLayer.runtime.drawingUnits = drawingUnits;
  }
  clear() {
    this.render.setDepthTest(true);
    this.render.setCulling(true);
    this.render.clearColorBufferDepthBuffer(0, 0, 0, 0);
  }
  prepareDrawingStructures(posingLayer) {
    if (posingLayer.runtime.drawingUnits == null) {
      this.buildDrawingStructures(posingLayer);
    }
  }
  drawManipulaters(posingLayer, ctx) {
    const posingData = posingLayer.posingData;
    this.caluculateCameraMatrix(posingData);
    this.drawHeadSphere(1, posingLayer, ctx);
    for (const drawingUnit of posingLayer.runtime.drawingUnits) {
      if (ctx.subtoolID == drawingUnit.subToolID) {
        this.drawSphere(
          1,
          drawingUnit.targetData.inputSideID,
          drawingUnit.targetData.parentMatrix,
          drawingUnit.targetData.hitTestSphereRadius,
          posingLayer,
          ctx
        );
      }
    }
  }
  drawPosingModel(posingLayer, ctx) {
    const posingData = posingLayer.posingData;
    this.caluculateCameraMatrix(posingData);
    this.render.clearDepthBuffer();
    if (this.isHeadDrawable(posingData)) {
      this.setShaderParameters(posingData.headMatrix, false, this.posingFigureShader);
      this.posingFigureShader.setAlpha(posingLayer.layerColor[3]);
      this.drawModel(this.posingFigureShader, this.headModel.model, this.imageResurces[0].image);
    }
    if (this.isBodyDrawable(posingData))
      ;
    for (const drawingUnit of posingLayer.runtime.drawingUnits) {
      if (drawingUnit.drawModel && drawingUnit.targetData.inputDone) {
        if (drawingUnit.modelConvertMatrix != null) {
          mat4.multiply(this.tmpMatrix, drawingUnit.targetData.matrix, drawingUnit.modelConvertMatrix);
        } else {
          mat4.copy(this.tmpMatrix, drawingUnit.targetData.matrix);
        }
        this.setShaderParameters(this.tmpMatrix, false, this.posingFigureShader);
        this.posingFigureShader.setAlpha(drawingUnit.visualModelAlpha * posingLayer.layerColor[3]);
        this.drawModel(this.posingFigureShader, drawingUnit.modelResource.model, this.imageResurces[0].image);
      }
    }
  }
  drawPickingImage(posingLayer, ctx) {
    this.render.setBlendType(WebGLRenderBlendType.src);
    this.drawHeadSphere(2, posingLayer, ctx);
    this.drawBodySphere(2, posingLayer, ctx);
    this.drawBodyRotationSphere(2, posingLayer, ctx);
    for (const drawingUnit of posingLayer.runtime.drawingUnits) {
      if (ctx.subtoolID == drawingUnit.subToolID) {
        this.drawSphere(
          2,
          drawingUnit.targetData.inputSideID,
          drawingUnit.targetData.parentMatrix,
          drawingUnit.targetData.hitTestSphereRadius,
          posingLayer,
          ctx
        );
      }
    }
    this.render.setBlendType(WebGLRenderBlendType.blend);
  }
  getCurrentDrawingUnit(ctx) {
    for (const drawingUnit of ctx.currentPosingLayer.runtime.drawingUnits) {
      if (ctx.subtoolID == drawingUnit.subToolID) {
        return drawingUnit;
      }
    }
    return null;
  }
  drawHeadSphere(drawImageType, posingLayer, ctx) {
    const posingData = posingLayer.posingData;
    const posingModel = posingLayer.posingModel;
    const needsDrawing = posingData != null && posingData.headLocationInputData.inputDone && ctx.subtoolID == SubToolID.p3d_locateHead;
    if (!needsDrawing) {
      return;
    }
    mat4.copy(this.locationMatrix, posingData.rootMatrix);
    const scale = posingModel.headSphereSize;
    mat4.scale(this.locationMatrix, this.locationMatrix, vec3.set(this.tempVec3, scale, scale, scale));
    if (drawImageType == 1) {
      this.drawZTestSphere(this.locationMatrix, posingData.headRotationInputData.inputSideID, ctx);
    } else {
      this.render.clearDepthBuffer();
      this.drawZTestSphereDepth(this.locationMatrix, posingData.headRotationInputData.inputSideID);
    }
  }
  drawBodySphere(drawImageType, posingLayer, ctx) {
    const posingData = posingLayer.posingData;
    const posingModel = posingLayer.posingModel;
    const needsDrawing = posingData != null && posingData.headLocationInputData.inputDone && ctx.subtoolID == SubToolID.p3d_locateBody;
    if (!needsDrawing) {
      return;
    }
    Maths.copyTranslation(this.tempVec3, posingData.chestRootMatrix);
    mat4.identity(this.tmpMatrix);
    mat4.translate(this.locationMatrix, this.tmpMatrix, this.tempVec3);
    const scale = posingModel.bodySphereSize;
    mat4.scale(this.locationMatrix, this.locationMatrix, vec3.set(this.tempVec3, scale, scale, scale));
    if (drawImageType == 1) {
      this.drawZTestSphere(this.locationMatrix, posingData.bodyLocationInputData.inputSideID, ctx);
    } else {
      this.render.clearDepthBuffer();
      this.drawZTestSphereDepth(this.locationMatrix, posingData.bodyLocationInputData.inputSideID);
    }
  }
  drawBodyRotationSphere(drawImageType, posingLayer, ctx) {
    const posingData = posingLayer.posingData;
    const posingModel = posingLayer.posingModel;
    const needsDrawing = posingData != null && posingData.bodyLocationInputData.inputDone && ctx.subtoolID == SubToolID.p3d_locateHips;
    if (!needsDrawing) {
      return;
    }
    Maths.copyTranslation(this.tempVec3, posingData.bodyRotationCenterMatrix);
    mat4.identity(this.tmpMatrix);
    mat4.translate(this.locationMatrix, this.tmpMatrix, this.tempVec3);
    const scale = posingModel.bodyRotationSphereSize;
    mat4.scale(this.locationMatrix, this.locationMatrix, vec3.set(this.tempVec3, scale, scale, scale));
    if (drawImageType == 1) {
      this.drawZTestSphere(this.locationMatrix, posingData.bodyRotationInputData.inputSideID, ctx);
    } else {
      this.render.clearDepthBuffer();
      this.drawZTestSphereDepth(this.locationMatrix, posingData.bodyRotationInputData.inputSideID);
    }
  }
  drawSphere(drawImageType, inputSideID, rootMatrix, scale, posingLayer, ctx) {
    Maths.copyTranslation(this.tempVec3, rootMatrix);
    mat4.identity(this.tmpMatrix);
    mat4.translate(this.locationMatrix, this.tmpMatrix, this.tempVec3);
    mat4.scale(this.locationMatrix, this.locationMatrix, vec3.set(this.tempVec3, scale, scale, scale));
    if (drawImageType == 1) {
      this.drawZTestSphere(this.locationMatrix, inputSideID, ctx);
    } else {
      this.render.clearDepthBuffer();
      this.drawZTestSphereDepth(this.locationMatrix, inputSideID);
    }
  }
  isHeadDrawable(posingData) {
    return posingData != null && (posingData.headLocationInputData.inputDone || posingData.headRotationInputData.inputDone);
  }
  isBodyDrawable(posingData) {
    return posingData != null && posingData.bodyLocationInputData.inputDone;
  }
  isLeftArm1Drawable(posingData) {
    return posingData != null && posingData.leftArm1LocationInputData.inputDone;
  }
  isRightArm1Drawable(posingData) {
    return posingData != null && posingData.rightArm1LocationInputData.inputDone;
  }
  isLeftLeg1Drawable(posingData) {
    return posingData != null && posingData.leftLeg1LocationInputData.inputDone;
  }
  isRightLeg1Drawable(posingData) {
    return posingData != null && posingData.rightLeg1LocationInputData.inputDone;
  }
  setShaderParameters(locationMatrix, flipSide, shader) {
    mat4.copy(this.modelMatrix, locationMatrix);
    const wnd = this.webglWindow;
    const cullingBackFace = !wnd.mirrorX;
    if (flipSide) {
      mat4.scale(this.modelMatrix, this.modelMatrix, vec3.set(this.tempVec3, 1, -1, 1));
    }
    this.render.setCullingBackFace(cullingBackFace);
    mat4.multiply(this.modelViewMatrix, this.viewMatrix, this.modelMatrix);
    mat4.copy(this.normalMatrix, this.modelViewMatrix);
    this.normalMatrix[12] = 0;
    this.normalMatrix[13] = 0;
    this.normalMatrix[14] = 0;
    if (flipSide) {
      mat4.scale(this.normalMatrix, this.normalMatrix, vec3.set(this.tempVec3, -1, -1, -1));
    }
    this.render.setShader(shader);
    shader.setProjectionMatrix(this.projectionMatrix);
    shader.setModelViewMatrix(this.modelViewMatrix);
    shader.setNormalMatrix(this.normalMatrix);
  }
  drawZTestSphere(locationMatrix, inputSideID, ctx) {
    const modelResource = this.zTestShpereModel;
    const flipSide = inputSideID == InputSideID.back;
    this.setShaderParameters(locationMatrix, flipSide, this.posingFigureShader);
    if (this.isHeadDrawable(ctx.currentPosingData)) {
      this.posingFigureShader.setAlpha(0.3);
    } else {
      this.posingFigureShader.setAlpha(0.8);
    }
    this.drawModel(this.posingFigureShader, modelResource.model, this.imageResurces[0].image);
    this.render.setCullingBackFace(true);
  }
  drawZTestSphereDepth(locationMatrix, inputSideID) {
    const flipSide = inputSideID == InputSideID.back;
    this.setShaderParameters(locationMatrix, flipSide, this.depthShader);
    this.drawModel(this.depthShader, this.zTestShpereModel.model, this.imageResurces[0].image);
    this.drawModel(this.depthShader, this.zTestShpereEdgeModel.model, this.imageResurces[0].image);
  }
  drawAxis(locationMatrix, scale, alpha) {
    mat4.copy(this.modelMatrix, locationMatrix);
    mat4.scale(this.modelMatrix, this.modelMatrix, vec3.set(this.tempVec3, scale, scale, scale));
    this.setShaderParameters(this.modelMatrix, false, this.posingFigureShader);
    this.posingFigureShader.setAlpha(alpha);
    this.drawModel(this.posingFigureShader, this.axisModel.model, this.imageResurces[0].image);
  }
  drawModel(shader, model, image) {
    shader.setBuffers(model, [image]);
    this.render.activeTexture(image);
    this.render.drawElements(model);
  }
  caluculateCameraMatrix(posingData) {
    const wnd = this.webglWindow;
    const real3DViewHalfWidth = posingData.real3DViewMeterPerPixel * (wnd.height / 2);
    vec3.set(this.lookatLocation, 0, -1, 0);
    vec3.set(this.upVector, 0, 0, 1);
    vec3.set(this.eyeLocation, 0, 0, 0);
    const viewScale = wnd.viewScale;
    const orthoWidth = real3DViewHalfWidth / viewScale;
    mat4.ortho(this.real3DProjectionMatrix, -real3DViewHalfWidth, real3DViewHalfWidth, -real3DViewHalfWidth, real3DViewHalfWidth, 0.1, 10);
    mat4.ortho(this.projectionMatrix, -orthoWidth, orthoWidth, -orthoWidth, orthoWidth, 0.1, 10);
    wnd.caluclateGLViewMatrix(this.tmpMatrix);
    mat4.multiply(this.projectionMatrix, this.tmpMatrix, this.projectionMatrix);
    mat4.invert(this.projectionInvMatrix, this.projectionMatrix);
    mat4.lookAt(this.viewMatrix, this.eyeLocation, this.lookatLocation, this.upVector);
    mat4.invert(this.cameraMatrix, this.viewMatrix);
  }
  calculate3DLocationFrom2DLocation(result, real2DLocation, depth, posingData) {
    const wnd = this.webglWindow;
    this.caluculateCameraMatrix(posingData);
    vec3.transformMat4(this.screenLocation, real2DLocation, wnd.transformMatrix);
    const viewHalfWidth = wnd.width / 2;
    const viewHalfHeight = wnd.height / 2;
    this.screenLocation[0] = (this.screenLocation[0] - viewHalfWidth) / viewHalfWidth;
    this.screenLocation[1] = -(this.screenLocation[1] - viewHalfHeight) / viewHalfHeight;
    this.screenLocation[2] = 0;
    vec3.transformMat4(this.invProjectedVec3, this.screenLocation, this.projectionInvMatrix);
    this.invProjectedVec3[2] = -depth;
    vec3.transformMat4(result, this.invProjectedVec3, this.cameraMatrix);
  }
  calculate2DLocationFrom3DLocation(result, real3DLocation, posingData) {
    const wnd = this.webglWindow;
    this.caluculateCameraMatrix(posingData);
    vec3.transformMat4(result, real3DLocation, this.viewMatrix);
    const depth = result[2];
    vec3.transformMat4(result, result, this.real3DProjectionMatrix);
    result[0] *= wnd.height / 2;
    result[1] *= -(wnd.height / 2);
    return depth;
  }
  pick3DLocationFromDepthImage(result, location2d, posingData, pickingWindow, maxDepth) {
    vec3.transformMat4(this.tempVec3, location2d, pickingWindow.transformMatrix);
    if (this.tempVec3[0] < 0 || this.tempVec3[0] >= pickingWindow.width || this.tempVec3[1] < 0 || this.tempVec3[1] >= pickingWindow.height) {
      return false;
    }
    const imageData = pickingWindow.context.getImageData(Math.floor(this.tempVec3[0]), Math.floor(this.tempVec3[1]), 1, 1);
    const r2 = imageData.data[0];
    const g = imageData.data[1];
    const b = imageData.data[2];
    if (r2 == 0 && g == 0 && b == 0) {
      return false;
    }
    let depth = r2 / 255 + g / Math.pow(255, 2) + b / Math.pow(255, 3);
    depth *= maxDepth;
    this.calculate3DLocationFrom2DLocation(result, location2d, depth, posingData);
    return true;
  }
}
class PosingFigureShader extends RenderShader {
  constructor() {
    super(...arguments);
    this.aPosition = -1;
    this.aNormal = -1;
    this.aTexCoord = -1;
    this.uTexture0 = null;
    this.uNormalMatrix = null;
    this.uAlpha = null;
  }
  initializeVertexSourceCode() {
    this.vertexShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;
uniform mat4 uNormalMatrix;

varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vTexCoord;

void main(void) {

  gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);

  vPosition = (uMVMatrix * vec4(aPosition, 1.0)).xyz;
  vNormal = (uNormalMatrix * vec4(aNormal, 1.0)).xyz;
  vTexCoord = aTexCoord;
}
`;
  }
  initializeFragmentSourceCode() {
    this.fragmentShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vTexCoord;

uniform sampler2D uTexture0;
uniform float uAlpha;

void main(void) {

  vec3  directionalLight = normalize(vec3(0.0, 1.0, 1.0));

  vec3  nnormal = normalize(vNormal);
  float directional = clamp(dot(nnormal, directionalLight), 0.0, 1.0);

  vec3  viewVec = normalize(vPosition);
  float specular = pow(max(dot(nnormal, normalize(directionalLight - viewVec)), 0.0), 5.0);

  vec4 texColor = texture2D(uTexture0, vTexCoord);
  gl_FragColor = vec4(texColor.rgb * 0.2 + texColor.rgb * directional * 0.8, texColor.a * uAlpha);

}
`;
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
    this.initializeAttributes_PosingFigureShader();
  }
  initializeAttributes_PosingFigureShader() {
    this.aPosition = this.getAttribLocation("aPosition");
    this.aNormal = this.getAttribLocation("aNormal");
    this.aTexCoord = this.getAttribLocation("aTexCoord");
    this.uTexture0 = this.getUniformLocation("uTexture0");
    this.uNormalMatrix = this.getUniformLocation("uNormalMatrix");
    this.uAlpha = this.getUniformLocation("uAlpha");
  }
  setBuffers(model, images) {
    if (this.isDisabled()) {
      return;
    }
    const gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer);
    this.enableVertexAttributes();
    this.resetVertexAttribPointerOffset();
    this.vertexAttribPointer(this.aPosition, 3, gl.FLOAT, model.vertexDataStride);
    this.vertexAttribPointer(this.aNormal, 3, gl.FLOAT, model.vertexDataStride);
    this.vertexAttribPointer(this.aTexCoord, 2, gl.FLOAT, model.vertexDataStride);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, images[0].texture);
    gl.uniform1i(this.uTexture0, 0);
  }
  setNormalMatrix(matrix) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.uniformMatrix4fv(this.uNormalMatrix, false, matrix);
  }
  setAlpha(alpha) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.uniform1f(this.uAlpha, alpha);
  }
}
class DepthShader extends PosingFigureShader {
  constructor() {
    super(...arguments);
    this.uMaxDepth = null;
  }
  initializeFragmentSourceCode() {
    this.fragmentShaderSourceCode = `

${this.floatPrecisionDefinitionCode}

varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vTexCoord;

uniform sampler2D uTexture0;

uniform float uMaxDepth;
uniform float uAlpha;

void main(void) {

  float z1 = (-vPosition.z) / uMaxDepth * 255.0;
  float z2 = fract(z1) * 255.0;
  float z3 = fract(z2) * 255.0;

  float r = floor(z1) / 255.0;
  float g = floor(z2) / 255.0;
  float b = floor(z3) / 255.0;

  gl_FragColor = vec4(r, g, b , 1.0);
}
`;
  }
  initializeAttributes() {
    this.initializeAttributes_RenderShader();
    this.initializeAttributes_PosingFigureShader();
    this.initializeAttributes_DepthShader();
  }
  initializeAttributes_DepthShader() {
    this.uMaxDepth = this.getUniformLocation("uMaxDepth");
  }
  setMaxDepth(depth) {
    if (this.isDisabled()) {
      return;
    }
    this.gl.uniform1f(this.uMaxDepth, depth);
  }
}
class ImageFileReferenceLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.imageFileReferenceLayer;
    this.imageFilePath = "";
    this.location = vec3.fromValues(0, 0, 0);
    this.rotation = vec3.fromValues(0, 0, 0);
    this.scale = vec3.fromValues(1, 1, 1);
    this.imageFirstLoading = true;
    this.runtime = new ImageFileReferenceLayer_RuntimeProperty();
  }
  static isImageFileReferenceLayer(layer) {
    return layer != null && layer.type == LayerTypeID.imageFileReferenceLayer;
  }
  static isLoaded(layer) {
    return layer.runtime.imageResource.loaded;
  }
}
class ImageFileReferenceLayer_RuntimeProperty extends Layer_RuntimeProperty {
  constructor() {
    super(...arguments);
    this.imageResource = new ImageResource();
    this.adjustingLocation = vec3.fromValues(0, 0, 0);
    this.adjustingRotation = vec3.fromValues(0, 0, 0);
    this.adjustingScale = vec3.fromValues(1, 1, 1);
  }
}
class PosingModel {
  constructor() {
    this.headSphereSize = 0.12;
    this.headTwistSphereSize = 0.18;
    this.headCenterLocation = vec3.fromValues(0, 0, 0);
    this.headTopLocation = vec3.fromValues(0, 0, 0);
    this.headTopToNeckVector = vec3.fromValues(0, 0, 0);
    this.bodySphereSize = 0.3;
    this.bodySphereLocation = vec3.fromValues(0, -0.03, -0.19);
    this.neckSphereLocation = vec3.fromValues(0, -0.03, -0.17);
    this.shoulderSphereLocation = vec3.fromValues(0, -0.03, -0.17);
    this.bodyRotationSphereSize = 0.15;
    this.bodyRotationSphereLocation = vec3.fromValues(0, 0, -0.31);
    this.hipsSphereSize = 0.3;
    this.leftArm1Location = vec3.fromValues(-0.13, 0, -0.05);
    this.rightArm1Location = vec3.fromValues(0.13, 0, -0.05);
    this.leftArm1HeadLocation = vec3.fromValues(0, 0, -0.27);
    this.rightArm1HeadLocation = vec3.fromValues(0, 0, -0.27);
    this.leftArm2HeadLocation = vec3.fromValues(0, 0, -0.27);
    this.rightArm2HeadLocation = vec3.fromValues(0, 0, -0.27);
    this.leftLeg1Location = vec3.fromValues(-0.11, 0, -0.46);
    this.rightLeg1Location = vec3.fromValues(0.11, 0, -0.46);
    this.leftLeg1HeadLocation = vec3.fromValues(0, 0, -0.39);
    this.rightLeg1HeadLocation = vec3.fromValues(0, 0, -0.39);
    this.leftLeg2HeadLocation = vec3.fromValues(0, 0, -0.39);
    this.rightLeg2HeadLocation = vec3.fromValues(0, 0, -0.39);
    this.chestModelConvertMatrix = mat4.create();
    this.hipsModelConvertMatrix = mat4.create();
  }
}
var InputSideID = /* @__PURE__ */ ((InputSideID2) => {
  InputSideID2[InputSideID2["none"] = 0] = "none";
  InputSideID2[InputSideID2["front"] = 1] = "front";
  InputSideID2[InputSideID2["back"] = 2] = "back";
  return InputSideID2;
})(InputSideID || {});
class PosingInputData {
  constructor() {
    this.inputDone = false;
    this.parentMatrix = null;
    this.hitTestSphereRadius = 0;
  }
}
class HeadLocationInputData extends PosingInputData {
  constructor() {
    super(...arguments);
    this.center = vec3.fromValues(0, 0, 0);
    this.radius = 0;
    this.editLine = null;
    this.matrix = mat4.create();
    this.headMatrix = mat4.create();
    this.bodyRootMatrix = mat4.create();
  }
}
class DirectionInputData extends PosingInputData {
  constructor() {
    super(...arguments);
    this.inputSideID = 1;
    this.inputLocation = vec3.fromValues(0, 0, 0);
    this.inputLocation2D = vec3.fromValues(0, 0, 0);
    this.directionInputDone = false;
    this.rollInputDone = false;
    this.rollInputLocation = vec3.fromValues(0, 0, 0);
    this.rollInputAngle = 0;
    this.matrix = mat4.create();
  }
}
class HeadTwistInputData extends DirectionInputData {
  constructor() {
    super(...arguments);
    this.tempInputLocation = vec3.fromValues(0, 0, 0);
  }
}
class BodyRotationInputData extends DirectionInputData {
  constructor() {
    super(...arguments);
    this.inputSideID = 1;
    this.inputLocation = vec3.fromValues(0, 0, 0);
    this.matrix = mat4.create();
  }
}
class JointPartInputData extends DirectionInputData {
  constructor() {
    super(...arguments);
    this.childJointRootMatrix = mat4.create();
  }
}
class PosingData {
  constructor() {
    this.real3DViewHalfWidth = 1;
    this.real3DViewMeterPerPixel = 1;
    this.real3DModelDistance = 2;
    this.rootMatrix = mat4.create();
    this.headMatrix = mat4.create();
    this.headTopMatrix = mat4.create();
    this.neckSphereMatrix = mat4.create();
    this.chestRootMatrix = mat4.create();
    this.chestMatrix = mat4.create();
    this.shoulderRootMatrix = mat4.create();
    this.hipsRootMatrix = mat4.create();
    this.hipsMatrix = mat4.create();
    this.bodyRotationCenterMatrix = mat4.create();
    this.leftArm1RootMatrix = mat4.create();
    this.rightArm1RootMatrix = mat4.create();
    this.leftLeg1RootMatrix = mat4.create();
    this.rightLeg1RootMatrix = mat4.create();
    this.headLocationInputData = new HeadLocationInputData();
    this.headRotationInputData = new JointPartInputData();
    this.headTwistInputData = new HeadTwistInputData();
    this.bodyLocationInputData = new JointPartInputData();
    this.bodyRotationInputData = new BodyRotationInputData();
    this.hipsLocationInputData = new JointPartInputData();
    this.leftShoulderLocationInputData = new JointPartInputData();
    this.rightShoulderLocationInputData = new JointPartInputData();
    this.leftArm1LocationInputData = new JointPartInputData();
    this.leftArm2LocationInputData = new JointPartInputData();
    this.rightArm1LocationInputData = new JointPartInputData();
    this.rightArm2LocationInputData = new JointPartInputData();
    this.leftLeg1LocationInputData = new JointPartInputData();
    this.leftLeg2LocationInputData = new JointPartInputData();
    this.rightLeg1LocationInputData = new JointPartInputData();
    this.rightLeg2LocationInputData = new JointPartInputData();
  }
}
class JointPartDrawingUnit {
  constructor() {
    this.name = "";
    this.targetData = null;
    this.dependentInputData = null;
    this.drawModel = true;
    this.modelResource = null;
    this.modelConvertMatrix = null;
    this.visualModelAlpha = 1;
    this.hitTestSphereAlpha = 0.5;
  }
}
class PosingLayer_RuntimeProperty extends Layer_RuntimeProperty {
  constructor() {
    super(...arguments);
    this.drawingUnits = null;
  }
}
class PosingLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.posingLayer;
    this.posingModel = new PosingModel();
    this.posingData = new PosingData();
    this.runtime = new PosingLayer_RuntimeProperty();
  }
  static isPosingLayer(layer) {
    return layer != null && layer.type == LayerTypeID.posingLayer;
  }
}
class VectorLayerReferenceLayer_RuntimeProperty extends VectorLayer_RuntimeProperty {
  constructor() {
    super(...arguments);
    this.referenceLayer = null;
  }
}
class VectorLayerReferenceLayer extends VectorLayer {
  constructor() {
    super(...arguments);
    this.type = LayerTypeID.vectorLayerReferenceLayer;
    this.runtime = new VectorLayerReferenceLayer_RuntimeProperty();
  }
  static isVectorLayerReferenceLayer(layer) {
    return layer != null && layer.type == LayerTypeID.vectorLayerReferenceLayer;
  }
}
var PostUpdateSituationTypeID = /* @__PURE__ */ ((PostUpdateSituationTypeID2) => {
  PostUpdateSituationTypeID2[PostUpdateSituationTypeID2["changesKeepingObjectShapes"] = 0] = "changesKeepingObjectShapes";
  PostUpdateSituationTypeID2[PostUpdateSituationTypeID2["changesObjectShapes"] = 1] = "changesObjectShapes";
  PostUpdateSituationTypeID2[PostUpdateSituationTypeID2["addObjects"] = 2] = "addObjects";
  PostUpdateSituationTypeID2[PostUpdateSituationTypeID2["deleteObjects"] = 3] = "deleteObjects";
  return PostUpdateSituationTypeID2;
})(PostUpdateSituationTypeID || {});
class DefferedProcessFlagging {
  constructor() {
    this.postUpdate_geometrys = [];
    this.postUpdate_strokeGroups = [];
    this.postUpdate_layers = [];
    this.lazyUpdate_strokeGroups = [];
    this.lazyUpdate_layers = [];
  }
  addGeometryForDeletingEmpties(target_geometry) {
    this.postUpdate_geometrys.push(target_geometry);
  }
  addGroup(target_layer, target_strokeGroup, postUpdateStrategyType) {
    if (postUpdateStrategyType != 0) {
      this.postUpdate_strokeGroups.push(target_strokeGroup);
    }
    this.lazyUpdate_strokeGroups.push(target_strokeGroup);
    this.addLayer(target_layer);
  }
  addLayer(target_layer) {
    if (this.lazyUpdate_layers.find((ly) => ly == target_layer)) {
      return;
    }
    this.lazyUpdate_layers.push(target_layer);
    if (VectorLayer.isVectorStrokeLayer(target_layer)) {
      for (const child of target_layer.runtime.parentLayer.childLayers) {
        if (VectorLayer.isPointBrushFillLayer(child)) {
          this.postUpdate_layers.push(child);
        } else if (AutoFillLayer.isAutoFillLayer(child)) {
          this.lazyUpdate_layers.push(child);
        }
      }
    }
  }
  setFlags(ctx) {
    if (this.postUpdate_geometrys.length > 0) {
      for (const geometry of this.postUpdate_geometrys) {
        VectorLayerGeometry.setPostUpdateNeeded(geometry);
      }
      ctx.main.setPostUpdateNeeded();
    }
    if (this.postUpdate_layers.length > 0) {
      for (const layer of this.postUpdate_layers) {
        Layer.setPostUpdateNeeded(layer);
        ctx.main.setRedrawDrawPathForLayer(layer);
      }
      ctx.main.setPostUpdateNeeded();
    }
    if (this.postUpdate_strokeGroups.length > 0) {
      for (const group of this.postUpdate_strokeGroups) {
        VectorStrokeGroup.setPostUpdateNeeded(group);
      }
      ctx.main.setPostUpdateNeeded();
    }
    if (this.lazyUpdate_strokeGroups.length > 0) {
      for (const group of this.lazyUpdate_strokeGroups) {
        VectorStrokeGroup.setLazyUpdateNeeded(group);
      }
      ctx.main.setLazyUpdateNeeded();
    }
    if (this.lazyUpdate_layers.length > 0) {
      for (const layer of this.lazyUpdate_layers) {
        Layer.setLazyUpdateNeeded(layer);
        ctx.main.setRedrawDrawPathForLayer(layer);
      }
      ctx.main.setLazyUpdateNeeded();
    }
  }
}
class LazyUpdateState {
  constructor() {
    this.needsStartingLazyUpdate = false;
    this.processedIndex = -1;
    this.lastResetTime = 0;
    this.limitTime = 100;
    this.partialProcessMaxTime = 100;
    this.waitTime = 500;
    this.isLazyDrawingFinished = false;
    this.isFirstTime = true;
    this.isFinished = false;
    this.isRendered = false;
    this.processStartTime = 0;
  }
  resetLazyUpdate() {
    this.needsStartingLazyUpdate = false;
    this.isFirstTime = true;
    this.isFinished = false;
    this.isRendered = false;
  }
  setLazyUpdate() {
    this.needsStartingLazyUpdate = true;
    this.isFinished = false;
  }
  startLazyCalculation() {
    this.needsStartingLazyUpdate = false;
    this.processedIndex = -1;
    this.lastResetTime = Platform.getCurrentTime();
    this.isLazyDrawingFinished = false;
    this.isFirstTime = true;
    this.isFinished = false;
    this.isRendered = false;
  }
  finishLazyUpdate() {
    this.isFinished = true;
    this.isRendered = true;
  }
  isLazyDrawBigining() {
    return this.processedIndex == -1;
  }
  isLazyUpdateWaiting() {
    return !this.isFinished && this.lastResetTime + this.waitTime > Platform.getCurrentTime();
  }
  startPartialProcess() {
    this.processStartTime = Platform.getCurrentTime();
  }
  isOverPartialProcessMaxTime() {
    const currentTime = Platform.getCurrentTime();
    return currentTime - this.processStartTime >= this.partialProcessMaxTime;
  }
  finishLazyDrawing() {
    this.isLazyDrawingFinished = true;
  }
}
class LayerHighlightingLogic {
  constructor() {
    this.viewLayerList = null;
    this.selectCurrentLayerAnimationStarted = false;
    this.selectCurrentLayerAnimationLayer = null;
    this.selectCurrentLayerAnimationTime = 0;
    this.selectCurrentLayerAnimationTimeMax = 0.4;
  }
  link(viewLayerList) {
    this.viewLayerList = viewLayerList;
  }
  startShowingLayerItem(item, ctx) {
    if (item == null) {
      return;
    }
    this.selectCurrentLayerAnimationLayer = item.layer;
    this.selectCurrentLayerAnimationTime = this.selectCurrentLayerAnimationTimeMax;
    this.selectCurrentLayerAnimationStarted = false;
    ctx.setRedrawMainWindowEditorWindow();
    ctx.setRedrawWebGLWindow();
    ctx.setRedrawLayerWindow();
    ctx.setRedrawRibbonUI();
  }
  startShowingCurrentLayer(docContext, ctx) {
    const item = this.viewLayerList.findItemForLayer(docContext, docContext.currentLayer);
    this.startShowingLayerItem(item, ctx);
  }
  processHighlightingAnimation(elapsedTime, ctx) {
    if (this.selectCurrentLayerAnimationTime == 0) {
      return;
    }
    if (this.selectCurrentLayerAnimationStarted == false) {
      this.selectCurrentLayerAnimationStarted = true;
      return;
    }
    this.selectCurrentLayerAnimationTime -= elapsedTime / 1e3;
    if (this.selectCurrentLayerAnimationTime <= 0) {
      this.selectCurrentLayerAnimationTime = 0;
      ctx.setRedrawMainWindow();
      ctx.setRedrawWebGLWindow();
    }
  }
  isAnimatingLayer(layer) {
    return layer == this.selectCurrentLayerAnimationLayer;
  }
  isAnimating() {
    return this.selectCurrentLayerAnimationTime > 0;
  }
}
var ViewPointerPressedState = /* @__PURE__ */ ((ViewPointerPressedState2) => {
  ViewPointerPressedState2[ViewPointerPressedState2["released"] = 0] = "released";
  ViewPointerPressedState2[ViewPointerPressedState2["pressed"] = 1] = "pressed";
  return ViewPointerPressedState2;
})(ViewPointerPressedState || {});
class ViewPointerEventPointer {
  constructor() {
    this.identifier = -1;
    this.ageCount = 0;
    this.pressed = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.currentLocation = vec3.fromValues(0, 0, 0);
    this.pressure = 0;
    this.dragging = new ViewPointerEventDragging();
  }
  isSamePointer(e) {
    return this.identifier == e.pointerId;
  }
  isFree() {
    return !this.isActive();
  }
  isActive() {
    return this.identifier != -1;
  }
  isPressed() {
    return this.pressed != 0;
  }
  isActivePressed() {
    return this.isActive() && this.isPressed();
  }
  setActive(e) {
    this.identifier = e.pointerId;
    this.pressed = 0;
    this.ageCount = 0;
  }
  setFree() {
    this.identifier = -1;
    this.pressed = 0;
    this.ageCount = 0;
  }
  startDragging(wnd, velocityScale) {
    this.dragging.start(wnd, this.offsetX, this.offsetY, velocityScale);
  }
}
class ViewPointerEventDragging {
  constructor() {
    this.dragBeforeTransformMatrix = mat4.create();
    this.mouseDownOffset = vec3.fromValues(0, 0, 0);
    this.mouseDownLocation = vec3.fromValues(0, 0, 0);
    this.currentLocation = vec3.fromValues(0, 0, 0);
    this.mouseOffset = vec3.fromValues(0, 0, 0);
    this.mouseMovedOffset = vec3.fromValues(0, 0, 0);
    this.mouseMovedVector = vec3.fromValues(0, 0, 0);
    this.velocityScale = 1;
    this.tempVec3 = vec3.create();
  }
  start(wnd, offsetX, offsetY, velocityScale) {
    vec3.set(this.mouseOffset, offsetX, offsetY, 0);
    vec3.copy(this.mouseDownOffset, this.mouseOffset);
    mat4.copy(this.dragBeforeTransformMatrix, wnd.invView2DMatrix);
    vec3.set(this.tempVec3, offsetX, offsetY, 0);
    vec3.transformMat4(this.mouseDownLocation, this.tempVec3, this.dragBeforeTransformMatrix);
    vec3.set(this.mouseMovedOffset, 0, 0, 0);
    vec3.set(this.mouseMovedVector, 0, 0, 0);
    this.velocityScale = velocityScale;
  }
  move(offsetX, offsetY) {
    vec3.set(this.mouseOffset, offsetX, offsetY, 0);
    vec3.subtract(this.mouseMovedOffset, this.mouseOffset, this.mouseDownOffset);
    vec3.scale(this.mouseMovedOffset, this.mouseMovedOffset, this.velocityScale);
    vec3.transformMat4(this.currentLocation, this.mouseOffset, this.dragBeforeTransformMatrix);
    vec3.subtract(this.mouseMovedVector, this.mouseDownLocation, this.currentLocation);
    vec3.scale(this.mouseMovedVector, this.mouseMovedVector, this.velocityScale);
  }
  isMoved() {
    return vec3.length(this.mouseMovedOffset) > 0;
  }
}
class ViewPointerEvent {
  constructor(wnd) {
    this.window = null;
    this.location = vec3.fromValues(0, 0, 0);
    this.offsetX = 0;
    this.offsetY = 0;
    this.button = 0;
    this.buttons = 0;
    this.wheelDelta = 0;
    this.isPointerMoved = false;
    this.isMouseDragging = false;
    this.mouseDownLocation = vec3.fromValues(0, 0, 0);
    this.mouseMovedVector = vec3.fromValues(0, 0, 0);
    this.clickCount = 0;
    this.lastClickedOffset = vec3.fromValues(0, 0, 0);
    this.mouseDownOffset = vec3.fromValues(0, 0, 0);
    this.mouseMovedOffset = vec3.fromValues(0, 0, 0);
    this.pointers = [
      new ViewPointerEventPointer(),
      new ViewPointerEventPointer(),
      new ViewPointerEventPointer()
    ];
    this.activePointers = [];
    this.tempVec3 = vec3.fromValues(0, 0, 0);
    this.window = wnd;
  }
  isLeftButtonPressing() {
    return (this.buttons & 1) != 0;
  }
  isRightButtonPressing() {
    return (this.buttons & 2) != 0;
  }
  isCenterButtonPressing() {
    return (this.buttons & 4) != 0;
  }
  isLeftButtonReleased() {
    return !this.isLeftButtonPressing();
  }
  isRightButtonReleased() {
    return !this.isRightButtonPressing();
  }
  isCenterButtonReleased() {
    return !this.isCenterButtonPressing();
  }
}
class PointerInputWindow extends CanvasWindow {
  constructor() {
    super(...arguments);
    this.pointerEvent = new ViewPointerEvent(this);
    this.view2DMatrix = mat4.create();
    this.invView2DMatrix = mat4.create();
  }
}
class ViewCoordinateLogic {
  static calculateTransfomredLocation(result, wnd, x2, y2) {
    vec3.set(this.tempVec3, x2, y2, 0);
    vec3.transformMat4(result, this.tempVec3, wnd.invView2DMatrix);
  }
  static calculateTransfomredMouseParams(result, e, wnd) {
    this.calculateTransfomredLocation(
      e.location,
      wnd,
      e.offsetX,
      e.offsetY
    );
    vec3.copy(result, e.location);
  }
  static calculateTransfomredTouchParams(result, e, wnd) {
    this.calculateTransfomredLocation(
      result,
      wnd,
      e.currentLocation[0],
      e.currentLocation[1]
    );
  }
}
ViewCoordinateLogic.tempVec3 = vec3.create();
class PointerInputLogic {
  static processSinglePointerEvent(wnd, e, ctx, buttonDown, buttonUp) {
    const viewPointerEvent = wnd.pointerEvent;
    if (document.activeElement.nodeName == "INPUT") {
      document.activeElement.blur();
    }
    viewPointerEvent.button = e.button;
    viewPointerEvent.buttons = e.buttons;
    if (buttonUp) {
      viewPointerEvent.button = -1;
      viewPointerEvent.buttons = 0;
    }
    viewPointerEvent.offsetX = e.offsetX * wnd.devicePixelRatio;
    viewPointerEvent.offsetY = e.offsetY * wnd.devicePixelRatio;
    ViewCoordinateLogic.calculateTransfomredMouseParams(viewPointerEvent.location, viewPointerEvent, wnd);
    vec3.copy(ctx.mouseCursorLocation, viewPointerEvent.location);
    if (buttonDown) {
      viewPointerEvent.isPointerMoved = false;
    }
    if (buttonDown) {
      vec3.copy(viewPointerEvent.mouseDownLocation, viewPointerEvent.location);
    }
    if (!buttonDown && !buttonUp && !viewPointerEvent.isPointerMoved) {
      const distance = vec3.distance(viewPointerEvent.location, viewPointerEvent.mouseDownLocation);
      const threshold = wnd.getViewScaledLength(ctx.dragStartThresholdDistance);
      if (distance >= threshold) {
        viewPointerEvent.isPointerMoved = true;
      }
    }
  }
  static processMultiPointerEvent(wnd, e, buttonDown, buttonUp) {
    let isPointerChanged = false;
    let lastUsed_Pointer = null;
    for (const pointer of wnd.pointerEvent.pointers) {
      if (pointer.isSamePointer(e)) {
        lastUsed_Pointer = pointer;
        break;
      }
    }
    if (buttonUp) {
      if (lastUsed_Pointer != null) {
        lastUsed_Pointer.setFree();
        isPointerChanged = true;
      }
    } else {
      let target_Pointer = lastUsed_Pointer;
      if (target_Pointer == null) {
        let free_Pointer = wnd.pointerEvent.pointers.find((pointer) => pointer.isFree());
        if (!free_Pointer) {
          free_Pointer = wnd.pointerEvent.pointers.at(-1);
        }
        if (free_Pointer) {
          target_Pointer = free_Pointer;
          target_Pointer.setActive(e);
          isPointerChanged = true;
        }
      }
      if (target_Pointer != null) {
        target_Pointer.offsetX = wnd.pointerEvent.offsetX;
        target_Pointer.offsetY = wnd.pointerEvent.offsetY;
        vec3.copy(target_Pointer.currentLocation, wnd.pointerEvent.location);
        target_Pointer.pressure = e.pressure;
        const pressedBefore = target_Pointer.pressed;
        if (buttonDown) {
          target_Pointer.pressed = ViewPointerPressedState.pressed;
        } else if (buttonUp) {
          target_Pointer.pressed = ViewPointerPressedState.released;
        }
        if (pressedBefore != target_Pointer.pressed) {
          isPointerChanged = true;
        }
      }
    }
    if (isPointerChanged) {
      this.updatePointerStates(wnd.pointerEvent);
    }
  }
  static processMultiPointerLeaveEvent(wnd, e) {
    const target_Pointer = wnd.pointerEvent.pointers.find((pointer) => pointer.isSamePointer(e));
    if (!target_Pointer) {
      return;
    }
    target_Pointer.setFree();
    this.updatePointerStates(wnd.pointerEvent);
  }
  static cancelAllPointers(viewPointerEvent) {
    viewPointerEvent.pointers.forEach((pointer) => pointer.setFree());
    this.updatePointerStates(viewPointerEvent);
  }
  static hasActivePointer(pointerId, viewPointerEvent) {
    return viewPointerEvent.activePointers.findIndex(
      (pointer) => pointer.identifier == pointerId
    ) != -1;
  }
  static updatePointerStates(viewPointerEvent) {
    for (const pointer of viewPointerEvent.pointers) {
      pointer.ageCount++;
    }
    viewPointerEvent.pointers = viewPointerEvent.pointers.sort((a, b) => {
      return a.ageCount - b.ageCount;
    });
    viewPointerEvent.activePointers = viewPointerEvent.pointers.filter((pointer) => pointer.isActivePressed());
  }
  static getFirstActivePointer(viewPointerEvent) {
    var _a;
    let foundPointer = null;
    if (viewPointerEvent.activePointers.length > 0) {
      foundPointer = viewPointerEvent.activePointers[0];
    } else {
      foundPointer = (_a = viewPointerEvent.pointers.find((ptr) => ptr.isActive())) != null ? _a : null;
    }
    return foundPointer;
  }
  static getWheelInfo(viewPointerEvent, e) {
    let wheelDelta = 0;
    if ("wheelDelta" in e) {
      wheelDelta = e["wheelDelta"];
    } else if ("deltaY" in e) {
      wheelDelta = e["deltaY"];
    } else if ("wheelDeltaY" in e) {
      wheelDelta = e["wheelDeltaY"];
    }
    if (wheelDelta > 0) {
      wheelDelta = 1;
    } else if (wheelDelta < 0) {
      wheelDelta = -1;
    }
    viewPointerEvent.wheelDelta = wheelDelta;
  }
  static handleDoubleClick(viewPointerEvent, offsetX, offsetY) {
    if (viewPointerEvent.clickCount == 0) {
      viewPointerEvent.clickCount++;
      viewPointerEvent.lastClickedOffset[0] = offsetX;
      viewPointerEvent.lastClickedOffset[1] = offsetY;
      setTimeout(() => {
        viewPointerEvent.clickCount = 0;
      }, 350);
      return false;
    } else {
      viewPointerEvent.clickCount = 0;
      if (Math.pow(offsetX - viewPointerEvent.lastClickedOffset[0], 2) + Math.pow(offsetY - viewPointerEvent.lastClickedOffset[1], 2) < 9) {
        return true;
      } else {
        return false;
      }
    }
  }
  static startMouseDragging(viewPointerEvent) {
    viewPointerEvent.isMouseDragging = true;
    vec3.copy(viewPointerEvent.mouseDownLocation, viewPointerEvent.location);
    vec3.set(viewPointerEvent.mouseMovedVector, 0, 0, 0);
    vec3.set(viewPointerEvent.mouseDownOffset, viewPointerEvent.offsetX, viewPointerEvent.offsetY, 0);
    vec3.set(viewPointerEvent.mouseMovedOffset, 0, 0, 0);
  }
  static processMouseDragging(viewPointerEvent) {
    if (!viewPointerEvent.isMouseDragging) {
      return;
    }
    vec3.subtract(viewPointerEvent.mouseMovedVector, viewPointerEvent.mouseDownLocation, viewPointerEvent.location);
    vec3.set(this.tempVec3, viewPointerEvent.offsetX, viewPointerEvent.offsetY, 0);
    vec3.subtract(viewPointerEvent.mouseMovedOffset, viewPointerEvent.mouseDownOffset, this.tempVec3);
  }
  static endMouseDragging(viewPointerEvent) {
    viewPointerEvent.isMouseDragging = false;
  }
  static isPointerMovedOnDevice(viewPointerEvent, e) {
    return viewPointerEvent.offsetX != e.offsetX * viewPointerEvent.window.devicePixelRatio || viewPointerEvent.offsetY != e.offsetY * viewPointerEvent.window.devicePixelRatio;
  }
}
PointerInputLogic.tempVec3 = vec3.create();
class ViewKeyframeLayer {
  constructor() {
    this.layer = null;
    this.keyframe = null;
    this.vectorLayerKeyframe = null;
    this.autoFillLayerKeyframe = null;
    this.hasActualFrame = false;
  }
  hasKeyframe() {
    return this.keyframe != null;
  }
  static forEachStrokeGroup(viewKeyframeLayers, loopBodyFunction) {
    for (const viewKeyframeLayer of viewKeyframeLayers) {
      if (viewKeyframeLayer.vectorLayerKeyframe == null) {
        continue;
      }
      for (const unit of viewKeyframeLayer.vectorLayerKeyframe.geometry.units) {
        for (const group of unit.groups) {
          loopBodyFunction(group, viewKeyframeLayer.layer);
        }
      }
    }
  }
  static forEachVectorGeometry(viewKeyframeLayers, loopBodyFunction) {
    for (const viewKeyframeLayer of viewKeyframeLayers) {
      if (viewKeyframeLayer.vectorLayerKeyframe == null) {
        continue;
      }
      loopBodyFunction(viewKeyframeLayer.vectorLayerKeyframe.geometry, viewKeyframeLayer.layer);
    }
  }
}
class ViewKeyframe {
  constructor() {
    this.frame = 0;
    this.layers = [];
  }
  static findViewKeyframe(viewKeyframes, frame) {
    const keyframeIndex = ViewKeyframe.findViewKeyframeIndex(viewKeyframes, frame);
    if (keyframeIndex != -1) {
      return viewKeyframes[keyframeIndex];
    } else {
      return null;
    }
  }
  static findViewKeyframeIndex(viewKeyframes, frame) {
    let resultIndex = 0;
    for (let index2 = 0; index2 < viewKeyframes.length; index2++) {
      if (viewKeyframes[index2].frame > frame) {
        break;
      }
      resultIndex = index2;
    }
    return resultIndex;
  }
  static findViewKeyframeLayerIndex(viewKeyFrame, layer) {
    for (let index2 = 0; index2 < viewKeyFrame.layers.length; index2++) {
      if (viewKeyFrame.layers[index2].layer == layer) {
        return index2;
      }
    }
    return -1;
  }
  static findViewKeyframeLayer(viewKeyFrame, layer) {
    const index2 = this.findViewKeyframeLayerIndex(viewKeyFrame, layer);
    if (index2 != -1) {
      return viewKeyFrame.layers[index2];
    } else {
      return null;
    }
  }
}
class ViewKeyframeLogic {
  collectViewKeyframesToContext(docContext) {
    const layers = LayerLogic.collectLayers(docContext.documentData.rootLayer);
    const viewKeyFrames = this.collectKeyframes(layers);
    this.updateViewKeyframesForLayerReferences(viewKeyFrames, layers);
    docContext.keyframes = viewKeyFrames;
    this.updateContextForViewKeyframeReferences(docContext, docContext.documentData.animationSettingData.currentTimeFrame);
  }
  updateContextForViewKeyframeReferences(docContext, frame) {
    const viewKeyframes = docContext.keyframes;
    const keyframeIndex = ViewKeyframe.findViewKeyframeIndex(viewKeyframes, frame);
    if (keyframeIndex == -1) {
      return false;
    }
    const last_currentViewKeyframe = docContext.currentViewKeyframe;
    const last_previousKeyframe = docContext.previousKeyframe;
    const last_nextKeyframe = docContext.nextKeyframe;
    docContext.currentViewKeyframe = viewKeyframes[keyframeIndex];
    if (keyframeIndex - 1 >= 0) {
      docContext.previousKeyframe = viewKeyframes[keyframeIndex - 1];
    } else {
      docContext.previousKeyframe = null;
    }
    if (keyframeIndex + 1 < viewKeyframes.length) {
      docContext.nextKeyframe = viewKeyframes[keyframeIndex + 1];
    } else {
      docContext.nextKeyframe = null;
    }
    return docContext.currentViewKeyframe != last_currentViewKeyframe || docContext.previousKeyframe != last_previousKeyframe || docContext.nextKeyframe != last_nextKeyframe;
  }
  collectKeyframes(layers) {
    const viewKeyFrames = [];
    const keyframeDictionary = /* @__PURE__ */ new Map();
    for (const layer of layers) {
      if (EditAnimationFrameLogic.isAnimatableLayer(layer)) {
        const animatableLayer = layer;
        this.registerKeyframes(viewKeyFrames, keyframeDictionary, animatableLayer.keyframes);
      }
    }
    const result = viewKeyFrames.sort((a, b) => {
      return a.frame - b.frame;
    });
    return result;
  }
  registerKeyframes(viewKeyFrames, keyframeDictionary, keyframes) {
    for (const keyframe of keyframes) {
      const frameText = keyframe.frame.toString();
      if (!keyframeDictionary.has(frameText)) {
        const viewKeyframe = new ViewKeyframe();
        viewKeyframe.frame = keyframe.frame;
        viewKeyFrames.push(viewKeyframe);
        keyframeDictionary.set(frameText, true);
      }
    }
  }
  updateViewKeyframesForLayerReferences(viewKeyframes, layers) {
    for (const viewKeyframe of viewKeyframes) {
      for (const layer of layers) {
        const keyframeLayer = new ViewKeyframeLayer();
        keyframeLayer.layer = layer;
        if (EditAnimationFrameLogic.isAnimatableLayer(layer)) {
          if (VectorLayer.isVectorLayer(layer)) {
            const vectorLayer = layer;
            let max_KeyFrame = EditAnimationFrameLogic.findLastKeyframeData(vectorLayer.keyframes, viewKeyframe.frame);
            if (max_KeyFrame == null) {
              throw new Error("ERROR-0071:The document contains a layer that has no keyframe.");
            }
            keyframeLayer.keyframe = max_KeyFrame;
            keyframeLayer.vectorLayerKeyframe = max_KeyFrame;
          } else if (AutoFillLayer.isAutoFillLayer(layer)) {
            const autoFillLayer = layer;
            let max_KeyFrame = EditAnimationFrameLogic.findLastKeyframeData(autoFillLayer.keyframes, viewKeyframe.frame);
            if (max_KeyFrame == null) {
              throw new Error("ERROR-0071:The document contains a layer that has no keyframe.");
            }
            keyframeLayer.keyframe = max_KeyFrame;
            keyframeLayer.autoFillLayerKeyframe = max_KeyFrame;
          }
          keyframeLayer.hasActualFrame = keyframeLayer.keyframe.frame == viewKeyframe.frame;
        }
        viewKeyframe.layers.push(keyframeLayer);
      }
    }
  }
  findNextViewKeyframeIndex(docContext, startFrame, searchDirection) {
    const viewKeyframes = docContext.keyframes;
    const startKeyframeIndex = ViewKeyframe.findViewKeyframeIndex(viewKeyframes, startFrame);
    if (startKeyframeIndex == -1) {
      return -1;
    }
    const resultIndex = startKeyframeIndex + searchDirection;
    if (resultIndex < 0) {
      return 0;
    }
    if (resultIndex >= viewKeyframes.length) {
      return viewKeyframes.length - 1;
    }
    return resultIndex;
  }
  findNextViewKeyframeFrame(docContext, startFrame, searchDirection) {
    const keyframeIndex = this.findNextViewKeyframeIndex(docContext, startFrame, searchDirection);
    if (keyframeIndex == -1) {
      return -1;
    } else {
      return docContext.keyframes[keyframeIndex].frame;
    }
  }
  collectVectorViewKeyframeLayersForEdit(currentViewKeyframe, editTargetOnly = false) {
    const editableKeyframeLayers = [];
    if (currentViewKeyframe == null) {
      return editableKeyframeLayers;
    }
    for (const viewKeyframeLayer of currentViewKeyframe.layers) {
      const layer = viewKeyframeLayer.layer;
      if (!VectorLayer.isVectorLayer(layer)) {
        continue;
      }
      if (editTargetOnly && !Layer.isEditTarget(layer)) {
        continue;
      }
      editableKeyframeLayers.push(viewKeyframeLayer);
    }
    return editableKeyframeLayers;
  }
}
class ViewLayerListItem {
  constructor() {
    this.index = -1;
    this.layer = null;
    this.parentLayer = null;
    this.previousItem = null;
    this.nextItem = null;
    this.previousSiblingItem = null;
    this.nextSiblingItem = null;
    this.hierarchyDepth = 0;
    this.isVisible = false;
    this.isCurrentLayer = false;
    this.isSelected = false;
    this.scrollIntoView = () => {
    };
  }
}
class ViewLayerListLogic {
  collectItemsToContext(docContext) {
    docContext.layerListItems = [];
    this.collectItemsRecursive(docContext.layerListItems, docContext.documentData.rootLayer, 0);
    let previousItem = null;
    for (const item of docContext.layerListItems) {
      item.index = item.layer.hashID;
      item.previousItem = previousItem;
      if (previousItem != null) {
        previousItem.nextItem = item;
      }
      previousItem = item;
    }
    for (const item of docContext.layerListItems) {
      let nextItem = item.nextItem;
      while (nextItem != null) {
        if (nextItem.hierarchyDepth <= item.hierarchyDepth) {
          item.nextSiblingItem = nextItem;
          break;
        }
        nextItem = nextItem.nextItem;
      }
    }
  }
  collectItemsRecursive(result, parentLayer, currentDepth) {
    let siblingItem = null;
    for (const layer of parentLayer.childLayers) {
      const item = new ViewLayerListItem();
      item.layer = layer;
      item.parentLayer = parentLayer;
      item.hierarchyDepth = currentDepth;
      item.previousSiblingItem = siblingItem;
      if (siblingItem != null) {
        siblingItem.nextSiblingItem = item;
      }
      result.push(item);
      if (layer.isListExpanded && layer.childLayers.length > 0) {
        this.collectItemsRecursive(result, layer, currentDepth + 1);
      }
      siblingItem = item;
    }
  }
  findCurrentItemIndex(docContext, currentLayer) {
    for (let index2 = 0; index2 < docContext.layerListItems.length; index2++) {
      const item = docContext.layerListItems[index2];
      if (item.layer == currentLayer) {
        return index2;
      }
    }
    return -1;
  }
  findItemForLayer(docContext, currentLayer) {
    const index2 = this.findCurrentItemIndex(docContext, currentLayer);
    if (index2 != -1) {
      const item = docContext.layerListItems[index2];
      return item;
    }
    return null;
  }
  collectPosingLayerOptions(docContext) {
    const options = [];
    options.push({
      index: 0,
      label: "",
      data: null
    });
    for (const [index2, layerWindowItem] of docContext.layerListItems.entries()) {
      if (PosingLayer.isPosingLayer(layerWindowItem.layer)) {
        options.push({
          index: index2,
          label: layerWindowItem.layer.name,
          data: layerWindowItem.layer
        });
      }
    }
    return options;
  }
}
var ViewOperationMode = /* @__PURE__ */ ((ViewOperationMode2) => {
  ViewOperationMode2[ViewOperationMode2["none"] = 0] = "none";
  ViewOperationMode2[ViewOperationMode2["pan"] = 1] = "pan";
  ViewOperationMode2[ViewOperationMode2["rotate"] = 2] = "rotate";
  ViewOperationMode2[ViewOperationMode2["zoom"] = 3] = "zoom";
  return ViewOperationMode2;
})(ViewOperationMode || {});
class ViewOperation {
  constructor() {
    this.homeViewLocation = vec3.fromValues(0, 0, 0);
    this.lastViewLocation = vec3.fromValues(0, 0, 0);
    this.isViewLocationMoved = false;
    this.lastViewScale = 0;
    this.lastViewRotation = 0;
    this.viewOperationMode = 0;
    this.velocityScale = 1;
    this.clickedArea = null;
    this.moveBeforeViewLocation = vec3.create();
    this.moveBeforeViewRotation = 0;
    this.moveBeforeViewScale = 0;
    this.first_Pointer = null;
    this.second_Pointer = null;
    this.tempVec3 = vec3.create();
    this.direction = vec3.create();
    this.difference = vec3.create();
  }
  startViewOperation(mode, wnd, area, ctx, velocityScale = 1) {
    const e = wnd.pointerEvent;
    const pointer = PointerInputLogic.getFirstActivePointer(e);
    if (pointer == null) {
      return;
    }
    this.viewOperationMode = mode;
    this.velocityScale = velocityScale;
    this.first_Pointer = pointer;
    this.second_Pointer = null;
    if (area != null) {
      this.clickedArea = area;
      this.clickedArea.hover = true;
    }
    this.copyBeforeViewState(wnd);
    if (mode != 1) {
      this.copyLastViewLocation(true, wnd);
    }
    this.first_Pointer.startDragging(wnd, velocityScale);
    ctx.setRedrawEditorWindow();
  }
  endViewOperation(wnd, spaceKeyUp, ctx) {
    if (this.first_Pointer == null) {
      return false;
    }
    ctx.setRedrawEditorWindow();
    if (wnd.pointerEvent.activePointers.length == 1) {
      this.startViewOperation(
        this.viewOperationMode,
        wnd,
        this.clickedArea,
        ctx,
        this.velocityScale
      );
      return true;
    }
    if (wnd.pointerEvent.activePointers.length == 0 || spaceKeyUp) {
      PointerInputLogic.cancelAllPointers(wnd.pointerEvent);
      this.viewOperationMode = 0;
      if (this.clickedArea != null) {
        this.clickedArea.hover = false;
      }
    }
    PointerInputLogic.endMouseDragging(wnd.pointerEvent);
    return this.first_Pointer.dragging.isMoved();
  }
  pointerDownAdditional(wnd) {
    const e = wnd.pointerEvent;
    if (e.activePointers.length < 2) {
      return;
    }
    this.copyBeforeViewState(wnd);
    this.second_Pointer = e.activePointers[0];
    this.second_Pointer.startDragging(wnd, 1);
  }
  isViewOperationRunning() {
    return this.viewOperationMode != 0;
  }
  getActivePointer() {
    if (this.second_Pointer != null && this.second_Pointer.isPressed()) {
      return this.second_Pointer;
    } else {
      return this.first_Pointer;
    }
  }
  processViewOperation(wnd, e, ctx) {
    if (this.viewOperationMode == 0) {
      return false;
    }
    const pointer = this.getActivePointer();
    if (pointer == null) {
      return false;
    }
    pointer.dragging.move(pointer.offsetX, pointer.offsetY);
    switch (this.viewOperationMode) {
      case 1:
        this.processPan(wnd, e, ctx);
        break;
      case 2:
        this.processRotate(wnd, e, ctx);
        break;
      case 3:
        this.processScale(wnd, e, ctx);
        break;
    }
    return pointer.dragging.isMoved();
  }
  processPan(wnd, e, ctx) {
    const pointer = this.getActivePointer();
    if (pointer == null) {
      return;
    }
    vec3.add(wnd.viewLocation, this.moveBeforeViewLocation, pointer.dragging.mouseMovedVector);
    if (!this.isViewLocationMoved) {
      vec3.copy(this.homeViewLocation, wnd.viewLocation);
    } else {
      vec3.copy(this.lastViewLocation, wnd.viewLocation);
    }
    ctx.setRedrawMainWindowEditorWindow();
    ctx.setRedrawWebGLWindow();
  }
  processRotate(wnd, e, ctx) {
    const pointer = this.getActivePointer();
    if (pointer == null) {
      return;
    }
    vec3.subtract(this.direction, pointer.dragging.mouseDownLocation, wnd.viewLocation);
    const initialAngle = Math.atan2(this.direction[1], this.direction[0]);
    vec3.subtract(this.direction, pointer.dragging.currentLocation, wnd.viewLocation);
    const currentAngle = Math.atan2(this.direction[1], this.direction[0]);
    let movedAngle = currentAngle - initialAngle;
    if (movedAngle >= Math.PI) {
      movedAngle -= Math.PI * 2;
    }
    if (movedAngle <= -Math.PI) {
      movedAngle += Math.PI * 2;
    }
    wnd.viewRotation = this.moveBeforeViewRotation + movedAngle * 180 / Math.PI;
    if (ctx.isCtrlKeyPressing()) {
      const flooring = 90 / 4;
      wnd.viewRotation = Math.floor(wnd.viewRotation / flooring) * flooring;
    }
    wnd.fixViewRotation();
    ctx.setRedrawMainWindowEditorWindow();
  }
  processScale(wnd, e, ctx) {
    const pointer = this.getActivePointer();
    if (pointer == null) {
      return;
    }
    if (pointer == this.first_Pointer) {
      const range = Math.min(wnd.width, wnd.height) / 2;
      const scaling = (pointer.dragging.mouseMovedOffset[0] - pointer.dragging.mouseMovedOffset[1]) / range;
      wnd.viewScale = this.moveBeforeViewScale * (1 - scaling);
    } else {
      vec3.subtract(this.difference, pointer.dragging.mouseDownLocation, wnd.viewLocation);
      const initialScale = vec3.length(this.difference);
      vec3.subtract(this.difference, pointer.dragging.currentLocation, wnd.viewLocation);
      const currentScale = vec3.length(this.difference);
      if (initialScale > 0) {
        wnd.viewScale = this.moveBeforeViewScale * (currentScale / initialScale);
      }
    }
    wnd.fixViewScale();
    ctx.setRedrawMainWindowEditorWindow();
  }
  addViewRotation(quantity, clockwise, wnd, ctx) {
    let rot = quantity;
    if (clockwise) {
      rot = -rot;
    }
    if (wnd.mirrorX) {
      rot = -rot;
    }
    wnd.viewRotation += rot;
    wnd.fixViewRotation();
    ctx.setRedrawMainWindowEditorWindow();
  }
  addViewScale(quantity, wnd, ctx) {
    this.copyLastViewLocation(true, wnd);
    wnd.addViewScale(quantity);
    ctx.setRedrawMainWindowEditorWindow();
  }
  toggletHome(wnd, rest, ctx) {
    if (rest) {
      this.setViewToDefaultState(wnd, ctx.documentData.defaultViewScale);
    } else if (this.isViewLocationMoved) {
      this.setViewToHomeLocation(wnd, ctx.documentData.defaultViewScale);
    } else {
      this.setViewToLastLocation(wnd);
    }
    ctx.setRedrawMainWindowEditorWindow();
  }
  setViewToDefaultState(wnd, defaultViewScale) {
    wnd.viewLocation[0] = 0;
    wnd.viewLocation[1] = 0;
    vec3.copy(this.homeViewLocation, wnd.viewLocation);
    wnd.viewScale = defaultViewScale;
    wnd.viewRotation = 0;
    wnd.mirrorX = false;
    wnd.mirrorY = false;
    this.isViewLocationMoved = false;
  }
  setViewToHomeLocation(wnd, defaultViewScale) {
    vec3.copy(wnd.viewLocation, this.homeViewLocation);
    wnd.viewScale = defaultViewScale;
    wnd.viewRotation = 0;
    this.isViewLocationMoved = false;
  }
  setViewToLastLocation(wnd) {
    vec3.copy(wnd.viewLocation, this.lastViewLocation);
    wnd.viewScale = this.lastViewScale;
    wnd.viewRotation = this.lastViewRotation;
    this.isViewLocationMoved = true;
  }
  copyBeforeViewState(wnd) {
    vec3.copy(this.moveBeforeViewLocation, wnd.viewLocation);
    this.moveBeforeViewRotation = wnd.viewRotation;
    this.moveBeforeViewScale = wnd.viewScale;
  }
  copyLastViewLocation(setUpdate, wnd) {
    this.isViewLocationMoved = setUpdate;
    vec3.copy(this.lastViewLocation, wnd.viewLocation);
    this.lastViewScale = wnd.viewScale;
    this.lastViewRotation = wnd.viewRotation;
  }
}
class StrokeSearchResult {
  constructor() {
    this.distance = 0;
    this.compareDistance = 0;
    this.nearestSegmentIndex = 0;
    this.nearestSegmentPoint = null;
    this.isCrossing = false;
    this.crossingLocation = vec3.fromValues(0, 0, 0);
  }
  clear() {
    this.distance = VectorStrokeHitTestLogic.MaxDistance;
    this.compareDistance = VectorStrokeHitTestLogic.MaxDistance;
    this.nearestSegmentIndex = VectorStrokeHitTestLogic.InvalidIndex;
    this.nearestSegmentPoint = null;
    this.isCrossing = false;
    vec3.set(this.crossingLocation, 0, 0, 0);
  }
}
const _VectorStrokeHitTestLogic = class {
  static getNearestSegmentIndex(stroke, location) {
    let minDistance = _VectorStrokeHitTestLogic.MaxDistance;
    let nearestSegmentIndex = _VectorStrokeHitTestLogic.InvalidIndex;
    for (let i = 0; i < stroke.points.length - 1; i++) {
      const target_FromPoint = stroke.points[i];
      const target_ToPoint = stroke.points[i + 1];
      const distance = Logic_Points.pointToLineSegment_SorroundingDistance(
        target_FromPoint.location,
        target_ToPoint.location,
        location
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearestSegmentIndex = i;
      }
    }
    return nearestSegmentIndex;
  }
  static searchSegmentToSegmentNearestIndex(result, segmentFrom, segmentTo, stroke) {
    result.clear();
    for (let i = 0; i <= stroke.points.length - 2; i++) {
      const target_FromPoint = stroke.points[i];
      const target_ToPoint = stroke.points[i + 1];
      const isCrossing = Logic_Points.lineSegmentToLineSegment_CrossPoint(
        result.crossingLocation,
        segmentFrom,
        segmentTo,
        target_FromPoint.location,
        target_ToPoint.location
      );
      if (isCrossing) {
        result.distance = 0;
        result.nearestSegmentIndex = i;
        result.nearestSegmentPoint = null;
        result.isCrossing = true;
        break;
      }
      const isHead = i == 0;
      const isTail = i == stroke.points.length - 2;
      if (!isHead && !isTail) {
        continue;
      }
      const compareDistance = vec3.distance(segmentFrom, target_FromPoint.location) + vec3.distance(segmentTo, target_FromPoint.location);
      if (compareDistance >= result.compareDistance) {
        continue;
      }
      let distance = _VectorStrokeHitTestLogic.MaxDistance;
      if (isHead) {
        const point_Distance = Logic_Points.pointToLineSegment_SorroundingDistance(
          segmentFrom,
          segmentTo,
          target_FromPoint.location
        );
        if (point_Distance < distance) {
          distance = point_Distance;
          result.nearestSegmentPoint = target_FromPoint;
        }
      }
      if (isTail) {
        const point_Distance = Logic_Points.pointToLineSegment_SorroundingDistance(
          segmentFrom,
          segmentTo,
          target_ToPoint.location
        );
        if (point_Distance < distance) {
          distance = point_Distance;
          result.nearestSegmentPoint = target_ToPoint;
        }
      }
      result.distance = distance;
      result.compareDistance = compareDistance;
      result.nearestSegmentIndex = i;
    }
  }
  static hitTestLocationToStrokeByRectangle(location, stroke, minDistance) {
    return stroke.runtime.area.hittestLocationWithRadius(location, minDistance);
  }
  static hitTestLineSegmentToStrokeByRectangle(segmentFrom, segmentTo, stroke, minDistance) {
    const surroundLeft = stroke.runtime.area.left - minDistance;
    const surroundTop = stroke.runtime.area.top - minDistance;
    const surroundRight = stroke.runtime.area.right + minDistance;
    const surroundBottom = stroke.runtime.area.bottom + minDistance;
    if (_VectorStrokeHitTestLogic.hitTestLocationToStrokeByRectangle(segmentFrom, stroke, minDistance)) {
      return true;
    }
    if (_VectorStrokeHitTestLogic.hitTestLocationToStrokeByRectangle(segmentTo, stroke, minDistance)) {
      return true;
    }
    if (Maths.lineToLine_CrossPoint(
      this.tempCrossingLocation,
      segmentFrom[0],
      segmentFrom[1],
      segmentTo[0],
      segmentTo[1],
      surroundLeft,
      surroundTop,
      surroundRight,
      surroundTop
    )) {
      return true;
    }
    if (Maths.lineToLine_CrossPoint(
      this.tempCrossingLocation,
      segmentFrom[0],
      segmentFrom[1],
      segmentTo[0],
      segmentTo[1],
      surroundRight,
      surroundTop,
      surroundRight,
      surroundBottom
    )) {
      return true;
    }
    if (Maths.lineToLine_CrossPoint(
      this.tempCrossingLocation,
      segmentFrom[0],
      segmentFrom[1],
      segmentTo[0],
      segmentTo[1],
      surroundRight,
      surroundBottom,
      surroundLeft,
      surroundBottom
    )) {
      return true;
    }
    if (Maths.lineToLine_CrossPoint(
      this.tempCrossingLocation,
      segmentFrom[0],
      segmentFrom[1],
      segmentTo[0],
      segmentTo[1],
      surroundLeft,
      surroundBottom,
      surroundLeft,
      surroundTop
    )) {
      return true;
    }
    return false;
  }
  static hitTestStrokeToStrokeByRectangle(stroke1, stroke2, minDistance) {
    const centerX1 = stroke1.runtime.area.getMedianHrizontalPosition();
    const centerY1 = stroke1.runtime.area.getMedianVerticalPosition();
    const centerX2 = stroke2.runtime.area.getMedianHrizontalPosition();
    const centerY2 = stroke2.runtime.area.getMedianVerticalPosition();
    const widthHalf = (stroke1.runtime.area.getWidth() + stroke2.runtime.area.getWidth()) / 2 + minDistance;
    const heightHalf = (stroke1.runtime.area.getHeight() + stroke2.runtime.area.getHeight()) / 2 + minDistance;
    return centerX2 >= centerX1 - widthHalf && centerX2 <= centerX1 + widthHalf && centerY2 >= centerY1 - heightHalf && centerY2 <= centerY1 + heightHalf;
  }
};
let VectorStrokeHitTestLogic = _VectorStrokeHitTestLogic;
VectorStrokeHitTestLogic.MaxDistance = 999999;
VectorStrokeHitTestLogic.InvalidDistance = -1;
VectorStrokeHitTestLogic.InvalidIndex = -1;
VectorStrokeHitTestLogic.tempCrossingLocation = vec3.create();
class HitTest_VectorPointBase {
  constructor() {
    this.existsPointHitTest = false;
    this.currentLayer = null;
    this.currentGeometry = null;
    this.currentDrawingUnit = null;
    this.currentStrokeGroup = null;
    this.currentStroke = null;
  }
  startProcess() {
    this.existsPointHitTest = false;
    this.beforeHitTest();
  }
  processGeometry(layer, geometry, location, minDistance) {
    this.hitTest(geometry, location, minDistance, layer);
  }
  endProcess() {
    this.afterHitTest();
  }
  hitTest(geometry, location, minDistance, layer) {
    this.beforeHitTestToLayer(geometry);
    const minDistanceSQ = Math.pow(minDistance, 2);
    this.currentLayer = layer;
    this.currentGeometry = geometry;
    for (const unit of geometry.units) {
      this.currentDrawingUnit = unit;
      for (const group of unit.groups) {
        this.currentStrokeGroup = group;
        this.beforeHitTestToGroup();
        for (const stroke of group.lines) {
          this.currentStroke = stroke;
          this.beforeHitTestToLine();
          let lineHited = false;
          if (this.hitTestStrokeByRectangle(stroke, location, minDistance)) {
            lineHited = this.processHitTestToStroke(location, minDistanceSQ);
          }
          if (lineHited) {
            this.onLineHited();
          } else {
            this.onLineNotHited();
          }
          this.afterHitTestToLine();
        }
        this.currentStroke = null;
        this.afterHitTestToGroup();
      }
      this.currentStrokeGroup = null;
    }
    this.currentDrawingUnit = null;
    this.afterHitTestToLayer(geometry);
    this.currentGeometry = null;
    this.currentLayer = null;
  }
  hitTestStrokeByRectangle(line, location, minDistance) {
    return VectorStrokeHitTestLogic.hitTestLocationToStrokeByRectangle(location, line, minDistance);
  }
  processHitTestToStroke(_location, _minDistanceSQ) {
    return false;
  }
  beforeHitTest() {
  }
  afterHitTest() {
  }
  beforeHitTestToLayer(_geometry) {
  }
  afterHitTestToLayer(_geometry) {
  }
  beforeHitTestToGroup() {
  }
  afterHitTestToGroup() {
  }
  beforeHitTestToLine() {
  }
  afterHitTestToLine() {
  }
  onPointHited(_point) {
  }
  onPointNotHited(_point) {
  }
  onLineSegmentHited(_point1, _point2, _location, _minDistanceSQ, _distanceSQ) {
  }
  onLineSegmentNotHited(_point1, _point2) {
  }
  onLineHited() {
  }
  onLineNotHited() {
  }
}
class HitTest_VectorPoint_PointToPoint extends HitTest_VectorPointBase {
  processHitTestToStroke(location, minDistanceSQ) {
    this.existsPointHitTest = false;
    for (const point of this.currentStroke.points) {
      const distance2d = Math.pow(location[0] - point.location[0], 2) + Math.pow(location[1] - point.location[1], 2);
      if (distance2d < minDistanceSQ) {
        this.onPointHited(point);
      } else {
        this.onPointNotHited(point);
      }
      if (this.existsPointHitTest) {
        break;
      }
    }
    return this.existsPointHitTest;
  }
}
class HitTest_VectorStroke_PointToStroke extends HitTest_VectorPointBase {
  processHitTestToStroke(location, minDistanceSQ) {
    this.existsPointHitTest = false;
    let lineHited = false;
    for (let i = 0; i + 1 < this.currentStroke.points.length; i++) {
      const point1 = this.currentStroke.points[i];
      const point2 = this.currentStroke.points[i + 1];
      const distanceSQ = Logic_Points.pointToLineSegment_SorroundingDistanceSQ(
        point1.location,
        point2.location,
        location
      );
      if (distanceSQ < minDistanceSQ) {
        this.onLineSegmentHited(point1, point2, location, minDistanceSQ, distanceSQ);
        lineHited = true;
      } else {
        this.onLineSegmentNotHited(point1, point2);
      }
      if (this.existsPointHitTest) {
        break;
      }
    }
    return lineHited;
  }
}
class HitTest_VectorStroke_PointToStroke_Nearest extends HitTest_VectorStroke_PointToStroke {
  constructor() {
    super(...arguments);
    this.minDistanceSQ = -1;
    this.hitedGeometry = null;
    this.hitedGroup = null;
    this.hitedStoke = null;
  }
  beforeHitTest() {
    this.minDistanceSQ = -1;
    this.hitedGeometry = null;
    this.hitedGroup = null;
    this.hitedStoke = null;
  }
  onLineSegmentHited(_point1, _point2, _location, _minDistanceSQ, distanceSQ) {
    if (this.minDistanceSQ == -1 || distanceSQ < this.minDistanceSQ) {
      this.minDistanceSQ = distanceSQ;
      this.hitedGeometry = this.currentGeometry;
      this.hitedGroup = this.currentStrokeGroup;
      this.hitedStoke = this.currentStroke;
    }
  }
}
class HitTest_VectorStroke_IsCloseToMouse extends HitTest_VectorStroke_PointToStroke {
  constructor() {
    super(...arguments);
    this.isChanged = false;
  }
  beforeHitTest() {
    this.isChanged = false;
  }
  onLineSegmentHited(_point1, _point2, _location, _minDistanceSQ, _distanceSQ) {
    this.existsPointHitTest = true;
  }
  onLineHited() {
    if (!this.currentStroke.runtime.isCloseToMouse) {
      this.isChanged = true;
    }
    this.currentStroke.runtime.isCloseToMouse = true;
  }
  onLineNotHited() {
    if (this.currentStroke.runtime.isCloseToMouse) {
      this.isChanged = true;
    }
    this.currentStroke.runtime.isCloseToMouse = false;
  }
}
class VectorLayerLogic {
  static clearGeometryModifyFlags(geometry) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        this.clearGroupModifyFlags(group);
      }
    }
  }
  static clearGroupModifyFlags(group) {
    group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.none;
    group.runtime.linePointModifyFlag = VectorStrokeGroupModifyFlagID.none;
    for (const stroke of group.lines) {
      this.clearStrokeModifyFlags(stroke);
    }
  }
  static clearStrokeModifyFlags(stroke) {
    stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
    VectorLayerLogic.clearPointModifyFlags(stroke.points);
  }
  static clearPointModifyFlags(points) {
    for (const point of points) {
      point.modifyFlag = VectorPointModifyFlagID.none;
    }
  }
  static fillGeometryDeleteFlags(geometry, forceDelete) {
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        this.fillGroupDeleteFlags(group, forceDelete);
      }
    }
  }
  static fillGroupDeleteFlags(group, forceDelete) {
    if (forceDelete) {
      group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.delete;
    }
    let setDelete = false;
    if (group.runtime.modifyFlag == VectorStrokeGroupModifyFlagID.delete) {
      setDelete = true;
    }
    for (const line of group.lines) {
      this.fillLineDeleteFlags(line, setDelete);
    }
  }
  static fillLineDeleteFlags(line, forceDelete) {
    if (forceDelete) {
      line.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
    }
    if (line.runtime.modifyFlag == VectorStrokeModifyFlagID.delete) {
      for (const point of line.points) {
        point.modifyFlag = VectorPointModifyFlagID.delete;
      }
    }
  }
}
const _VectorPointLogic = class {
  static getLineRadiusFromLineWidth(lineWidth) {
    return lineWidth / 2;
  }
  static getPointRadius(point) {
    return _VectorPointLogic.getLineRadiusFromLineWidth(point.lineWidth);
  }
  static calculatePointTotalLength(points, startLength) {
    if (points.length == 0) {
      return;
    }
    points[0].totalLength = startLength;
    let totalLength = startLength;
    for (let i = 1; i < points.length; i++) {
      const point1 = points[i];
      const point2 = points[i - 1];
      totalLength += vec3.distance(point1.location, point2.location);
      point1.totalLength = totalLength;
    }
  }
  static calculatePointCurvature(points) {
    if (points.length <= 2) {
      return;
    }
    points[0].totalLength = 0;
    points[points.length - 1].totalLength = 0;
    for (let i = 1; i + 1 < points.length; i++) {
      const point1 = points[i - 1];
      const point2 = points[i];
      const point3 = points[i + 1];
      point2.curvature = Logic_Points.angleDistanceOfCorner(point1.location, point2.location, point3.location);
    }
  }
  static calculateSegmentTotalLength(points, startIndex, endIndex) {
    let totalLength = 0;
    for (let i = startIndex; i <= endIndex - 1; i++) {
      const point1 = points[i];
      const point2 = points[i + 1];
      totalLength += vec3.distance(point1.location, point2.location);
    }
    return totalLength;
  }
  static resamplePoints(result, points, startIndex, endIndex, samplingUnitLength) {
    if (samplingUnitLength <= 0) {
      throw new Error("ERROR 0000: Can't set sampling unit length as zero or minus");
    }
    const sampledLocationVec = this.sampledLocation;
    const totalLength = _VectorPointLogic.calculateSegmentTotalLength(points, startIndex, endIndex);
    const firstPoint = points[startIndex];
    const lastPoint = points[endIndex];
    let currentIndex = startIndex;
    let currentPosition = 0;
    const endPosition = totalLength;
    const maxSampleCount = 1 + Math.ceil(totalLength / samplingUnitLength);
    let nextStepLength = samplingUnitLength;
    {
      const sampledPoint = new VectorPoint();
      vec3.copy(sampledPoint.location, firstPoint.location);
      vec3.copy(sampledPoint.adjustingLocation, sampledPoint.location);
      sampledPoint.lineWidth = firstPoint.lineWidth;
      sampledPoint.adjustingLineWidth = sampledPoint.lineWidth;
      result.push(sampledPoint);
    }
    let sampledCount = 1;
    let currentPointPosition = 0;
    while (currentPosition < endPosition) {
      const currentPoint = points[currentIndex];
      const nextPoint = points[currentIndex + 1];
      const segmentLength = vec3.distance(nextPoint.location, currentPoint.location);
      if (segmentLength < samplingUnitLength / 10) {
        currentIndex++;
        currentPointPosition += segmentLength;
        if (currentIndex == endIndex) {
          break;
        }
      }
      const nextPointPosition = currentPointPosition + segmentLength;
      if (currentPosition + nextStepLength >= endPosition - samplingUnitLength / 2) {
        break;
      } else if (currentPosition + nextStepLength <= nextPointPosition) {
        const localPosition = currentPosition + nextStepLength - currentPointPosition;
        const positionRate = localPosition / segmentLength;
        vec3.lerp(sampledLocationVec, currentPoint.location, nextPoint.location, positionRate);
        const sampledPoint = new VectorPoint();
        vec3.copy(sampledPoint.location, sampledLocationVec);
        vec3.copy(sampledPoint.adjustingLocation, sampledPoint.location);
        sampledPoint.lineWidth = Maths.lerp(positionRate, currentPoint.lineWidth, nextPoint.lineWidth);
        sampledPoint.adjustingLineWidth = sampledPoint.lineWidth;
        result.push(sampledPoint);
        currentPosition = currentPosition + nextStepLength;
        nextStepLength = samplingUnitLength;
        sampledCount++;
        if (sampledCount >= maxSampleCount) {
          break;
        }
      } else {
        nextStepLength = currentPosition + nextStepLength - nextPointPosition;
        currentPosition = nextPointPosition;
        currentIndex++;
        currentPointPosition += segmentLength;
        if (currentIndex == endIndex) {
          break;
        }
      }
    }
    {
      const sampledPoint = new VectorPoint();
      vec3.copy(sampledPoint.location, lastPoint.location);
      vec3.copy(sampledPoint.adjustingLocation, sampledPoint.location);
      sampledPoint.lineWidth = lastPoint.lineWidth;
      sampledPoint.adjustingLineWidth = sampledPoint.lineWidth;
      result.push(sampledPoint);
    }
    return result;
  }
};
let VectorPointLogic = _VectorPointLogic;
VectorPointLogic.sampledLocation = vec3.fromValues(0, 0, 0);
class VectorStrokeLogic {
  static expandAreasForPoint(bound_area, inner_area, point, lineWidthBiasRate) {
    const pointRadius = VectorPointLogic.getPointRadius(point);
    bound_area.expandByLocation(
      point.location[0] - pointRadius * lineWidthBiasRate,
      point.location[1] - pointRadius * lineWidthBiasRate
    );
    bound_area.expandByLocation(
      point.location[0] + pointRadius * lineWidthBiasRate,
      point.location[1] + pointRadius * lineWidthBiasRate
    );
    inner_area.expandByLocation(
      point.location[0],
      point.location[1]
    );
  }
  static calculateParameters(stroke, lineWidthBiasRate = 1) {
    let isSelected = false;
    stroke.runtime.area.setMinimumValue();
    stroke.runtime.innerArea.setMinimumValue();
    for (const point of stroke.points) {
      this.expandAreasForPoint(
        stroke.runtime.area,
        stroke.runtime.innerArea,
        point,
        lineWidthBiasRate
      );
      if (point.isSelected) {
        isSelected = true;
      }
    }
    stroke.runtime.area.calculateParams();
    stroke.runtime.innerArea.calculateParams();
    stroke.isSelected = isSelected;
    if (stroke.points.length > 0) {
      VectorPointLogic.calculatePointTotalLength(stroke.points, 0);
      stroke.runtime.totalLength = stroke.points[stroke.points.length - 1].totalLength;
    } else {
      stroke.runtime.totalLength = 0;
    }
    VectorPointLogic.calculatePointCurvature(stroke.points);
  }
  static calculateSurroundingArea(result, strokes) {
    result.setMinimumValue();
    for (const stroke of strokes) {
      RectangleArea.calculateSurroundingRectangle(result, result, stroke.runtime.area);
    }
    result.calculateParams();
  }
  static isEmpty(stroke) {
    return stroke.points.length == 0;
  }
  static isEmptyStroke(stroke) {
    return stroke.points.length < 2 || stroke.runtime.totalLength <= 0 || stroke.runtime.innerArea.range == 0;
  }
  static clalculateSamplingDivisionCount(totalLength, resamplingUnitLength) {
    if (resamplingUnitLength <= 0) {
      throw new Error("ERROR 0000: Can't set resampling unit length as zero or minus");
    }
    let divisionCount = Math.floor(totalLength / resamplingUnitLength);
    if (divisionCount % 2 == 0) {
      divisionCount = divisionCount + 1;
    }
    return divisionCount;
  }
  static smooth(line, iterationCount = 1) {
    for (let loopCount = 0; loopCount < iterationCount; loopCount++) {
      VectorStrokeLogic.smoothPoints(line.points);
      VectorStrokeLogic.applyAdjustments(line);
    }
    VectorStrokeLogic.calculateParameters(line);
  }
  static smoothPoints(linePoints) {
    for (let i = 0; i < linePoints.length; i++) {
      const point = linePoints[i];
      vec3.copy(point.adjustingLocation, point.location);
      vec3.copy(point.tempLocation, point.location);
      point.adjustingLineWidth = point.lineWidth;
    }
    const iteration = 2;
    for (let count = 0; count < iteration; count++) {
      for (let i = 0; i + 2 < linePoints.length; i++) {
        const point1 = linePoints[i];
        const point2 = linePoints[i + 1];
        const point3 = linePoints[i + 2];
        VectorStrokeLogic.calcBezier2d(
          point2.adjustingLocation,
          point1.tempLocation,
          point2.tempLocation,
          point3.tempLocation,
          0.5
        );
        point2.adjustingLineWidth = (point1.adjustingLineWidth + point3.adjustingLineWidth) / 2;
      }
      for (let i = 0; i + 2 < linePoints.length; i++) {
        const point2 = linePoints[i + 1];
        vec3.copy(point2.tempLocation, point2.adjustingLocation);
      }
    }
  }
  static calcBezier2d(result, p0, p1, p2, t2) {
    const px = (1 - t2) * (1 - t2) * p0[0] + 2 * (1 - t2) * t2 * p1[0] + t2 * t2 * p2[0];
    const py = (1 - t2) * (1 - t2) * p0[1] + 2 * (1 - t2) * t2 * p1[1] + t2 * t2 * p2[1];
    vec3.set(result, px, py, 0);
  }
  static applyAdjustments(line) {
    for (const point of line.points) {
      vec3.copy(point.location, point.adjustingLocation);
      point.lineWidth = point.adjustingLineWidth;
    }
  }
  static resetModifyStates(lines) {
    for (const line of lines) {
      line.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
    }
  }
  static createResampledLine(baseLine, samplingUnitLength) {
    const result = new VectorStroke();
    const startIndex = 0;
    const endIndex = baseLine.points.length - 1;
    VectorPointLogic.resamplePoints(
      result.points,
      baseLine.points,
      startIndex,
      endIndex,
      samplingUnitLength
    );
    VectorStrokeLogic.calculateParameters(result);
    return result;
  }
  static createConnectionInfos(strokeGroup) {
    const infos = [];
    for (const [index2, stroke] of strokeGroup.lines.entries()) {
      if (index2 != strokeGroup.lines.length - 1) {
        const info = new VectorStrokeConnectionInfo();
        info.from_Stroke = stroke;
        info.to_Stroke = strokeGroup.lines[index2 + 1];
        infos.push(info);
      }
    }
    return infos;
  }
}
class AutoFillSearchState {
  constructor(targetStroke, start_SegmentIndex, isForwardSearch, start_Location, previousState) {
    this.targetStroke = targetStroke;
    this.start_SegmentIndex = start_SegmentIndex;
    this.isForwardSearch = isForwardSearch;
    this.previousState = previousState;
    this.startLocation = vec3.fromValues(0, 0, 0);
    this.points = [];
    this.rotationCalcPoints = [];
    this.start_PointIndex = -1;
    this.end_PointIndex = -1;
    this.totalRotation = 0;
    vec3.copy(this.startLocation, start_Location);
    if (previousState != null) {
      this.totalRotation = previousState.totalRotation;
      if (previousState.points.length > 0) {
        this.rotationCalcPoints.push(previousState.points[previousState.points.length - 1]);
      }
    }
  }
  addPoint(location) {
    const point = new VectorPoint();
    vec3.copy(point.location, location);
    vec3.copy(point.adjustingLocation, location);
    this.points.push(point);
    this.rotationCalcPoints.push(point);
    if (this.rotationCalcPoints.length >= 3) {
      const rotation = Logic_Points.directionAngleDifferenceOfCorner(
        this.rotationCalcPoints[this.rotationCalcPoints.length - 3].location,
        this.rotationCalcPoints[this.rotationCalcPoints.length - 2].location,
        this.rotationCalcPoints[this.rotationCalcPoints.length - 1].location
      );
      if (rotation > -Math.PI * 0.99 && rotation < Math.PI * 0.99) {
        this.totalRotation += rotation;
      }
    }
  }
}
const _AutoFillLogic = class {
  static findStartStroke(startLocation, mouseCursorViewRadius, viewKeyframeLayers) {
    let startStroke = null;
    let hitedDistanceSQ = -1;
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry, layer) => {
      this.lineNearestHitTester.startProcess();
      this.lineNearestHitTester.processGeometry(layer, geometry, startLocation, mouseCursorViewRadius);
      if (this.lineNearestHitTester.hitedStoke != null) {
        if (hitedDistanceSQ == -1 || this.lineNearestHitTester.minDistanceSQ < hitedDistanceSQ) {
          hitedDistanceSQ = this.lineNearestHitTester.minDistanceSQ;
          startStroke = this.lineNearestHitTester.hitedStoke;
        }
      }
    });
    return startStroke;
  }
  static generate(resultStroke, resultLookDirection, start_Stroke, start_Location, minDistanceRange, sibling_ViewKeyframeLayers) {
    const start_SegmentIndex = VectorStrokeHitTestLogic.getNearestSegmentIndex(
      start_Stroke,
      start_Location
    );
    if (start_SegmentIndex == VectorStrokeHitTestLogic.InvalidIndex) {
      return false;
    }
    const target_Strokes = this.getTargetStrokes(sibling_ViewKeyframeLayers);
    for (const stroke of target_Strokes) {
      VectorLayerLogic.clearStrokeModifyFlags(stroke);
    }
    const start_IsForwardSearch = this.isForwardSearchAtSegment(
      this.nearestLocation,
      start_Location,
      start_Stroke,
      start_SegmentIndex
    );
    vec3.subtract(resultLookDirection, this.nearestLocation, start_Location);
    const searchStateStack = [];
    searchStateStack.push(new AutoFillSearchState(
      start_Stroke,
      start_SegmentIndex,
      start_IsForwardSearch,
      this.nearestLocation,
      null
    ));
    let isLoopFinished = false;
    let available_SearchState = null;
    while (searchStateStack.length > 0) {
      const searchState = searchStateStack.pop();
      const current_Stroke = searchState.targetStroke;
      const current_SegmentIndex = searchState.start_SegmentIndex;
      const current_IsForwardSearch = searchState.isForwardSearch;
      vec3.copy(this.strokeStartLocation, searchState.startLocation);
      vec3.copy(this.currentLocation, searchState.startLocation);
      if (current_IsForwardSearch && current_SegmentIndex + 1 >= current_Stroke.points.length || !current_IsForwardSearch && current_SegmentIndex < 0) {
        continue;
      }
      const candidate_Strokes = target_Strokes.filter(
        (stroke) => stroke != current_Stroke && VectorStrokeHitTestLogic.hitTestStrokeToStrokeByRectangle(current_Stroke, stroke, minDistanceRange)
      );
      let next_Stroke = null;
      let next_SegmentIndex = -1;
      let search_PointIndex = current_IsForwardSearch ? current_SegmentIndex + 1 : current_SegmentIndex;
      let searched_Start_PointIndex = -1;
      let searched_Last_PointIndex = -1;
      let next_IsCrossing = false;
      let isSegmentSearchEnd = false;
      let isRouteDiscarded = false;
      {
        let candidate_Stroke = null;
        let candidate_SegmentIndex = -1;
        let candidate_IsCrossing = false;
        while (true) {
          const pointTo = current_Stroke.points[search_PointIndex];
          if (pointTo.modifyFlag == VectorPointModifyFlagID.edit) {
            isLoopFinished = current_Stroke == start_Stroke && (start_IsForwardSearch && search_PointIndex == start_SegmentIndex + 1 || !start_IsForwardSearch && search_PointIndex == start_SegmentIndex);
            if (!isLoopFinished) {
              isRouteDiscarded = true;
              break;
            }
          }
          vec3.copy(this.lastLocation, this.currentLocation);
          vec3.copy(this.currentLocation, pointTo.location);
          const nearToSegment_Strokes = candidate_Strokes.filter(
            (stroke) => VectorStrokeHitTestLogic.hitTestLineSegmentToStrokeByRectangle(this.lastLocation, this.currentLocation, stroke, minDistanceRange)
          );
          const isSearchPointAtEndOfStroke = current_IsForwardSearch && search_PointIndex >= current_Stroke.points.length - 1 || !current_IsForwardSearch && search_PointIndex <= 0;
          let minDistance_Stroke = null;
          let minDistance_SegmentIndex = -1;
          let minDistance_IsCrossing = false;
          let compareDistance = -1;
          for (const stroke of nearToSegment_Strokes) {
            VectorStrokeHitTestLogic.searchSegmentToSegmentNearestIndex(
              this.strokeSearchResult,
              this.lastLocation,
              this.currentLocation,
              stroke
            );
            if (this.strokeSearchResult.nearestSegmentIndex == VectorStrokeHitTestLogic.InvalidIndex) {
              continue;
            }
            if (this.strokeSearchResult.distance > minDistanceRange) {
              continue;
            }
            if (this.strokeSearchResult.nearestSegmentPoint != null && this.strokeSearchResult.nearestSegmentPoint.modifyFlag == VectorPointModifyFlagID.edit) {
              continue;
            }
            if (this.strokeSearchResult.isCrossing && vec3.distance(this.lastLocation, this.strokeSearchResult.crossingLocation) < _AutoFillLogic.limitMinimumSegmentLength) {
              continue;
            }
            if (compareDistance == -1 || this.strokeSearchResult.compareDistance < compareDistance) {
              minDistance_Stroke = stroke;
              minDistance_SegmentIndex = this.strokeSearchResult.nearestSegmentIndex;
              minDistance_IsCrossing = this.strokeSearchResult.isCrossing;
              vec3.copy(this.crossingLocation, this.strokeSearchResult.crossingLocation);
              compareDistance = this.strokeSearchResult.compareDistance;
            }
          }
          let segement_Leaved = false;
          isSegmentSearchEnd = isLoopFinished || isSearchPointAtEndOfStroke;
          if (minDistance_Stroke != null && (isSegmentSearchEnd || minDistance_IsCrossing)) {
            candidate_Stroke = minDistance_Stroke;
            candidate_SegmentIndex = minDistance_SegmentIndex;
            candidate_IsCrossing = minDistance_IsCrossing;
            vec3.copy(this.lastSegmentLocationFrom, this.lastLocation);
            if (minDistance_IsCrossing) {
              vec3.copy(this.lastSegmentLocationTo, this.crossingLocation);
            } else {
              vec3.copy(this.lastSegmentLocationTo, this.currentLocation);
            }
          }
          if (isSegmentSearchEnd || candidate_IsCrossing || segement_Leaved) {
            if (candidate_Stroke) {
              next_Stroke = candidate_Stroke;
              next_SegmentIndex = candidate_SegmentIndex;
              next_IsCrossing = candidate_IsCrossing;
            }
            if (!candidate_IsCrossing) {
              if (searched_Start_PointIndex == -1) {
                searched_Start_PointIndex = search_PointIndex;
              }
              searched_Last_PointIndex = search_PointIndex;
            }
            break;
          }
          if (searched_Start_PointIndex == -1) {
            searched_Start_PointIndex = search_PointIndex;
          }
          searched_Last_PointIndex = search_PointIndex;
          search_PointIndex = current_IsForwardSearch ? search_PointIndex + 1 : search_PointIndex - 1;
        }
      }
      if (isRouteDiscarded) {
        continue;
      }
      searchState.start_PointIndex = Math.min(searched_Start_PointIndex, searched_Last_PointIndex);
      searchState.end_PointIndex = Math.max(searched_Start_PointIndex, searched_Last_PointIndex);
      searchState.addPoint(this.strokeStartLocation);
      if (searched_Start_PointIndex != -1) {
        for (let index2 = searched_Start_PointIndex; ; ) {
          const point = current_Stroke.points[index2];
          searchState.addPoint(point.location);
          point.modifyFlag = VectorPointModifyFlagID.edit;
          if (index2 == searched_Last_PointIndex) {
            break;
          }
          index2 += current_IsForwardSearch ? 1 : -1;
        }
      }
      if (isLoopFinished) {
        searchState.addPoint(this.currentLocation);
        available_SearchState = searchState;
        break;
      }
      if (next_Stroke != null) {
        if (next_IsCrossing) {
          const next_IsForwardSearch = Logic_Points.isClockwise(
            this.lastSegmentLocationFrom,
            this.crossingLocation,
            next_Stroke.points[next_SegmentIndex + 1].location
          );
          this.pushNext(
            searchStateStack,
            searchState,
            next_Stroke,
            next_SegmentIndex,
            !next_IsForwardSearch,
            this.crossingLocation
          );
          this.pushNext(
            searchStateStack,
            searchState,
            current_Stroke,
            search_PointIndex,
            current_IsForwardSearch,
            this.crossingLocation
          );
          this.pushNext(
            searchStateStack,
            searchState,
            next_Stroke,
            next_SegmentIndex,
            next_IsForwardSearch,
            this.crossingLocation
          );
        } else {
          const next_IsForwardSearch = this.isForwardSearchAtSegment(this.nearestLocation, this.lastSegmentLocationTo, next_Stroke, next_SegmentIndex);
          this.pushNext(
            searchStateStack,
            searchState,
            next_Stroke,
            next_SegmentIndex,
            !next_IsForwardSearch,
            this.nearestLocation
          );
          this.pushNext(
            searchStateStack,
            searchState,
            next_Stroke,
            next_SegmentIndex,
            next_IsForwardSearch,
            this.nearestLocation
          );
        }
      }
      if (isSegmentSearchEnd) {
        if (available_SearchState == null || available_SearchState.totalRotation < searchState.totalRotation) {
          available_SearchState = searchState;
        }
      }
    }
    for (const stroke of target_Strokes) {
      VectorLayerLogic.clearStrokeModifyFlags(stroke);
    }
    const stateList = [];
    if (available_SearchState != null) {
      let state = available_SearchState;
      while (state != null) {
        stateList.push(state);
        state = state.previousState;
      }
    }
    Lists.reverse(stateList);
    for (const state of stateList) {
      state.points.forEach((p2) => resultStroke.points.push(p2));
    }
    VectorStrokeLogic.calculateParameters(resultStroke);
    return true;
  }
  static getTargetStrokes(viewKeyframeLayers) {
    const target_Strokes = [];
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry) => {
      for (const unit of geometry.units) {
        for (const group of unit.groups) {
          for (const stroke of group.lines) {
            target_Strokes.push(stroke);
          }
        }
      }
    });
    return target_Strokes;
  }
  static isForwardSearchAtSegment(resultNearestLocation, currentLocation, stroke, segmentIndex) {
    const from_PointIndex = segmentIndex;
    const to_PointIndex = segmentIndex + 1;
    const from_Point = stroke.points[from_PointIndex];
    const to_Point = stroke.points[to_PointIndex];
    const from_Location = from_Point.location;
    const to_Location = to_Point.location;
    const normalizedPosition = Logic_Points.pointToLineSegment_NormalizedPosition(
      from_Location,
      to_Location,
      currentLocation
    );
    if (normalizedPosition < 0) {
      const isForwardSearch = this.isForwardSearchAtSegmentCorner(
        resultNearestLocation,
        currentLocation,
        stroke,
        from_PointIndex
      );
      return isForwardSearch;
    } else if (normalizedPosition > 1) {
      const isForwardSearch = this.isForwardSearchAtSegmentCorner(
        resultNearestLocation,
        currentLocation,
        stroke,
        to_PointIndex
      );
      return isForwardSearch;
    } else {
      const isAvailable = Logic_Points.pointToLine_NearestLocation(
        resultNearestLocation,
        from_Location,
        to_Location,
        currentLocation
      );
      if (!isAvailable) {
        return true;
      }
      const isForwardSearch = Logic_Points.isClockwise(
        currentLocation,
        resultNearestLocation,
        to_Location
      );
      return isForwardSearch;
    }
  }
  static isForwardSearchAtSegmentCorner(resultNearestLocation, currentLocation, stroke, pointIndex) {
    const center_Point = stroke.points[pointIndex];
    vec3.copy(resultNearestLocation, center_Point.location);
    const isHead = pointIndex <= 0;
    const isTail = pointIndex >= stroke.points.length - 1;
    if (isHead || isTail) {
      return isHead;
    }
    const previous_Point = stroke.points[pointIndex - 1];
    const next_Point = stroke.points[pointIndex + 1];
    vec3.subtract(this.tangentPreviousVec, previous_Point.location, center_Point.location);
    vec3.normalize(this.tangentPreviousVec, this.tangentPreviousVec);
    vec3.subtract(this.tangentNextVec, next_Point.location, center_Point.location);
    vec3.normalize(this.tangentNextVec, this.tangentNextVec);
    vec3.subtract(this.tangentDirection, this.tangentNextVec, this.tangentPreviousVec);
    vec3.add(this.tangentLocation, center_Point.location, this.tangentDirection);
    const isForwardSearch = Logic_Points.isClockwise(
      currentLocation,
      center_Point.location,
      this.tangentLocation
    );
    return isForwardSearch;
  }
  static isAvailableToNextSearch(stroke, segmentIndex, isForwardSearch, currentLocation) {
    const targetIndex = isForwardSearch ? segmentIndex + 1 : segmentIndex;
    if (targetIndex < 0 || targetIndex >= stroke.points.length) {
      return false;
    }
    const targetPoint = stroke.points[targetIndex];
    return vec3.distance(currentLocation, targetPoint.location) > 0;
  }
  static pushNext(searchStateStack, currentState, stroke, segmentIndex, isForwardSearch, currentLocation) {
    if (!this.isAvailableToNextSearch(stroke, segmentIndex, isForwardSearch, currentLocation)) {
      return;
    }
    searchStateStack.push(new AutoFillSearchState(
      stroke,
      segmentIndex,
      isForwardSearch,
      currentLocation,
      currentState
    ));
  }
};
let AutoFillLogic = _AutoFillLogic;
AutoFillLogic.lineNearestHitTester = new HitTest_VectorStroke_PointToStroke_Nearest();
AutoFillLogic.currentLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.lastLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.strokeStartLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.nearestLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.crossingLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.tangentPreviousVec = vec3.fromValues(0, 0, 0);
AutoFillLogic.tangentNextVec = vec3.fromValues(0, 0, 0);
AutoFillLogic.tangentDirection = vec3.fromValues(0, 0, 0);
AutoFillLogic.tangentLocation = vec3.fromValues(0, 0, 0);
AutoFillLogic.lastSegmentLocationFrom = vec3.fromValues(0, 0, 0);
AutoFillLogic.lastSegmentLocationTo = vec3.fromValues(0, 0, 0);
AutoFillLogic.strokeSearchResult = new StrokeSearchResult();
AutoFillLogic.limitMinimumSegmentLength = 1e-3;
class DocumentMigration_v00_01_01 {
  static matches(versionString) {
    return versionString == this.currentVersionString;
  }
  static migrateDocumentData(documentData) {
    {
      if (documentData.paletteColors == void 0) {
        if (documentData["palletColors"] != void 0) {
          documentData["paletteColors"] = documentData["palletColors"];
        } else {
          DocumentData.initializeDefaultPaletteColors(documentData);
        }
      }
      for (const paletteColor of documentData.paletteColors) {
        paletteColor.isSelected = false;
      }
      while (documentData.paletteColors.length < DocumentData.maxPaletteColors) {
        documentData.paletteColors.push(new PaletteColor());
      }
    }
    if (documentData["exportingCount"] != void 0) {
      delete documentData["exportingCount"];
    }
    if (documentData["exportBackGroundType"] != void 0) {
      delete documentData["exportBackGroundType"];
    }
    return this.nextVersionString;
  }
  static migrateLayer(layer) {
    if (layer.isRenderTarget == void 0) {
      layer.isRenderTarget = true;
    }
    if (layer.isMaskedByBelowLayer == void 0) {
      layer.isMaskedByBelowLayer = false;
    }
    if (layer.isListExpanded == void 0) {
      layer.isListExpanded = true;
    }
    return this.nextVersionString;
  }
  static migrateVectorLayer(layer, state) {
    const vectorLayer = layer;
    vectorLayer["eyesSymmetryGeometry"] = null;
    if (vectorLayer.drawLineType == void 0) {
      vectorLayer.drawLineType = DrawLineTypeID.layerColor;
    }
    if (vectorLayer.fillAreaType == void 0) {
      vectorLayer.fillAreaType = FillAreaTypeID.none;
    }
    if (vectorLayer.fillColor == void 0) {
      vectorLayer.fillColor = vec4.fromValues(1, 1, 1, 1);
    }
    if (vectorLayer["enableEyesSymmetry"] != void 0) {
      vectorLayer.eyesSymmetryEnabled = vectorLayer["enableEyesSymmetry"];
    }
    if (vectorLayer.eyesSymmetryEnabled == void 0) {
      vectorLayer.eyesSymmetryEnabled = false;
      vectorLayer.eyesSymmetryInputSide = EyesSymmetryInputSideID.left;
      vectorLayer["posingLayer"] = null;
    }
    if (vectorLayer["posingLayer"] != void 0) {
      delete vectorLayer["posingLayer"];
    }
    if (vectorLayer.line_PaletteColorIndex == void 0) {
      vectorLayer.line_PaletteColorIndex = vectorLayer["line_PalletColorIndex"] || 0;
    }
    if (vectorLayer.fill_PaletteColorIndex == void 0) {
      vectorLayer.fill_PaletteColorIndex = vectorLayer["fill_PalletColorIndex"] || 0;
    }
    if (vectorLayer.keyframes == void 0 && vectorLayer["geometry"] != void 0) {
      vectorLayer.keyframes = [];
      const keyframe = new VectorLayerKeyframe(VectorLayerGeometryTypeID.strokes);
      keyframe.frame = 0;
      keyframe.geometry = vectorLayer["geometry"];
      vectorLayer.keyframes.push(keyframe);
    }
    if (vectorLayer.lineWidthBiasRate == void 0) {
      vectorLayer.lineWidthBiasRate = 1;
    }
    if (vectorLayer["geometry"] != void 0) {
      delete vectorLayer["geometry"];
    }
    if (vectorLayer["groups"] != void 0) {
      delete vectorLayer["groups"];
    }
    this.migrateStrokeGroups(vectorLayer);
    this.migrateGeometry(vectorLayer);
    return this.nextVersionString;
  }
  static migrateGeometry(layer) {
    for (const keyframe of layer.keyframes) {
      for (const unit of keyframe.geometry.units) {
        for (const group of unit.groups) {
          for (const stroke of group.lines) {
            for (const point of stroke.points) {
              if (point.lineWidth == void 0) {
                point.lineWidth = 1;
              }
              if (point["adjustedLocation"] != void 0) {
                delete point["adjustedLocation"];
              }
            }
          }
        }
      }
    }
  }
  static migrateStrokeGroups(layer) {
    for (const keyframe of layer.keyframes) {
      if (keyframe.geometry["units"] == void 0 && keyframe.geometry["groups"] != void 0) {
        const new_units = [];
        for (const group of keyframe.geometry["groups"]) {
          const old_lines = group["lines"];
          let new_unit = new VectorStrokeDrawingUnit();
          let new_group = new VectorStrokeGroup();
          for (const line of old_lines) {
            if (line["strokeWidth"] != void 0) {
              delete line["strokeWidth"];
            }
            new_group.lines.push(line);
            if (!line["continuousFill"]) {
              new_unit.groups.push(new_group);
              new_units.push(new_unit);
              new_unit = new VectorStrokeDrawingUnit();
              new_group = new VectorStrokeGroup();
            }
          }
        }
        if (new_units.length == 0) {
          const new_unit = new VectorStrokeDrawingUnit();
          new_units.push(new_unit);
          const new_group = new VectorStrokeGroup();
          new_unit.groups.push(new_group);
        }
        keyframe.geometry.units = new_units;
        delete keyframe.geometry["groups"];
      }
    }
  }
  static migrateAutoFillLayer(layer) {
    const autoFillLayer = layer;
    if (autoFillLayer["fillPoints"] !== void 0) {
      const group = new AutoFillPointGroup();
      group.fillPoints = autoFillLayer["fillPoints"];
      const keyframe = new AutoFillLayerKeyframe();
      keyframe.groups.push(group);
      keyframe.geometry = autoFillLayer["geometry"];
      autoFillLayer.keyframes = [keyframe];
    }
    for (const keyframe of autoFillLayer.keyframes) {
      for (const groups of keyframe.groups) {
        for (const fillPoint of groups.fillPoints) {
          if (fillPoint.minDistanceRange == void 0) {
            fillPoint.minDistanceRange = 15;
          }
        }
      }
    }
    return this.nextVersionString;
  }
  static migrateImageFileReferenceLayer(layer, state) {
    const ifrLayer = layer;
    ifrLayer["adjustingLocation"] = vec3.fromValues(0, 0, 0);
    ifrLayer["adjustingRotation"] = vec3.fromValues(0, 0, 0);
    ifrLayer["adjustingScale"] = vec3.fromValues(1, 1, 1);
    if (ifrLayer.location == void 0) {
      ifrLayer.location = vec3.fromValues(0, 0, 0);
      ifrLayer.rotation = vec3.fromValues(0, 0, 0);
      ifrLayer.scale = vec3.fromValues(1, 1, 1);
    }
    vec3.copy(ifrLayer["adjustingLocation"], ifrLayer.location);
    vec3.copy(ifrLayer["adjustingRotation"], ifrLayer.rotation);
    vec3.copy(ifrLayer["adjustingScale"], ifrLayer.scale);
    return this.nextVersionString;
  }
  static migratePosingLayer(layer, state) {
    const posingLayer = layer;
    posingLayer.posingData = { ...new PosingData(), ...posingLayer.posingData };
    let posingData = posingLayer.posingData;
    if (posingData.real3DViewMeterPerPixel == void 0) {
      const posingModel = posingLayer.posingModel;
      const radiusPx = posingData.headLocationInputData.radius;
      const real2DViewWidth = posingData.real3DViewHalfWidth / posingModel.headSphereSize * radiusPx;
      posingData.real3DViewMeterPerPixel = posingData.real3DViewHalfWidth * 2 / real2DViewWidth;
    }
    posingLayer.posingModel = state.modelFile.posingModelDictionary.get("dummy_skin");
    return this.nextVersionString;
  }
}
DocumentMigration_v00_01_01.currentVersionString = "0.1.1";
DocumentMigration_v00_01_01.nextVersionString = "0.1.2";
class DocumentMigration_v00_01_02 {
  static matches(versionString) {
    return versionString == this.currentVersionString;
  }
  static pass() {
    return this.nextVersionString;
  }
  static migrateVectorLayer(layer) {
    const vectorLayer = layer;
    if (vectorLayer.fillAreaType == FillAreaTypeID.none) {
      for (const keyframe of vectorLayer.keyframes) {
        for (const unit of keyframe.geometry.units) {
          for (const group of unit.groups) {
            group["type"] = 2;
          }
        }
      }
      return this.nextVersionString;
    }
    vectorLayer.type = LayerTypeID.surroundingFillLayer;
    for (const keyframe of vectorLayer.keyframes) {
      for (const unit of keyframe.geometry.units) {
        const parted_stroke_groups = [];
        for (const group of unit.groups) {
          let continued_strokes = [];
          for (const stroke of group.lines) {
            continued_strokes.push(stroke);
            if (!stroke["continuousFill"] && continued_strokes.length > 0) {
              parted_stroke_groups.push(continued_strokes);
              continued_strokes = [];
            }
          }
          if (continued_strokes.length > 0) {
            parted_stroke_groups.push(continued_strokes);
          }
        }
        const new_groupes = [];
        for (const strokes of parted_stroke_groups) {
          const new_group = new VectorStrokeGroup();
          new_group.lines = strokes;
          for (const stroke of strokes) {
            if (stroke["continuousFill"] != void 0) {
              delete stroke["continuousFill"];
            }
          }
          new_groupes.push(new_group);
        }
        unit.groups = new_groupes;
      }
    }
    return this.nextVersionString;
  }
}
DocumentMigration_v00_01_02.currentVersionString = "0.1.2";
DocumentMigration_v00_01_02.nextVersionString = "0.1.3";
class DocumentMigration_v00_01_03 {
  static matches(versionString) {
    return versionString == this.currentVersionString;
  }
  static migrateVectorLayer(layer) {
    const vectorLayer = layer;
    for (const keyframe of vectorLayer.keyframes) {
      if (layer.type == LayerTypeID.vectorLayer) {
        keyframe.geometry.type = VectorLayerGeometryTypeID.strokes;
      } else if (layer.type == LayerTypeID.surroundingFillLayer || layer.type == LayerTypeID.autoFillLayer) {
        keyframe.geometry.type = VectorLayerGeometryTypeID.surroundingFill;
      } else if (layer.type == LayerTypeID.pointBrushFillLayer) {
        keyframe.geometry.type = VectorLayerGeometryTypeID.pointBrushFill;
      }
      for (const unit of keyframe.geometry.units) {
        for (const group of unit.groups) {
          if ("type" in group) {
            delete group["type"];
          }
        }
      }
    }
    return this.nextVersionString;
  }
  static migrateAutoFillLayer(layer) {
    const autoFillLayer = layer;
    for (const keyframe of autoFillLayer.keyframes) {
      keyframe.geometry.type = VectorLayerGeometryTypeID.surroundingFill;
      for (const unit of keyframe.geometry.units) {
        for (const group of unit.groups) {
          if ("type" in group) {
            delete group["type"];
          }
        }
      }
    }
    return this.nextVersionString;
  }
}
DocumentMigration_v00_01_03.currentVersionString = "0.1.3";
DocumentMigration_v00_01_03.nextVersionString = "0.1.4";
class DocumentDeserializingLogic {
  static fixLoadedDocumentData(documentData, state) {
    this.registerLayerRecursive(documentData.rootLayer, state);
    let curentVersionString = documentData.version;
    this.fixDocumentData(documentData);
    this.fixLayer_Recursive(curentVersionString, documentData.rootLayer, null, state);
    documentData.version = DocumentData.versionString;
  }
  static registerLayerRecursive(layer, state) {
    state.registerLayerToDeserialize(layer);
    for (const childLayer of layer.childLayers) {
      this.registerLayerRecursive(childLayer, state);
    }
  }
  static fixDocumentData(documentData) {
    if (documentData.version == void 0) {
      documentData.version = "0.1.1";
    }
    {
      let curentVersionString = documentData.version;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migrateDocumentData(documentData);
      }
    }
    const template_DocumentData = new DocumentData();
    this.copyDefaultValue(documentData, template_DocumentData, "animationSettingData");
    this.copyDefaultValue(documentData, template_DocumentData, "defaultViewScale");
    this.copyDefaultValue(documentData, template_DocumentData, "lineWidthBiasRate");
    this.copyDefaultValue(documentData, template_DocumentData, "documentFrame_HideOuterArea");
    this.copyDefaultValue(documentData, template_DocumentData, "exportImageSetting");
    this.copyDefaultValue(documentData.animationSettingData, template_DocumentData.animationSettingData, "onionSkinMode");
    this.copyDefaultValue(documentData.animationSettingData, template_DocumentData.animationSettingData, "onionSkinForwardLevel");
    this.copyDefaultValue(documentData.animationSettingData, template_DocumentData.animationSettingData, "onionSkinBackwardLevel");
  }
  static copyDefaultValue(targetData, templateData, propertyName) {
    if (targetData[propertyName] == void 0) {
      targetData[propertyName] = templateData[propertyName];
    }
  }
  static fixLayer_Recursive(versionString, layer, parentLayer, state) {
    layer.hashID = Layer.getHashID();
    {
      let curentVersionString = versionString;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migrateLayer(layer);
      }
    }
    if (VectorLayer.isVectorLayerWithOwnData(layer)) {
      let curentVersionString = versionString;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migrateVectorLayer(layer, state);
      }
      if (DocumentMigration_v00_01_02.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_02.migrateVectorLayer(layer);
      }
      if (DocumentMigration_v00_01_03.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_03.migrateVectorLayer(layer);
      }
      this.setRuntimePropertiesForVectorLayer(layer, state);
      this.setRuntimePropertiesForVectorLayerContents(layer);
    } else if (AutoFillLayer.isAutoFillLayer(layer)) {
      let curentVersionString = versionString;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migrateAutoFillLayer(layer);
      }
      if (DocumentMigration_v00_01_02.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_02.pass();
      }
      if (DocumentMigration_v00_01_03.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_03.migrateAutoFillLayer(layer);
      }
      this.setRuntimePropertiesForAutoFillLayer(layer);
    } else if (VectorLayerReferenceLayer.isVectorLayerReferenceLayer(layer)) {
      this.setRuntimePropertiesForVectorLayer(layer, state);
      this.setRuntimePropertiesForVectorLayerReferenceLayer(layer, state);
    } else if (ImageFileReferenceLayer.isImageFileReferenceLayer(layer)) {
      let curentVersionString = versionString;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migrateImageFileReferenceLayer(layer, state);
      }
      this.setRuntimePropertiesForImageFileReferenceLayer(layer);
    } else if (PosingLayer.isPosingLayer(layer)) {
      let curentVersionString = versionString;
      if (DocumentMigration_v00_01_01.matches(curentVersionString)) {
        curentVersionString = DocumentMigration_v00_01_01.migratePosingLayer(layer, state);
      }
      this.setRuntimePropertiesForPosingLayer(layer);
    }
    if (!layer.runtime) {
      layer.runtime = new Layer_RuntimeProperty();
    }
    layer.runtime.parentLayer = parentLayer;
    for (const childLayer of layer.childLayers) {
      this.fixLayer_Recursive(versionString, childLayer, layer, state);
    }
  }
  static setRuntimePropertiesForVectorLayer(layer, state) {
    const vectorLayer = layer;
    vectorLayer.runtime = new VectorLayer_RuntimeProperty();
    if (vectorLayer.posingLayerID) {
      vectorLayer.runtime.posingLayer = state.layerDictionary.get(vectorLayer.posingLayerID);
      delete vectorLayer.posingLayerID;
      Layer.setLazyUpdateNeeded(vectorLayer);
    }
  }
  static setRuntimePropertiesForVectorLayerContents(layer) {
    const vectorLayer = layer;
    for (const keyframe of vectorLayer.keyframes) {
      this.setRuntimePropertiesForVectorLayerGeometry(keyframe.geometry, vectorLayer.lineWidthBiasRate);
    }
  }
  static setRuntimePropertiesForVectorLayerGeometry(geometry, lineWidthBiasRate) {
    geometry.runtime = new VectorLayerGeometry_RuntimeProperty();
    geometry.runtime.needsPostUpdate = false;
    geometry.runtime.area.setMinimumValue();
    for (const unit of geometry.units) {
      unit.modifyFlag = VectorStrokeDrawingUnitModifyFlagID.none;
      for (const group of unit.groups) {
        group.runtime = new VectorStrokeGroup_RuntimeProperty();
        VectorStrokeGroup.setLazyUpdateNeeded(group);
        for (const stroke of group.lines) {
          stroke.runtime = new VectorStroke_RuntimeProperty();
          for (const point of stroke.points) {
            point.modifyFlag = VectorPointModifyFlagID.none;
            if (point.v !== void 0) {
              point.location = vec3.fromValues(point.v[0], point.v[1], 0);
              point.lineWidth = point.w;
              point.isSelected = point.s == 1;
              delete point.v;
              delete point.w;
              delete point.s;
            }
            point.tempLocation = vec3.create();
            point.adjustingLocation = vec3.clone(point.location);
            point.adjustingLineWidth = point.lineWidth;
            point.adjustingLengthFrom = 1;
            point.adjustingLengthTo = 0;
            point.totalLength = 0;
            point.curvature = 0;
            point.location3D = vec3.create();
          }
          VectorStrokeLogic.calculateParameters(stroke, lineWidthBiasRate);
        }
        VectorStrokeLogic.calculateSurroundingArea(group.runtime.area, group.lines);
        group.runtime.connectionInfos = VectorStrokeLogic.createConnectionInfos(group);
        geometry.runtime.area.expandByRectangle(group.runtime.area);
      }
      geometry.runtime.area.calculateParams();
    }
  }
  static setRuntimePropertiesForVectorLayerReferenceLayer(layer, state) {
    const ifrLayer = layer;
    ifrLayer.runtime = new VectorLayerReferenceLayer_RuntimeProperty();
    if (ifrLayer.referenceLayerID) {
      ifrLayer.runtime.referenceLayer = state.layerDictionary.get(ifrLayer.referenceLayerID);
      delete ifrLayer.referenceLayerID;
    }
  }
  static setRuntimePropertiesForImageFileReferenceLayer(layer) {
    const ifrLayer = layer;
    ifrLayer.runtime = new ImageFileReferenceLayer_RuntimeProperty();
    vec3.copy(ifrLayer.runtime.adjustingLocation, ifrLayer.location);
    vec3.copy(ifrLayer.runtime.adjustingRotation, ifrLayer.rotation);
    vec3.copy(ifrLayer.runtime.adjustingScale, ifrLayer.scale);
  }
  static setRuntimePropertiesForAutoFillLayer(layer) {
    const autoFillLayer = layer;
    autoFillLayer.runtime = new Layer_RuntimeProperty();
    Layer.setLazyUpdateNeeded(autoFillLayer);
    for (const keyframe of autoFillLayer.keyframes) {
      this.setRuntimePropertiesForVectorLayerGeometry(keyframe.geometry, 1);
    }
  }
  static setRuntimePropertiesForPosingLayer(layer) {
    const posingLayer = layer;
    posingLayer.runtime = new PosingLayer_RuntimeProperty();
  }
  static finishResourceLoading(documentData) {
    this.finishResourceLoading_Recursive(documentData.rootLayer);
  }
  static finishResourceLoading_Recursive(layer) {
    if (ImageFileReferenceLayer.isImageFileReferenceLayer(layer)) {
      const ifrLayer = layer;
      ifrLayer.imageFirstLoading = false;
    }
    for (const childLayer of layer.childLayers) {
      this.finishResourceLoading_Recursive(childLayer);
    }
  }
}
class EditAnimationFrameLogic {
  static isAnimatableLayer(layer) {
    return VectorLayer.isVectorLayerWithOwnData(layer) || AutoFillLayer.isAutoFillLayer(layer);
  }
  static findLastKeyframeDataIndex(keyframes, targetFrame) {
    let keyframeIndex = -1;
    for (let index2 = 0; index2 < keyframes.length; index2++) {
      const keyframe = keyframes[index2];
      if (keyframe.frame > targetFrame) {
        break;
      }
      keyframeIndex = index2;
    }
    return keyframeIndex;
  }
  static findLastKeyframeData(keyframes, targetFrame) {
    const keyframeIndex = EditAnimationFrameLogic.findLastKeyframeDataIndex(keyframes, targetFrame);
    if (keyframeIndex == -1) {
      return null;
    }
    return keyframes[keyframeIndex];
  }
  static moveKeyframeData(currentViewKeyframe, previousKeyframe, nextKeyframe, moveForward) {
    if (currentViewKeyframe == null) {
      return;
    }
    let add_FrameTime = 1;
    if (!moveForward) {
      add_FrameTime = -1;
    }
    let newFrame = currentViewKeyframe.frame + add_FrameTime;
    if (newFrame < 0) {
      newFrame = 0;
    }
    if (add_FrameTime > 0 && nextKeyframe != null && newFrame >= nextKeyframe.frame) {
      newFrame = nextKeyframe.frame - 1;
    }
    if (add_FrameTime < 0 && previousKeyframe != null && newFrame <= previousKeyframe.frame) {
      newFrame = previousKeyframe.frame + 1;
    }
    if (currentViewKeyframe.frame != newFrame) {
      for (const viewKeyFrameLayer of currentViewKeyframe.layers) {
        if (viewKeyFrameLayer.hasKeyframe()) {
          if (viewKeyFrameLayer.vectorLayerKeyframe != null) {
            viewKeyFrameLayer.vectorLayerKeyframe.frame = newFrame;
          }
          if (viewKeyFrameLayer.autoFillLayerKeyframe != null) {
            viewKeyFrameLayer.autoFillLayerKeyframe.frame = newFrame;
          }
        }
      }
      currentViewKeyframe.frame = newFrame;
      return true;
    }
    return false;
  }
  static processInsertKeyframeData(layer, targetFrame, createKeyframeFunc) {
    const keyframeIndex = EditAnimationFrameLogic.findLastKeyframeDataIndex(layer.keyframes, targetFrame);
    if (keyframeIndex == -1) {
      return;
    }
    const last_KeyFrame = layer.keyframes[keyframeIndex];
    if (last_KeyFrame.frame == targetFrame) {
      return;
    }
    const newKeyframe = createKeyframeFunc(last_KeyFrame);
    newKeyframe.frame = targetFrame;
    const newKeyFrames = Lists.clone(layer.keyframes);
    if (keyframeIndex + 1 < newKeyFrames.length) {
      Lists.insertAt(newKeyFrames, keyframeIndex + 1, newKeyframe);
    } else {
      newKeyFrames.push(newKeyframe);
    }
    return newKeyFrames;
  }
  static changeAnimationMaxFrame(aniSetting, moveForward) {
    let add_FrameTime = 1;
    if (!moveForward) {
      add_FrameTime = -1;
    }
    aniSetting.maxFrame += add_FrameTime;
    if (aniSetting.maxFrame < 0) {
      aniSetting.maxFrame = 0;
    }
    if (aniSetting.maxFrame > 1e4) {
      aniSetting.maxFrame = 1e4;
    }
  }
  static changeLoopStartFrame(aniSetting, moveForward) {
    let add_FrameTime = 1;
    if (!moveForward) {
      add_FrameTime = -1;
    }
    aniSetting.loopStartFrame += add_FrameTime;
    if (aniSetting.loopStartFrame > aniSetting.loopEndFrame) {
      aniSetting.loopStartFrame = aniSetting.loopEndFrame;
    }
    if (aniSetting.loopStartFrame < 0) {
      aniSetting.loopStartFrame = 0;
    }
  }
  static changeLoopEndFrame(aniSetting, moveForward) {
    let add_FrameTime = 1;
    if (!moveForward) {
      add_FrameTime = -1;
    }
    aniSetting.loopEndFrame += add_FrameTime;
    if (aniSetting.loopEndFrame < aniSetting.loopStartFrame) {
      aniSetting.loopEndFrame = aniSetting.loopStartFrame;
    }
    if (aniSetting.loopEndFrame < 0) {
      aniSetting.loopEndFrame = 0;
    }
  }
}
class EyesSymmetryLogic {
  static updateEyesSymetries(vectorLayer, geometry, posing3DLogic, posing3DView) {
    if (!(VectorLayer.isVectorLayerWithOwnData(vectorLayer) && vectorLayer.eyesSymmetryEnabled)) {
      return;
    }
    let existsUpdate = false;
    VectorLayerGeometry.forEachGroup(geometry, (group) => {
      if (group.runtime.needsLazyUpdate) {
        existsUpdate = true;
      }
    });
    if (!existsUpdate) {
      return;
    }
    const posingData = vectorLayer.runtime.posingLayer.posingData;
    posing3DView.caluculateCameraMatrix(posingData);
    posing3DLogic.getEyeSphereLocation(this.eyeLocation, posingData, vectorLayer.eyesSymmetryInputSide);
    mat4.invert(this.invMatrix, posingData.headMatrix);
    mat4.identity(this.mirrorMatrix);
    mat4.scale(this.mirrorMatrix, this.mirrorMatrix, vec3.set(this.tempVec3, -1, 1, 1));
    mat4.multiply(this.tempMat4, posingData.headMatrix, this.mirrorMatrix);
    mat4.multiply(this.oppositeTransformMatrix, this.tempMat4, this.invMatrix);
    const eyeSize = posing3DLogic.getEyeSphereSize();
    vectorLayer.runtime.eyesSymmetryGeometry = new VectorLayerGeometry(VectorLayerGeometryTypeID.strokes);
    const drawingUnit = new VectorStrokeDrawingUnit();
    const strokeGroup = new VectorStrokeGroup();
    VectorLayerGeometry.forEachGroup(geometry, (group) => {
      if (!group.runtime.needsLazyUpdate) {
        return;
      }
      group.runtime.needsLazyUpdate = false;
      for (const stroke of group.lines) {
        const symmetryStroke = new VectorStroke();
        for (const point of stroke.points) {
          const hited = posing3DLogic.calculateInputLocation3DForDoubleSide(
            this.locationFront,
            this.locationBack,
            point.location,
            this.eyeLocation,
            eyeSize,
            posingData,
            posing3DView
          );
          if (hited) {
            vec3.copy(point.location3D, this.locationFront);
            const symmetryPoint = VectorPoint.clone(point);
            vec3.transformMat4(symmetryPoint.location3D, point.location3D, this.oppositeTransformMatrix);
            posing3DView.calculate2DLocationFrom3DLocation(symmetryPoint.location, symmetryPoint.location3D, posingData);
            vec3.copy(symmetryPoint.adjustingLocation, symmetryPoint.location);
            symmetryStroke.points.push(symmetryPoint);
          }
        }
        if (symmetryStroke.points.length > 0) {
          VectorStrokeLogic.calculateParameters(symmetryStroke, vectorLayer.lineWidthBiasRate);
          strokeGroup.lines.push(symmetryStroke);
        }
      }
    });
    drawingUnit.groups.push(strokeGroup);
    vectorLayer.runtime.eyesSymmetryGeometry.units.push(drawingUnit);
    const surroundingArea = RectangleArea.createMinumumValueRectangle();
    for (const unite of vectorLayer.runtime.eyesSymmetryGeometry.units) {
      for (const group of unite.groups) {
        VectorStrokeLogic.calculateSurroundingArea(group.runtime.area, group.lines);
        surroundingArea.expandByRectangle(group.runtime.area);
      }
    }
    surroundingArea.calculateParams();
    surroundingArea.copyTo(vectorLayer.runtime.eyesSymmetryGeometry.runtime.area);
  }
}
EyesSymmetryLogic.locationFront = vec3.create();
EyesSymmetryLogic.locationBack = vec3.create();
EyesSymmetryLogic.invMatrix = mat4.create();
EyesSymmetryLogic.mirrorMatrix = mat4.create();
EyesSymmetryLogic.oppositeTransformMatrix = mat4.create();
EyesSymmetryLogic.eyeLocation = vec3.create();
EyesSymmetryLogic.tempMat4 = mat4.create();
EyesSymmetryLogic.tempVec3 = vec3.create();
class DocumentFileNameLogic {
  static getDefaultDocumentFilePath(localSetting) {
    const date = new Date();
    const fileName = "" + date.getFullYear() + ("0" + (date.getMonth() + 1)).slice(-2) + ("0" + date.getDate()).slice(-2) + "_" + ("0" + this.fileNameCount).slice(-2);
    this.fileNameCount++;
    const filePath = Platform.path.join(localSetting.currentDirectoryPath, `${fileName}.v.ora`);
    return Platform.path.getPlatformIndependentPath(filePath);
  }
  static getExportFileName(filePath, autoNumberingEnabled, exportingCount) {
    let fileName = Platform.path.getFileName(filePath);
    const separatorDotIndex = Strings.indexOf(fileName, ".");
    if (separatorDotIndex != -1) {
      fileName = Strings.substring(fileName, 0, separatorDotIndex);
    }
    if (autoNumberingEnabled) {
      let maxLength = exportingCount.toString().length;
      if (maxLength < 2) {
        maxLength = 2;
      } else {
        maxLength = 4;
      }
      fileName += ("0".repeat(maxLength) + exportingCount).slice(-maxLength);
    }
    return fileName;
  }
  static getDocumentFileTypeFromName(filePath) {
    let fileType = DocumentFileType.json;
    if (Strings.lastIndexOf(filePath, ".json") == filePath.length - 5) {
      fileType = DocumentFileType.json;
    } else if (Strings.lastIndexOf(filePath, ".ora") == filePath.length - 4) {
      fileType = DocumentFileType.ora;
    }
    return fileType;
  }
  static getDocumentRelativeFilePath(documentFilePath, absoluteFilePath) {
    let relativeDir = Platform.path.getRelativePath(
      Platform.path.getDirectoryPath(documentFilePath),
      Platform.path.getDirectoryPath(absoluteFilePath)
    );
    return Platform.path.join(relativeDir, Platform.path.getFileName(absoluteFilePath));
  }
}
DocumentFileNameLogic.fileNameCount = 1;
class HierarchicalLayerInfo {
  constructor() {
    this.layer = null;
    this.children = null;
    this.parent = null;
  }
}
class LayerLogic {
  static collectLayers(parentLayer) {
    return this.collectLayersRecursive([], parentLayer);
  }
  static collectLayersRecursive(result, parentLayer) {
    for (const layer of parentLayer.childLayers) {
      result.push(layer);
      if (layer.childLayers.length > 0) {
        this.collectLayersRecursive(result, layer);
      }
    }
    return result;
  }
  static collectHierarchicalLayerInfoRecursive(result, parentLayer) {
    for (const layer of parentLayer.childLayers) {
      const info = new HierarchicalLayerInfo();
      info.layer = layer;
      info.parent = parentLayer;
      info.children = layer.childLayers;
      result.push(info);
      if (layer.childLayers.length > 0) {
        this.collectHierarchicalLayerInfoRecursive(result, layer);
      }
    }
  }
  static updateHierarchicalSelectRecursive(parentLayer) {
    for (const layer of parentLayer.childLayers) {
      layer.isSelected = Layer.isSelected(parentLayer);
      if (layer.childLayers.length > 0) {
        this.updateHierarchicalSelectRecursive(layer);
      }
    }
  }
  static updateHierarchicalStatesRecursive(parentLayer) {
    for (const layer of parentLayer.childLayers) {
      layer.runtime.isHierarchicalVisible = layer.isVisible && Layer.isVisible(parentLayer);
      layer.runtime.isHierarchicalListVisible = parentLayer.isListExpanded || parentLayer.runtime.isHierarchicalListVisible;
      if (layer.childLayers.length > 0) {
        this.updateHierarchicalStatesRecursive(layer);
      }
    }
  }
}
class RefferenceUpdating {
  constructor() {
    this.replacedReferenceInfos = [];
  }
  set(layer, oldReference, newReference) {
    this.replaceReferenceRecursive(layer, oldReference, newReference);
  }
  replaceReferenceRecursive(layer, oldReference, newReference) {
    if (EditAnimationFrameLogic.isAnimatableLayer(layer)) {
      const animatableLayer = layer;
      this.replaceProperty(animatableLayer, "keyframes", oldReference, newReference);
    }
    if (VectorLayer.isVectorLayerWithOwnData(layer)) {
      const vectorLayer = layer;
      this.replaceProperty(vectorLayer.runtime, "posingLayer", oldReference, newReference);
    } else if (VectorLayerReferenceLayer.isVectorLayerReferenceLayer(layer)) {
      const vRefLayer = layer;
      this.replaceProperty(vRefLayer.runtime, "referenceLayer", oldReference, newReference);
      this.replaceProperty(vRefLayer, "keyframes", oldReference, newReference);
    }
    for (const child of layer.childLayers) {
      this.replaceReferenceRecursive(child, oldReference, newReference);
    }
  }
  replaceProperty(target, propertyKeyName, oldReference, newReference) {
    const propertyName = String(propertyKeyName);
    if (propertyName in target && target[propertyName] == oldReference) {
      this.replacedReferenceInfos.push(
        {
          propertyName,
          target,
          oldReference: target[propertyName],
          newReference
        }
      );
      target[propertyName] = newReference;
    }
  }
  existsReplacedReference() {
    return this.replacedReferenceInfos.length > 0;
  }
  undoReplacedReferences() {
    for (const unlinkedLayerInfo of this.replacedReferenceInfos) {
      unlinkedLayerInfo.target[unlinkedLayerInfo.propertyName] = unlinkedLayerInfo.oldReference;
    }
  }
  redoReplacedReferences() {
    for (const unlinkedLayerInfo of this.replacedReferenceInfos) {
      unlinkedLayerInfo.target[unlinkedLayerInfo.propertyName] = unlinkedLayerInfo.newReference;
    }
  }
}
class VectorPointSelectionInfo {
  constructor() {
    this.point = null;
    this.selectStateAfter = false;
    this.selectStateBefore = false;
  }
}
class VectorStrokeSelectionInfo {
  constructor() {
    this.stroke = null;
    this.selectStateAfter = false;
    this.selectStateBefore = false;
  }
}
class VectorGroupSelectionInfo {
  constructor() {
    this.geometry = null;
    this.layer = null;
    this.group = null;
  }
}
class VectorLayerSelectionInfo {
  constructor() {
    this.selectedGroups = null;
    this.selectedStrokess = null;
    this.selectedPoints = null;
    this.clear();
  }
  clear() {
    this.selectedGroups = [];
    this.selectedStrokess = [];
    this.selectedPoints = [];
  }
  isGroupDone(group) {
    return group.runtime.modifyFlag != VectorStrokeGroupModifyFlagID.none;
  }
  isStrokeDone(stroke) {
    return stroke.runtime.modifyFlag != VectorStrokeModifyFlagID.none;
  }
  isPointDone(point) {
    return point.modifyFlag != VectorPointModifyFlagID.none;
  }
  selectPoint(stroke, point, editMode) {
    if (this.isPointDone(point)) {
      return;
    }
    if ((editMode == SelectionEditMode.setSelected || editMode == SelectionEditMode.toggle) && !point.isSelected) {
      const selPoint = new VectorPointSelectionInfo();
      selPoint.point = point;
      selPoint.selectStateAfter = true;
      selPoint.selectStateBefore = point.isSelected;
      this.selectedPoints.push(selPoint);
      point.isSelected = selPoint.selectStateAfter;
      point.modifyFlag = VectorPointModifyFlagID.unselectedToSelected;
      this.selectLine(stroke, editMode);
    } else if ((editMode == SelectionEditMode.setUnselected || editMode == SelectionEditMode.toggle) && point.isSelected) {
      const selPoint = new VectorPointSelectionInfo();
      selPoint.point = point;
      selPoint.selectStateAfter = false;
      selPoint.selectStateBefore = point.isSelected;
      this.selectedPoints.push(selPoint);
      point.isSelected = selPoint.selectStateAfter;
      point.modifyFlag = VectorPointModifyFlagID.selectedToUnselected;
      this.selectLine(stroke, editMode);
    }
  }
  selectLinePoints(stroke, editMode) {
    for (const point of stroke.points) {
      this.selectPoint(stroke, point, editMode);
    }
  }
  selectLine(stroke, editMode) {
    if (this.isStrokeDone(stroke)) {
      return;
    }
    const selInfo = new VectorStrokeSelectionInfo();
    selInfo.stroke = stroke;
    selInfo.selectStateBefore = stroke.isSelected;
    if (editMode == SelectionEditMode.setSelected) {
      selInfo.selectStateAfter = true;
      stroke.isSelected = true;
      stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.unselectedToSelected;
    } else if (editMode == SelectionEditMode.setUnselected) {
      selInfo.selectStateAfter = false;
      stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.selectedToUnselected;
    } else if (editMode == SelectionEditMode.toggle) {
      if (stroke.isSelected) {
        selInfo.selectStateAfter = false;
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.selectedToUnselected;
      } else {
        selInfo.selectStateAfter = true;
        stroke.isSelected = true;
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.unselectedToSelected;
      }
    }
    this.selectedStrokess.push(selInfo);
  }
  selectLinePointsForLines(editMode) {
    for (const selLineInfo of this.selectedStrokess) {
      for (const point of selLineInfo.stroke.points) {
        this.selectPoint(selLineInfo.stroke, point, editMode);
      }
    }
  }
  editGroup(group, geometry, layer) {
    if (this.isGroupDone(group)) {
      return;
    }
    const selInfo = new VectorGroupSelectionInfo();
    selInfo.layer = layer;
    selInfo.geometry = geometry;
    selInfo.group = group;
    this.selectedGroups.push(selInfo);
    geometry.runtime.modifyFlag = VectorLayerGeometryModifyFlagID.edit;
    group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.edit;
  }
  editStroke(stroke) {
    if (this.isStrokeDone(stroke)) {
      return;
    }
    const selInfo = new VectorStrokeSelectionInfo();
    selInfo.stroke = stroke;
    this.selectedStrokess.push(selInfo);
    stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.edit;
  }
  editPoint(point) {
    if (this.isPointDone(point)) {
      return;
    }
    const selInfo = new VectorPointSelectionInfo();
    selInfo.point = point;
    this.selectedPoints.push(selInfo);
    point.modifyFlag = VectorPointModifyFlagID.edit;
  }
  deletePoint(point) {
    if (this.isPointDone(point)) {
      return;
    }
    const selInfo = new VectorPointSelectionInfo();
    selInfo.point = point;
    this.selectedPoints.push(selInfo);
    point.modifyFlag = VectorPointModifyFlagID.delete;
  }
  updateLineSelectionState() {
    for (const selLineInfo of this.selectedStrokess) {
      let existsSelectedPoint = false;
      for (const point of selLineInfo.stroke.points) {
        if (point.isSelected) {
          existsSelectedPoint = true;
          break;
        }
      }
      selLineInfo.selectStateAfter = existsSelectedPoint;
      selLineInfo.stroke.isSelected = existsSelectedPoint;
    }
  }
  resetModifyStates() {
    for (const selGroup of this.selectedGroups) {
      if (selGroup.geometry.runtime.modifyFlag != VectorLayerGeometryModifyFlagID.delete) {
        selGroup.geometry.runtime.modifyFlag = VectorLayerGeometryModifyFlagID.none;
      }
      if (selGroup.group.runtime.modifyFlag != VectorStrokeGroupModifyFlagID.delete) {
        selGroup.group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.none;
      }
    }
    for (const selLine of this.selectedStrokess) {
      if (selLine.stroke.runtime.modifyFlag != VectorStrokeModifyFlagID.delete) {
        selLine.stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
      }
    }
    for (const selPoint of this.selectedPoints) {
      if (selPoint.point.modifyFlag != VectorPointModifyFlagID.delete) {
        selPoint.point.modifyFlag = VectorPointModifyFlagID.none;
      }
    }
  }
  existsSelected() {
    return this.selectedGroups.length > 0 || this.selectedStrokess.length > 0 || this.selectedPoints.length > 0;
  }
}
var SelectionEditMode = /* @__PURE__ */ ((SelectionEditMode2) => {
  SelectionEditMode2[SelectionEditMode2["none"] = 0] = "none";
  SelectionEditMode2[SelectionEditMode2["setSelected"] = 1] = "setSelected";
  SelectionEditMode2[SelectionEditMode2["setUnselected"] = 2] = "setUnselected";
  SelectionEditMode2[SelectionEditMode2["toggle"] = 3] = "toggle";
  return SelectionEditMode2;
})(SelectionEditMode || {});
class Selector_VectorPoint_BrushSelect extends HitTest_VectorPoint_PointToPoint {
  constructor() {
    super(...arguments);
    this.editMode = 0;
    this.selectionInfo = new VectorLayerSelectionInfo();
  }
  beforeHitTest() {
    this.selectionInfo.clear();
  }
  onPointHited(point) {
    this.selectionInfo.selectPoint(this.currentStroke, point, this.editMode);
  }
  afterHitTest() {
    this.selectionInfo.updateLineSelectionState();
    this.resetModifyStates();
  }
  resetModifyStates() {
    this.selectionInfo.resetModifyStates();
  }
}
class Selector_VectorStroke_BrushSelect extends HitTest_VectorStroke_PointToStroke {
  constructor() {
    super(...arguments);
    this.editMode = 0;
    this.selectionInfo = new VectorLayerSelectionInfo();
  }
  beforeHitTest() {
    this.selectionInfo.clear();
  }
  onLineSegmentHited(_point1, _point2, _location, _minDistanceSQ, _distanceSQ) {
    this.selectionInfo.selectLine(this.currentStroke, this.editMode);
    this.existsPointHitTest = true;
  }
  afterHitTest() {
    this.selectionInfo.selectLinePointsForLines(this.editMode);
    this.selectionInfo.updateLineSelectionState();
    this.selectionInfo.resetModifyStates();
  }
}
class Selector_StrokeSegment_BrushSelect extends HitTest_VectorStroke_PointToStroke {
  constructor() {
    super(...arguments);
    this.editMode = 0;
    this.selectionInfo = new VectorLayerSelectionInfo();
  }
  beforeHitTest() {
    this.selectionInfo.clear();
  }
  onLineSegmentHited(point1, point2, _location, _minDistanceSQ, _distanceSQ) {
    this.selectionInfo.selectPoint(this.currentStroke, point1, this.editMode);
    this.selectionInfo.selectPoint(this.currentStroke, point2, this.editMode);
  }
  afterHitTest() {
    this.selectionInfo.updateLineSelectionState();
    this.selectionInfo.resetModifyStates();
  }
  resetModifyStates() {
    this.selectionInfo.resetModifyStates();
  }
}
class DocumentDataSerializingState {
  constructor() {
    this.layers = [];
    this.infileLayerID = 0;
    this.layerDictionary = /* @__PURE__ */ new Map();
    this.modelFile = null;
  }
  registerLayerToSerialize(layer) {
    layer.ID = this.infileLayerID;
    this.layers.push(layer);
    this.infileLayerID++;
  }
  registerLayerToDeserialize(layer) {
    if (layer.ID === void 0) {
      return;
    }
    this.layerDictionary.set(layer.ID, layer);
    delete layer.ID;
  }
}
class DocumentSerializingLogic {
  static vec3ToArray(vec) {
    return [vec[0], vec[1], vec[2]];
  }
  static vec4ToArray(vec) {
    return [vec[0], vec[1], vec[2], vec[3]];
  }
  static duplicateDocumentDataForSave(documentData, save_filePath) {
    const state = new DocumentDataSerializingState();
    this.setIDRecursive(documentData.rootLayer, state);
    this.copyIDRecursive(documentData.rootLayer, state);
    const result_documentData = JSON.parse(this.stringifyDocumentData(documentData));
    this.fixLayersRecursive(result_documentData.rootLayer, save_filePath, state);
    for (const paletteColor of result_documentData.paletteColors) {
      delete paletteColor.isSelected;
      paletteColor.color = this.vec4ToArray(paletteColor.color);
    }
    return result_documentData;
  }
  static stringifyDocumentData(documentData) {
    const ignore_key_imageData = "imageData";
    const ignore_key_runtime = "runtime";
    const ignore_key_parentLayer = "parentLayer";
    return JSON.stringify(documentData, (key, value) => {
      if (key == ignore_key_parentLayer || key == ignore_key_imageData || key == ignore_key_runtime) {
        return null;
      } else {
        return value;
      }
    });
  }
  static setIDRecursive(layer, state) {
    state.registerLayerToSerialize(layer);
    for (const childLayer of layer.childLayers) {
      this.setIDRecursive(childLayer, state);
    }
  }
  static copyIDRecursive(layer, state) {
    if (VectorLayer.isVectorLayerWithOwnData(layer)) {
      const vectorLayer = layer;
      if (vectorLayer.runtime.posingLayer != null) {
        vectorLayer.posingLayerID = vectorLayer.runtime.posingLayer.ID;
      }
    } else if (VectorLayerReferenceLayer.isVectorLayerReferenceLayer(layer)) {
      const vRefLayer = layer;
      if (vRefLayer.runtime.referenceLayer != null) {
        vRefLayer.referenceLayerID = vRefLayer.runtime.referenceLayer.ID;
      }
    }
    for (const childLayer of layer.childLayers) {
      this.copyIDRecursive(childLayer, state);
    }
  }
  static fixLayersRecursive(layer, save_filePath, state) {
    delete layer.hashID;
    delete layer.runtime;
    layer.layerColor = this.vec4ToArray(layer.layerColor);
    if (VectorLayer.isVectorLayerWithOwnData(layer)) {
      const vectorLayer = layer;
      vectorLayer.fillColor = this.vec4ToArray(vectorLayer.fillColor);
      delete vectorLayer.runtime;
      for (const keyframe of vectorLayer.keyframes) {
        const geometry = keyframe.geometry;
        delete geometry.runtime;
        for (const unit of geometry.units) {
          delete unit.modifyFlag;
          for (const group of unit.groups) {
            delete group.runtime;
            for (const line of group.lines) {
              delete line.runtime;
              for (const point of line.points) {
                point.v = this.vec3ToArray(point.location);
                point.w = point.lineWidth;
                point.s = point.isSelected ? 1 : 0;
                delete point.location;
                delete point.lineWidth;
                delete point.isSelected;
                delete point.modifyFlag;
                delete point.tempLocation;
                delete point.adjustingLocation;
                delete point.adjustingLineWidth;
                delete point.adjustingLengthFrom;
                delete point.adjustingLengthTo;
                delete point.totalLength;
                delete point.curvature;
                delete point.location3D;
              }
            }
          }
        }
      }
    } else if (VectorLayerReferenceLayer.isVectorLayerReferenceLayer(layer)) {
      const vRefLayer = layer;
      delete vRefLayer.keyframes;
    } else if (AutoFillLayer.isAutoFillLayer(layer))
      ;
    else if (ImageFileReferenceLayer.isImageFileReferenceLayer(layer)) {
      const ifrLayer = layer;
      ifrLayer.imageFilePath = DocumentFileNameLogic.getDocumentRelativeFilePath(save_filePath, ifrLayer.imageFilePath);
      ifrLayer.location = this.vec3ToArray(ifrLayer.location);
      ifrLayer.rotation = this.vec3ToArray(ifrLayer.rotation);
      ifrLayer.scale = this.vec3ToArray(ifrLayer.scale);
      delete ifrLayer.runtime;
    } else if (PosingLayer.isPosingLayer(layer)) {
      const posingLayer = layer;
      delete posingLayer.posingData.bodyLocationInputData.parentMatrix;
      delete posingLayer.posingData.bodyLocationInputData.hitTestSphereRadius;
    }
    for (const childLayer of layer.childLayers) {
      this.fixLayersRecursive(childLayer, save_filePath, state);
    }
  }
  static releaseDocumentResources(documentData, render) {
    this.releaseDocumentResources_Recursive(documentData.rootLayer, render);
  }
  static releaseDocumentResources_Recursive(layer, render) {
    if (VectorLayer.isVectorLayerWithOwnData(layer)) {
      const vectorLayer = layer;
      for (const keyframe of vectorLayer.keyframes) {
        for (const unit of keyframe.geometry.units) {
          for (const group of unit.groups) {
            if (group.runtime.buffer.buffer != null) {
              render.deleteBuffer(group.runtime.buffer.buffer);
              group.runtime.buffer.buffer = null;
            }
          }
        }
      }
    }
    for (const childLayer of layer.childLayers) {
      this.releaseDocumentResources_Recursive(childLayer, render);
    }
  }
}
class CommandBase {
  constructor() {
    this.isContinued = false;
    this.defferedProcess = new DefferedProcessFlagging();
    this.refferenceUpdate = new RefferenceUpdating();
  }
  execute(_ctx) {
  }
  undo(_ctx) {
  }
  redo(_ctx) {
  }
}
class Command_AddStroke extends CommandBase {
  constructor() {
    super(...arguments);
    this.layer = null;
    this.geometry = null;
    this.drawingUnit = null;
    this.group = null;
    this.stroke = null;
    this.addToTop = false;
    this.add_strokeGroup = null;
    this.add_drawingUnit = null;
  }
  setTarget(layer, geometry, drawingUnit, group, stroke) {
    this.layer = layer;
    this.geometry = geometry;
    this.drawingUnit = drawingUnit;
    this.group = group;
    this.stroke = stroke;
  }
  execute(ctx) {
    VectorStrokeLogic.calculateParameters(this.stroke, this.layer.lineWidthBiasRate);
    if (this.group == null) {
      if (this.drawingUnit == null) {
        this.add_drawingUnit = new VectorStrokeDrawingUnit();
        this.drawingUnit = this.add_drawingUnit;
      }
      this.add_strokeGroup = new VectorStrokeGroup();
      this.group = this.add_strokeGroup;
    }
    this.defferedProcess.addGroup(this.layer, this.group, PostUpdateSituationTypeID.changesObjectShapes);
    this.redo(ctx);
  }
  undo(_ctx) {
    if (this.add_drawingUnit != null) {
      this.geometry.units.pop();
    }
    if (this.add_strokeGroup != null) {
      this.drawingUnit.groups.pop();
    }
    if (this.addToTop) {
      Lists.removeAt(this.group.lines, 0);
    } else {
      this.group.lines.pop();
    }
    this.stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
  }
  redo(_ctx) {
    if (this.add_drawingUnit != null) {
      this.geometry.units.push(this.add_drawingUnit);
    }
    if (this.add_strokeGroup != null) {
      this.drawingUnit.groups.push(this.add_strokeGroup);
    }
    if (this.addToTop) {
      Lists.insertAt(this.group.lines, 0, this.stroke);
    } else {
      this.group.lines.push(this.stroke);
    }
    this.stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
  }
}
class Command_Animation_InsertKeyframeAllLayer extends CommandBase {
  constructor() {
    super(...arguments);
    this.frame = 0;
    this.rootLayer = null;
  }
  prepareEditData(ctx) {
    const layers = LayerLogic.collectLayers(ctx.documentData.rootLayer);
    const targetFrame = this.frame;
    for (const layer of layers) {
      if (!EditAnimationFrameLogic.isAnimatableLayer(layer)) {
        continue;
      }
      if (VectorLayer.isVectorLayer(layer)) {
        const vectorLayer = layer;
        const newKeyframes = EditAnimationFrameLogic.processInsertKeyframeData(
          vectorLayer,
          targetFrame,
          (last_KeyFrame) => {
            const newKeyframe = new VectorLayerKeyframe(VectorLayerGeometry.getGeometryTypeForLayer(layer));
            newKeyframe.geometry = JSON.parse(JSON.stringify(last_KeyFrame.geometry));
            return newKeyframe;
          }
        );
        this.refferenceUpdate.set(this.rootLayer, vectorLayer.keyframes, newKeyframes);
      } else if (AutoFillLayer.isAutoFillLayer(layer)) {
        const autoFillLayer = layer;
        const newKeyframes = EditAnimationFrameLogic.processInsertKeyframeData(
          autoFillLayer,
          targetFrame,
          (last_KeyFrame) => {
            const newKeyframe = new AutoFillLayerKeyframe();
            newKeyframe.groups = JSON.parse(JSON.stringify(last_KeyFrame.groups));
            newKeyframe.geometry = JSON.parse(JSON.stringify(last_KeyFrame.geometry));
            return newKeyframe;
          }
        );
        this.refferenceUpdate.set(this.rootLayer, autoFillLayer.keyframes, newKeyframes);
      }
    }
    return this.isAvailable(ctx);
  }
  isAvailable(_ctx) {
    return this.refferenceUpdate.existsReplacedReference();
  }
  execute(ctx) {
    ctx.updateLayerStructure();
  }
  undo(ctx) {
    this.refferenceUpdate.undoReplacedReferences();
    ctx.updateLayerStructure();
  }
  redo(ctx) {
    this.refferenceUpdate.redoReplacedReferences();
    ctx.updateLayerStructure();
  }
}
class Command_Animation_DeleteKeyframeAllLayer extends CommandBase {
  constructor() {
    super(...arguments);
    this.frame = 0;
    this.rootLayer = null;
  }
  prepareEditData(ctx) {
    const layers = LayerLogic.collectLayers(ctx.documentData.rootLayer);
    const targetFrame = this.frame;
    for (const layer of layers) {
      if (!VectorLayer.isVectorLayerWithOwnData(layer)) {
        continue;
      }
      const vectorLayer = layer;
      const keyframeIndex = EditAnimationFrameLogic.findLastKeyframeDataIndex(vectorLayer.keyframes, targetFrame);
      if (keyframeIndex == -1) {
        continue;
      }
      const last_KeyFrame = vectorLayer.keyframes[keyframeIndex];
      if (last_KeyFrame.frame != targetFrame) {
        continue;
      }
      const newKeyFrames = Lists.clone(vectorLayer.keyframes);
      Lists.removeAt(newKeyFrames, keyframeIndex);
      this.refferenceUpdate.set(this.rootLayer, vectorLayer.keyframes, newKeyFrames);
    }
    return this.isAvailable(ctx);
  }
  isAvailable(_ctx) {
    return this.refferenceUpdate.existsReplacedReference();
  }
  execute(ctx) {
    ctx.updateLayerStructure();
  }
  undo(ctx) {
    this.refferenceUpdate.undoReplacedReferences();
    ctx.updateLayerStructure();
  }
  redo(ctx) {
    this.refferenceUpdate.redoReplacedReferences();
    ctx.updateLayerStructure();
  }
}
const _Command_EditGeometry_ClipbardData = class {
  constructor() {
    this.data_version = _Command_EditGeometry_ClipbardData.data_version;
    this.copy_layers = [];
  }
};
let Command_EditGeometry_ClipbardData = _Command_EditGeometry_ClipbardData;
Command_EditGeometry_ClipbardData.data_version = "MTT_CLPBD_V001";
class Command_EditGeometry_CopyLayer {
  constructor() {
    this.name = "";
    this.drawingUnits = [];
  }
}
class Command_CopyGeometry extends CommandBase {
  constructor() {
    super(...arguments);
    this.copy_layers = null;
  }
  isAvailable(_ctx) {
    return this.copy_layers != null;
  }
  prepareEditData(ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    const copy_layers = [];
    for (const viewKeyframeLayer of viewKeyframeLayers) {
      if (!VectorLayer.isVectorLayer(viewKeyframeLayer.layer)) {
        continue;
      }
      const copy_units = [];
      for (const unit of viewKeyframeLayer.vectorLayerKeyframe.geometry.units) {
        const copy_groups = [];
        for (const group of unit.groups) {
          const copy_strokes = [];
          for (const stroke of group.lines) {
            if (!stroke.isSelected) {
              continue;
            }
            const copy_stroke = new VectorStroke();
            for (const point of stroke.points) {
              if (!point.isSelected) {
                continue;
              }
              copy_stroke.points.push(VectorPoint.clone(point));
            }
            if (copy_stroke.points.length > 0) {
              copy_strokes.push(copy_stroke);
            }
          }
          if (copy_strokes.length > 0) {
            const new_group = new VectorStrokeGroup();
            new_group.lines = copy_strokes;
            copy_groups.push(new_group);
          }
        }
        if (copy_groups.length > 0) {
          const new_unit = new VectorStrokeDrawingUnit();
          new_unit.groups = copy_groups;
          copy_units.push(new_unit);
        }
      }
      if (copy_units.length > 0) {
        const copy_layer = new Command_EditGeometry_CopyLayer();
        copy_layer.name = viewKeyframeLayer.layer.name;
        copy_layer.drawingUnits = copy_units;
        copy_layers.push(copy_layer);
      }
    }
    if (copy_layers.length > 0) {
      this.copy_layers = copy_layers;
      return true;
    } else {
      return false;
    }
  }
  execute(_ctx) {
    const clipboardData = new Command_EditGeometry_ClipbardData();
    clipboardData.copy_layers = this.copy_layers;
    Platform.clipboard.writeText(JSON.stringify(clipboardData)).then();
  }
}
class Command_EditGeometry_EditLayer {
  constructor() {
    this.targeLayer = null;
    this.targetGeometry = null;
    this.oldUnits = null;
    this.newUnits = [];
    this.targetGroup = null;
    this.oldStrokes = null;
    this.newStrokes = [];
  }
}
class Command_PasteGeometry extends CommandBase {
  constructor() {
    super(...arguments);
    this.editLayers = null;
    this.select_strokes = [];
  }
  isAvailable(_ctx) {
    return this.editLayers != null;
  }
  async prepareEditData(ctx) {
    if (!VectorLayer.isVectorLayerWithOwnData(ctx.currentLayer)) {
      return false;
    }
    const clipboardData = await this.getClipboardData();
    if (!clipboardData.isAvailable) {
      return false;
    }
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    const editLayers = [];
    const new_groups = [];
    const new_strokes = [];
    for (const copy_layer of clipboardData.copy_layers) {
      let target_viewKeyframeLayer = viewKeyframeLayers.find((viewKeyframeLayer) => viewKeyframeLayer.layer.isSelected && viewKeyframeLayer.layer.name == copy_layer.name);
      if (!target_viewKeyframeLayer) {
        target_viewKeyframeLayer = viewKeyframeLayers.find((viewKeyframeLayer) => viewKeyframeLayer.layer.isSelected);
      }
      const isAvailableToPaste = target_viewKeyframeLayer && VectorLayer.isVectorLayerWithOwnData(target_viewKeyframeLayer.layer);
      if (!isAvailableToPaste) {
        continue;
      }
      let editLayer = editLayers.find((editLayer2) => editLayer2.targeLayer == target_viewKeyframeLayer.layer);
      let isNewEditLayer = false;
      if (!editLayer) {
        editLayer = new Command_EditGeometry_EditLayer();
        editLayer.targeLayer = target_viewKeyframeLayer.layer;
        isNewEditLayer = true;
      }
      if (VectorLayer.isSurroundingFillLayer(target_viewKeyframeLayer.layer)) {
        if (isNewEditLayer) {
          editLayer.targetGeometry = target_viewKeyframeLayer.vectorLayerKeyframe.geometry;
          editLayer.oldUnits = editLayer.targetGeometry.units;
          Lists.addRange(editLayer.newUnits, editLayer.oldUnits);
        }
        Lists.addRange(editLayer.newUnits, copy_layer.drawingUnits);
        for (const unit of copy_layer.drawingUnits) {
          for (const group of unit.groups) {
            this.defferedProcess.addGroup(target_viewKeyframeLayer.layer, group, PostUpdateSituationTypeID.addObjects);
            this.calculateStrokeParameters(group.lines, target_viewKeyframeLayer.layer);
            new_groups.push(group);
            Lists.addRange(new_strokes, group.lines);
          }
        }
      } else {
        if (isNewEditLayer) {
          editLayer.targetGroup = target_viewKeyframeLayer.vectorLayerKeyframe.geometry.units[0].groups[0];
          editLayer.oldStrokes = editLayer.targetGroup.lines;
          Lists.addRange(editLayer.newStrokes, editLayer.oldStrokes);
        }
        for (const unit of copy_layer.drawingUnits) {
          for (const group of unit.groups) {
            this.calculateStrokeParameters(group.lines, target_viewKeyframeLayer.layer);
            Lists.addRange(editLayer.newStrokes, group.lines);
            new_groups.push(group);
            Lists.addRange(new_strokes, group.lines);
          }
        }
        this.defferedProcess.addGroup(target_viewKeyframeLayer.layer, editLayer.targetGroup, PostUpdateSituationTypeID.addObjects);
      }
      editLayers.push(editLayer);
      this.defferedProcess.addLayer(target_viewKeyframeLayer.layer);
    }
    for (const group of new_groups) {
      group.runtime = new VectorStrokeGroup_RuntimeProperty();
    }
    if (editLayers.length > 0) {
      this.editLayers = editLayers;
      this.select_strokes = new_strokes;
      return true;
    } else {
      return false;
    }
  }
  calculateStrokeParameters(strokes, layer) {
    const vectorLayer = layer;
    for (const stroke of strokes) {
      stroke.runtime = new VectorStroke_RuntimeProperty();
      VectorStrokeLogic.calculateParameters(stroke, vectorLayer.lineWidthBiasRate);
    }
  }
  async getClipboardData() {
    const availableFormats = await Platform.clipboard.availableFormats();
    if (availableFormats.length == 0 && availableFormats[0] != "text/plains") {
      return { isAvailable: false, copy_layers: null };
    }
    let copy_layers;
    try {
      const text = await Platform.clipboard.readText();
      const clipboardData = JSON.parse(text);
      const isAvailableData = clipboardData && clipboardData.data_version === Command_EditGeometry_ClipbardData.data_version && Array.isArray(clipboardData.copy_layers);
      if (!isAvailableData) {
        return { isAvailable: false, copy_layers: null };
      }
      copy_layers = clipboardData.copy_layers;
    } catch (e) {
      return { isAvailable: false, copy_layers: null };
    }
    return { isAvailable: true, copy_layers };
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editLayer of this.editLayers) {
      if (editLayer.targetGeometry) {
        editLayer.targetGeometry.units = editLayer.oldUnits;
      }
      if (editLayer.targetGroup) {
        editLayer.targetGroup.lines = editLayer.oldStrokes;
      }
    }
  }
  redo(_ctx) {
    for (const editLayer of this.editLayers) {
      if (editLayer.targetGeometry) {
        editLayer.targetGeometry.units = editLayer.newUnits;
      }
      if (editLayer.targetGroup) {
        editLayer.targetGroup.lines = editLayer.newStrokes;
      }
      for (const stroke of this.select_strokes) {
        stroke.isSelected = true;
        for (const point of stroke.points) {
          point.isSelected = true;
        }
      }
    }
  }
}
class Command_Layer_CommandBase extends CommandBase {
  constructor() {
    super(...arguments);
    this.rootLayer = null;
    this.currentLayer = null;
    this.currentLayerParent = null;
    this.currentLayerIndex = -1;
    this.previousLayer = null;
    this.previousLayerParent = null;
    this.previousLayerIndex = -1;
    this.nextLayer = null;
    this.nextLayerParent = null;
    this.nextLayerIndex = -1;
    this.removeFrom_ParentLayer = null;
    this.removeFrom_OldChildLayerList = null;
    this.removeFrom_NewChildLayerList = null;
    this.insertTo_ParentLayer = null;
    this.insertTo_Layer_OldChildLayerList = null;
    this.insertTo_Layer_NewChildLayerList = null;
    this.reselect_layer = null;
  }
  isAvailable(_ctx) {
    return false;
  }
  setPrameters(documentData, currentLayer, currentLayerParent, previousLayer, previousLayerParent, nextLayer, nextLayerParent) {
    this.rootLayer = documentData.rootLayer;
    this.currentLayer = currentLayer;
    this.currentLayerParent = currentLayerParent;
    this.currentLayerIndex = this.findChildLayerIndex(currentLayer);
    this.previousLayer = previousLayer;
    this.previousLayerParent = previousLayerParent;
    this.previousLayerIndex = this.findChildLayerIndex(previousLayer);
    this.nextLayer = nextLayer;
    this.nextLayerParent = nextLayerParent;
    this.nextLayerIndex = this.findChildLayerIndex(nextLayer);
    if (this.currentLayerIndex < 0 || this.currentLayerIndex >= currentLayerParent.childLayers.length) {
      throw new Error("ERROR 0000: Current layer index is invalid when setting command parameters");
    }
  }
  findChildLayerIndex(childLayer) {
    if (childLayer == null || childLayer.runtime.parentLayer == null) {
      return -1;
    }
    for (let i = 0; i < childLayer.runtime.parentLayer.childLayers.length; i++) {
      if (childLayer.runtime.parentLayer.childLayers[i] == childLayer) {
        return i;
      }
    }
    return -1;
  }
  isFirstChildLayer(parentLayer, childLayer) {
    return parentLayer.childLayers.length > 0 && parentLayer.childLayers[0] == childLayer;
  }
  isLastChildLayer(parentLayer, childLayer) {
    return parentLayer.childLayers.length > 0 && parentLayer.childLayers[parentLayer.childLayers.length - 1] == childLayer;
  }
  isContainerLayer(layer) {
    return Layer.isRootLayer(layer) || GroupLayer.isGroupLayer(layer);
  }
  executeLayerSwap(parentLayer, swapIndex1, swapIndex2, ctx) {
    if (swapIndex1 < 0 || swapIndex1 >= parentLayer.childLayers.length) {
      throw new Error("ERROR 0000: Index 1 is out of range when swapping layers");
    }
    if (swapIndex2 < 0 || swapIndex2 >= parentLayer.childLayers.length) {
      throw new Error("ERROR 0000: Index 2 is out of range when swapping layers");
    }
    this.insertTo_ParentLayer = parentLayer;
    this.insertTo_Layer_OldChildLayerList = parentLayer.childLayers;
    this.insertTo_Layer_NewChildLayerList = Lists.clone(parentLayer.childLayers);
    const swapItem = this.insertTo_Layer_NewChildLayerList[swapIndex1];
    this.insertTo_Layer_NewChildLayerList[swapIndex1] = this.insertTo_Layer_NewChildLayerList[swapIndex2];
    this.insertTo_Layer_NewChildLayerList[swapIndex2] = swapItem;
    parentLayer.childLayers = this.insertTo_Layer_NewChildLayerList;
    this.reselect_layer = swapItem;
  }
  executeLayerInsertToCurrent(layer, ctx) {
    let parentLayer;
    let insertIndex;
    if (GroupLayer.isGroupLayer(this.currentLayer)) {
      parentLayer = this.currentLayer;
      insertIndex = 0;
    } else {
      parentLayer = this.currentLayerParent;
      insertIndex = this.currentLayerIndex;
    }
    this.executeLayerInsert(parentLayer, insertIndex, layer, ctx);
  }
  executeLayerInsert(parentLayer, insertIndex, layer, ctx) {
    this.insertLayer(parentLayer, insertIndex, layer);
    this.reselect_layer = layer;
  }
  insertLayer(parentLayer, insertIndex, layer) {
    this.insertTo_ParentLayer = parentLayer;
    this.insertTo_Layer_OldChildLayerList = parentLayer.childLayers;
    this.insertTo_Layer_NewChildLayerList = Lists.clone(parentLayer.childLayers);
    if (insertIndex < this.insertTo_Layer_NewChildLayerList.length) {
      Lists.insertAt(this.insertTo_Layer_NewChildLayerList, insertIndex, layer);
    } else {
      this.insertTo_Layer_NewChildLayerList.push(layer);
    }
    parentLayer.childLayers = this.insertTo_Layer_NewChildLayerList;
    layer.runtime.parentLayer = parentLayer;
  }
  executeLayerRemove(parentLayer, removeIndex, ctx) {
    this.removeFrom_ParentLayer = parentLayer;
    this.removeFrom_OldChildLayerList = parentLayer.childLayers;
    this.removeFrom_NewChildLayerList = Lists.clone(parentLayer.childLayers);
    Lists.removeAt(this.removeFrom_NewChildLayerList, removeIndex);
    parentLayer.childLayers = this.removeFrom_NewChildLayerList;
    if (this.previousLayer != null) {
      this.reselect_layer = this.previousLayer;
    } else if (this.nextLayer != null) {
      this.reselect_layer = this.nextLayer;
    }
  }
  executeCurrentLayerRemove(ctx) {
    this.executeLayerRemove(this.currentLayerParent, this.currentLayerIndex, ctx);
  }
  undo(ctx) {
    if (this.insertTo_ParentLayer != null) {
      this.insertTo_ParentLayer.childLayers = this.insertTo_Layer_OldChildLayerList;
      ctx.unsetCurrentLayer();
    }
    if (this.removeFrom_ParentLayer != null) {
      this.removeFrom_ParentLayer.childLayers = this.removeFrom_OldChildLayerList;
    }
    this.refferenceUpdate.undoReplacedReferences();
    ctx.updateLayerStructure();
    ctx.tool.selectLayer(this.currentLayer);
    ctx.setRedrawMainWindowEditorWindow();
  }
  redo(ctx) {
    if (this.insertTo_ParentLayer != null) {
      this.insertTo_ParentLayer.childLayers = this.insertTo_Layer_NewChildLayerList;
    }
    if (this.removeFrom_ParentLayer != null) {
      this.removeFrom_ParentLayer.childLayers = this.removeFrom_NewChildLayerList;
      ctx.unsetCurrentLayer();
    }
    this.refferenceUpdate.redoReplacedReferences();
    ctx.updateLayerStructure();
    ctx.tool.selectLayer(this.reselect_layer);
    ctx.setRedrawMainWindowEditorWindow();
  }
}
class Command_Layer_CreateDefaultDocumentLayers extends Command_Layer_CommandBase {
  executeWithoutRedraw(documentData, ctx) {
    const rootLayer = documentData.rootLayer;
    rootLayer.type = LayerTypeID.rootLayer;
    {
      const layer1 = new VectorLayer();
      layer1.name = ctx.document.getNewLayerName(LayerTypeID.vectorLayer, true);
      layer1.runtime.parentLayer = rootLayer;
      const unit = new VectorStrokeDrawingUnit();
      unit.groups.push(new VectorStrokeGroup());
      const keyfarame = new VectorLayerKeyframe(VectorLayerGeometry.getGeometryTypeForLayer(layer1));
      keyfarame.geometry.units.push(unit);
      layer1.keyframes.push(keyfarame);
      this.insertLayer(rootLayer, 0, layer1);
    }
  }
}
class Command_Layer_AddVectorLayerToCurrentPosition extends Command_Layer_CommandBase {
  constructor() {
    super(...arguments);
    this.newLayer_layerType = LayerTypeID.none;
  }
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    switch (this.newLayer_layerType) {
      case LayerTypeID.vectorLayer:
        {
          const newLayer = new VectorLayer();
          newLayer.name = ctx.document.getNewLayerName(newLayer.type);
          newLayer.drawLineType = DrawLineTypeID.paletteColor;
          newLayer.fillAreaType = FillAreaTypeID.none;
          newLayer.keyframes.push(VectorLayerKeyframe.createWithDefaultGeometry(VectorLayerGeometryTypeID.strokes));
          this.executeLayerInsertToCurrent(newLayer, ctx);
        }
        break;
      case LayerTypeID.surroundingFillLayer:
        {
          const newLayer = new SurroundingFillLayer();
          newLayer.name = ctx.document.getNewLayerName(newLayer.type);
          newLayer.drawLineType = DrawLineTypeID.none;
          newLayer.fillAreaType = FillAreaTypeID.paletteColor;
          newLayer.keyframes.push(VectorLayerKeyframe.createWithDefaultGeometry(VectorLayerGeometryTypeID.surroundingFill));
          this.executeLayerInsertToCurrent(newLayer, ctx);
        }
        break;
      case LayerTypeID.pointBrushFillLayer:
        {
          const newLayer = new PointBrushFillLayer();
          newLayer.name = ctx.document.getNewLayerName(newLayer.type);
          newLayer.drawLineType = DrawLineTypeID.paletteColor;
          newLayer.fillAreaType = FillAreaTypeID.none;
          newLayer.keyframes.push(VectorLayerKeyframe.createWithDefaultGeometry(VectorLayerGeometryTypeID.pointBrushFill));
          this.executeLayerInsertToCurrent(newLayer, ctx);
        }
        break;
    }
    this.redo(ctx);
  }
}
class Command_Layer_AddVectorLayerReferenceLayerToCurrentPosition extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    if (!VectorLayer.isVectorLayerWithOwnData(this.currentLayer)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    const newLayer = new VectorLayerReferenceLayer();
    newLayer.name = ctx.document.getNewLayerName(newLayer.type);
    newLayer.runtime.referenceLayer = this.currentLayer;
    newLayer.keyframes = newLayer.runtime.referenceLayer.keyframes;
    this.executeLayerInsertToCurrent(newLayer, ctx);
    this.redo(ctx);
  }
}
class Command_Layer_AddAutoFillLayerToCurrentPosition extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    const newLayer = new AutoFillLayer();
    newLayer.name = ctx.document.getNewLayerName(newLayer.type);
    this.executeLayerInsertToCurrent(newLayer, ctx);
    this.redo(ctx);
  }
}
class Command_Layer_AddGroupLayerToCurrentPosition extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    const newLayer = new GroupLayer();
    newLayer.name = ctx.document.getNewLayerName(newLayer.type);
    this.executeLayerInsertToCurrent(newLayer, ctx);
    this.redo(ctx);
  }
}
class Command_Layer_AddImageFileReferenceLayerToCurrentPosition extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    const newLayer = new ImageFileReferenceLayer();
    newLayer.name = ctx.document.getNewLayerName(newLayer.type);
    this.executeLayerInsertToCurrent(newLayer, ctx);
    this.redo(ctx);
  }
}
class Command_Layer_AddPosingLayerToCurrentPosition extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (!this.isContainerLayer(this.currentLayerParent)) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    const newLayer = new PosingLayer();
    newLayer.name = ctx.document.getNewLayerName(newLayer.type);
    newLayer.posingModel = ctx.main.getPosingModelByName("dummy_skin");
    this.executeLayerInsertToCurrent(newLayer, ctx);
    this.redo(ctx);
  }
}
class Command_Layer_Delete extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    if (Layer.isRootLayer(this.currentLayerParent) && this.currentLayerParent.childLayers.length == 1) {
      return false;
    }
    return true;
  }
  execute(ctx) {
    this.executeCurrentLayerRemove(ctx);
    this.refferenceUpdate.set(this.rootLayer, this.currentLayer, null);
    this.redo(ctx);
  }
}
class Command_Layer_MoveUp extends Command_Layer_CommandBase {
  isAvailable(_ctx) {
    return this.getOperationType() != 0;
  }
  getOperationType() {
    if (this.currentLayerParent.type != LayerTypeID.rootLayer && this.isFirstChildLayer(this.currentLayerParent, this.currentLayer)) {
      return 1;
    }
    if (GroupLayer.isGroupLayer(this.previousLayer) && this.previousLayer.isListExpanded) {
      return 2;
    }
    if (this.previousLayerParent != null && this.previousLayerParent != this.currentLayerParent) {
      return 3;
    }
    if (this.previousLayerParent != null && this.previousLayerParent == this.currentLayerParent) {
      return 4;
    }
    return 0;
  }
  execute(ctx) {
    const operationType = this.getOperationType();
    switch (operationType) {
      case 1:
        this.executeCurrentLayerRemove(ctx);
        this.executeLayerInsert(this.currentLayerParent.runtime.parentLayer, this.findChildLayerIndex(this.currentLayerParent), this.currentLayer, ctx);
        break;
      case 2:
        this.executeCurrentLayerRemove(ctx);
        this.executeLayerInsert(this.previousLayer, this.previousLayer.childLayers.length, this.currentLayer, ctx);
        break;
      case 3:
        this.executeCurrentLayerRemove(ctx);
        this.executeLayerInsert(this.previousLayerParent, this.previousLayerParent.childLayers.length, this.currentLayer, ctx);
        break;
      case 4:
        this.executeLayerSwap(this.currentLayerParent, this.currentLayerIndex, this.currentLayerIndex - 1, ctx);
        break;
    }
    this.redo(ctx);
  }
}
class Command_Layer_MoveDown extends Command_Layer_MoveUp {
  isAvailable(_ctx) {
    return this.getOperationType() != 0;
  }
  getOperationType() {
    if (this.currentLayerParent.type != LayerTypeID.rootLayer && this.isLastChildLayer(this.currentLayerParent, this.currentLayer)) {
      return 1;
    }
    if (GroupLayer.isGroupLayer(this.nextLayer) && this.nextLayer.isListExpanded) {
      return 2;
    }
    if (this.nextLayerParent != null && this.nextLayerParent == this.currentLayerParent) {
      return 4;
    }
    return 0;
  }
  execute(ctx) {
    const operationType = this.getOperationType();
    switch (operationType) {
      case 1:
        this.executeCurrentLayerRemove(ctx);
        this.executeLayerInsert(this.currentLayerParent.runtime.parentLayer, this.findChildLayerIndex(this.currentLayerParent) + 1, this.currentLayer, ctx);
        break;
      case 2:
        this.executeCurrentLayerRemove(ctx);
        this.executeLayerInsert(this.nextLayer, 0, this.currentLayer, ctx);
        break;
      case 4:
        this.executeLayerSwap(this.currentLayerParent, this.currentLayerIndex, this.currentLayerIndex + 1, ctx);
        break;
    }
    this.redo(ctx);
  }
}
class Command_VectorLayer_SetProperty extends CommandBase {
  isAvailable(_ctx) {
    if (this.layer) {
      return true;
    }
    return false;
  }
  execute(ctx) {
    this.old_enableEyesSymmetry = ctx.currentVectorLayer.eyesSymmetryEnabled;
    this.old_eyesSymmetryInputSide = ctx.currentVectorLayer.eyesSymmetryInputSide;
    this.old_posingLayer = ctx.currentVectorLayer.runtime.posingLayer;
    this.redo(ctx);
  }
  undo(ctx) {
    this.layer.eyesSymmetryEnabled = this.old_enableEyesSymmetry;
    this.layer.eyesSymmetryInputSide = this.old_eyesSymmetryInputSide;
    this.layer.runtime.posingLayer = this.old_posingLayer;
    ctx.setRedrawLayerWindow();
  }
  redo(ctx) {
    if (this.new_enableEyesSymmetry !== void 0) {
      this.layer.eyesSymmetryEnabled = this.new_enableEyesSymmetry;
      ctx.setRedrawLayerWindow();
      ctx.setRedrawMainWindowEditorWindow();
    }
    if (this.new_eyesSymmetryInputSide !== void 0) {
      this.layer.eyesSymmetryInputSide = this.new_eyesSymmetryInputSide;
      ctx.setRedrawLayerWindow();
      ctx.setRedrawMainWindowEditorWindow();
    }
    if (this.new_posingLayer !== void 0) {
      this.layer.runtime.posingLayer = this.new_posingLayer;
      ctx.setRedrawLayerWindow();
      ctx.setRedrawMainWindowEditorWindow();
    }
  }
}
class Command_SetReferenceImageToLayer extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLayer = null;
    this.filePath = null;
    this.image = null;
    this.oldFilePath = null;
    this.oldAbsoluteFilePath = null;
    this.oldImage = null;
    this.oldLocation = vec3.fromValues(0, 0, 0);
    this.oldScale = vec3.fromValues(1, 1, 1);
    this.oldRotation = vec3.fromValues(0, 0, 0);
    this.newFilePath = null;
    this.newAbsoluteFilePath = null;
    this.newImage = null;
    this.newLocation = vec3.fromValues(0, 0, 0);
    this.newScale = vec3.fromValues(1, 1, 1);
    this.newRotation = vec3.fromValues(0, 0, 0);
  }
  execute(ctx) {
    this.oldFilePath = this.targetLayer.imageFilePath;
    this.oldAbsoluteFilePath = this.targetLayer.runtime.imageResource.filePath;
    this.oldImage = this.targetLayer.runtime.imageResource.image.imageData;
    vec3.copy(this.oldLocation, this.targetLayer.location);
    vec3.copy(this.oldScale, this.targetLayer.scale);
    vec3.copy(this.oldRotation, this.targetLayer.rotation);
    this.newFilePath = DocumentFileNameLogic.getDocumentRelativeFilePath(ctx.documentFilePath, this.filePath);
    this.newAbsoluteFilePath = this.filePath;
    this.newImage = this.image;
    vec3.set(this.newLocation, -this.newImage.width / 2, -this.newImage.height / 2, 0);
    vec3.copy(this.oldLocation, this.targetLayer.location);
    this.redo(ctx);
  }
  undo(ctx) {
    this.targetLayer.imageFilePath = this.oldFilePath;
    this.targetLayer.runtime.imageResource.filePath = this.oldAbsoluteFilePath;
    this.targetLayer.runtime.imageResource.image.imageData = this.oldImage;
    vec3.copy(this.targetLayer.location, this.oldLocation);
    vec3.copy(this.targetLayer.scale, this.oldScale);
    vec3.copy(this.targetLayer.rotation, this.oldRotation);
    Command_SetReferenceImageToLayer.setLoadedState(this.targetLayer.runtime.imageResource);
    ctx.setRedrawAllWindows();
  }
  redo(ctx) {
    this.targetLayer.imageFilePath = this.newFilePath;
    this.targetLayer.runtime.imageResource.filePath = this.newAbsoluteFilePath;
    this.targetLayer.runtime.imageResource.image.imageData = this.newImage;
    vec3.copy(this.targetLayer.location, this.newLocation);
    vec3.copy(this.targetLayer.scale, this.newScale);
    vec3.copy(this.targetLayer.rotation, this.newRotation);
    Command_SetReferenceImageToLayer.setLoadedState(this.targetLayer.runtime.imageResource);
    ctx.setRedrawAllWindows();
  }
  errorCheck() {
    if (this.targetLayer == null) {
      throw new Error("ERROR 0501:Command_LoadReferenceImageToLayer: layer is null!");
    }
    if (Strings.isNullOrEmpty(this.filePath)) {
      throw new Error("ERROR 0502:Command_LoadReferenceImageToLayer: new file path is empty!");
    }
    if (this.image == null) {
      throw new Error("ERROR 0503:Command_LoadReferenceImageToLayer: new image is null!");
    }
  }
  static setLoadedState(imageResource) {
    imageResource.loaded = imageResource.image.imageData != null;
    imageResource.error = false;
  }
}
class EditGeometry {
  constructor() {
    this.geometry = null;
    this.oldUnits = null;
    this.newUnits = null;
    this.deleteUnits = null;
  }
}
class EditDrawingUnit {
  constructor() {
    this.drawingUnit = null;
    this.oldGroups = null;
    this.newGroups = null;
    this.deleteGroups = null;
  }
}
class EditGroup {
  constructor() {
    this.group = null;
    this.oldStrokes = null;
    this.newStrokes = null;
    this.deleteStrokes = null;
  }
}
class EditStroke {
  constructor() {
    this.stroke = null;
    this.old_points = null;
    this.new_points = null;
    this.delete_points = null;
  }
}
class VectorLayerDeleteEditDataSet {
  constructor() {
    this.target_layers = [];
    this.editGeometrys = [];
    this.editDrawingUnits = [];
    this.editGroups = [];
    this.editStrokes = [];
  }
  existsChanges() {
    return this.editGeometrys.length > 0 || this.editDrawingUnits.length > 0 || this.editGroups.length > 0 || this.editStrokes.length > 0;
  }
}
class Command_VectorLayer_Delete_Base extends CommandBase {
  constructor() {
    super(...arguments);
    this.editDataSet = null;
  }
  prepare(ctx) {
    const editDataSet = new VectorLayerDeleteEditDataSet();
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    this.setFlags(viewKeyframeLayers);
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry, layer) => {
      this.processVectorGeometry(geometry, layer, editDataSet);
    });
    this.editDataSet = editDataSet;
    return this.editDataSet.existsChanges();
  }
  prepareForGeometry(geometry, layer) {
    const editDataSet = new VectorLayerDeleteEditDataSet();
    this.processVectorGeometry(geometry, layer, editDataSet);
    this.editDataSet = editDataSet;
    return this.editDataSet.existsChanges();
  }
  setFlags(viewKeyframeLayers) {
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry) => {
      this.setFlagsForGeometry(geometry);
    });
  }
  setFlagsForGeometry(geometry) {
  }
  processVectorGeometry(geometry, layer, editDataSet) {
    let deleteUnitCount = this.processDrawingUnits(geometry.units, editDataSet);
    if (deleteUnitCount > 0) {
      const editGeometry = new EditGeometry();
      editGeometry.geometry = geometry;
      editGeometry.oldUnits = geometry.units;
      editGeometry.newUnits = geometry.units.filter((unit) => unit.modifyFlag == VectorStrokeDrawingUnitModifyFlagID.none);
      editGeometry.deleteUnits = geometry.units.filter((unit) => unit.modifyFlag == VectorStrokeDrawingUnitModifyFlagID.delete);
      editDataSet.editGeometrys.push(editGeometry);
    }
    for (const unit of geometry.units) {
      unit.modifyFlag = VectorStrokeDrawingUnitModifyFlagID.none;
    }
    if (editDataSet.existsChanges()) {
      editDataSet.target_layers.push(layer);
    }
    return deleteUnitCount;
  }
  processDrawingUnits(units, editDataSet) {
    let deleteUnitCount = 0;
    for (const unit of units) {
      let deletedGroupCount = this.processStrokeGroups(unit.groups, editDataSet);
      if (unit.modifyFlag == VectorStrokeDrawingUnitModifyFlagID.delete || unit.groups.length - deletedGroupCount == 0) {
        unit.modifyFlag = VectorStrokeDrawingUnitModifyFlagID.delete;
        deleteUnitCount++;
      }
      if (deletedGroupCount > 0) {
        const editDrawingUnit = new EditDrawingUnit();
        editDrawingUnit.drawingUnit = unit;
        editDrawingUnit.oldGroups = unit.groups;
        editDrawingUnit.newGroups = unit.groups.filter((group) => group.runtime.modifyFlag == VectorStrokeGroupModifyFlagID.none);
        editDrawingUnit.deleteGroups = unit.groups.filter((group) => group.runtime.modifyFlag == VectorStrokeGroupModifyFlagID.delete);
        editDataSet.editDrawingUnits.push(editDrawingUnit);
      }
      for (const group of unit.groups) {
        group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.none;
      }
    }
    return deleteUnitCount;
  }
  processStrokeGroups(groups, editDataSet) {
    let deleteGroupCount = 0;
    for (const group of groups) {
      const deletedStrokeCount = this.processStrokes(group.lines, editDataSet);
      if (group.runtime.modifyFlag == VectorStrokeGroupModifyFlagID.delete || group.lines.length - deletedStrokeCount == 0) {
        group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.delete;
        deleteGroupCount++;
      }
      if (deletedStrokeCount > 0) {
        const editGroup = new EditGroup();
        editGroup.group = group;
        editGroup.oldStrokes = group.lines;
        editGroup.newStrokes = group.lines.filter((stroke) => stroke.runtime.modifyFlag == VectorStrokeModifyFlagID.none);
        editGroup.deleteStrokes = group.lines.filter((stroke) => stroke.runtime.modifyFlag == VectorStrokeModifyFlagID.delete);
        editDataSet.editGroups.push(editGroup);
      }
      for (const stroke of group.lines) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
      }
    }
    return deleteGroupCount;
  }
  processStrokes(strokes, editDataSet) {
    let deleteStrokeCount = 0;
    for (const stroke of strokes) {
      const deletePointCount = this.processPoints(stroke.points);
      if (stroke.runtime.modifyFlag == VectorStrokeModifyFlagID.delete || stroke.points.length - deletePointCount == 0 || VectorStrokeLogic.isEmptyStroke(stroke)) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
        deleteStrokeCount++;
      }
      if (deletePointCount > 0) {
        const editStroke = new EditStroke();
        editStroke.stroke = stroke;
        editStroke.old_points = stroke.points;
        editStroke.new_points = stroke.points.filter((point) => point.modifyFlag == VectorPointModifyFlagID.none);
        editStroke.delete_points = stroke.points.filter((point) => point.modifyFlag == VectorPointModifyFlagID.delete);
        editDataSet.editStrokes.push(editStroke);
      }
      for (const point of stroke.points) {
        point.modifyFlag = VectorPointModifyFlagID.none;
      }
    }
    return deleteStrokeCount;
  }
  processPoints(points) {
    let deletePointCount = 0;
    for (const point of points) {
      if (point.modifyFlag == VectorPointModifyFlagID.delete) {
        deletePointCount++;
      }
    }
    return deletePointCount;
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(ctx) {
    for (const editGeometry of this.editDataSet.editGeometrys) {
      editGeometry.geometry.units = editGeometry.oldUnits;
      for (const unit of editGeometry.deleteUnits) {
        unit.modifyFlag = VectorStrokeDrawingUnitModifyFlagID.none;
      }
    }
    for (const editDrawingUnit of this.editDataSet.editDrawingUnits) {
      editDrawingUnit.drawingUnit.groups = editDrawingUnit.oldGroups;
      for (const group of editDrawingUnit.deleteGroups) {
        group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.none;
      }
    }
    for (const editGroup of this.editDataSet.editGroups) {
      editGroup.group.lines = editGroup.oldStrokes;
      for (const stroke of editGroup.deleteStrokes) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
      }
    }
    for (const editStroke of this.editDataSet.editStrokes) {
      editStroke.stroke.points = editStroke.old_points;
      for (const point of editStroke.delete_points) {
        point.modifyFlag = VectorPointModifyFlagID.none;
      }
    }
  }
  redo(ctx) {
    for (const editGeometry of this.editDataSet.editGeometrys) {
      editGeometry.geometry.units = editGeometry.newUnits;
      for (const unit of editGeometry.deleteUnits) {
        unit.modifyFlag = VectorStrokeDrawingUnitModifyFlagID.delete;
      }
    }
    for (const editDrawingUnit of this.editDataSet.editDrawingUnits) {
      editDrawingUnit.drawingUnit.groups = editDrawingUnit.newGroups;
      for (const group of editDrawingUnit.deleteGroups) {
        group.runtime.modifyFlag = VectorStrokeGroupModifyFlagID.delete;
      }
    }
    for (const editGroup of this.editDataSet.editGroups) {
      editGroup.group.lines = editGroup.newStrokes;
      for (const stroke of editGroup.deleteStrokes) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
      }
    }
    for (const editStroke of this.editDataSet.editStrokes) {
      editStroke.stroke.points = editStroke.new_points;
      for (const point of editStroke.delete_points) {
        point.modifyFlag = VectorPointModifyFlagID.delete;
      }
    }
    for (const layer of this.editDataSet.target_layers) {
      if (VectorLayer.isPointBrushFillLayer(layer)) {
        ctx.main.setRedrawDrawPathForLayer(layer);
      }
    }
  }
}
class Command_VectorLayer_DeleteEmpties extends Command_VectorLayer_Delete_Base {
}
class Command_VectorLayer_DeleteSelected extends Command_VectorLayer_Delete_Base {
  setFlagsForGeometry(geometry) {
    VectorLayerGeometry.forEachPoint(geometry, (point) => {
      if (point.isSelected) {
        point.modifyFlag = VectorPointModifyFlagID.delete;
      }
    });
  }
}
class DocumentLoader {
  constructor() {
    this.oraSettings = null;
  }
  startLoadingDocumentFromURL(documentData, url) {
    const fileType = DocumentFileNameLogic.getDocumentFileTypeFromName(url);
    if (fileType == DocumentFileType.none) {
      console.error("not supported file type.");
      return;
    }
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.timeout = 3e3;
    xhr.responseType = "blob";
    xhr.addEventListener(
      "load",
      () => {
        if (fileType == DocumentFileType.json) {
          this.startLoadingDocumentJsonFromFile(documentData, xhr.response);
        } else if (fileType == DocumentFileType.ora) {
          this.startLoadingDocumentOraFromFile(documentData, xhr.response);
        }
      }
    );
    xhr.addEventListener(
      "timeout",
      () => {
        documentData.hasErrorOnLoading = true;
      }
    );
    xhr.addEventListener(
      "error",
      () => {
        documentData.hasErrorOnLoading = true;
      }
    );
    xhr.send();
  }
  startLoadingDocumentJsonFromFile(documentData, file) {
    const reader = new FileReader();
    reader.addEventListener("load", () => {
      if (typeof reader.result == "string") {
        const data = JSON.parse(reader.result);
        this.storeLoadedDocumentJSON(documentData, data);
      }
    });
    reader.readAsText(file);
  }
  startLoadingDocumentOraFromFile(documentData, file) {
    const zipfs = new zip.fs.FS();
    zip.workerScriptsPath = this.oraSettings.scriptsPath;
    zipfs.importBlob(file, () => {
      const entry = zipfs.find(this.oraSettings.vectorFileName);
      if (entry) {
        entry.getText((text) => {
          const data = JSON.parse(text);
          this.storeLoadedDocumentJSON(documentData, data);
        });
      } else {
        console.error("failed to read from ora file.");
      }
    });
  }
  storeLoadedDocumentJSON(documentData, loadedData) {
    documentData.version = loadedData.version;
    documentData.rootLayer = loadedData.rootLayer;
    documentData.documentFrame = loadedData.documentFrame;
    documentData.documentFrame_HideOuterArea = loadedData.documentFrame_HideOuterArea;
    if (loadedData["paletteColos"]) {
      documentData.paletteColors = loadedData["paletteColos"];
    } else {
      documentData.paletteColors = loadedData.paletteColors;
    }
    documentData.defaultViewScale = loadedData.defaultViewScale;
    documentData.lineWidthBiasRate = loadedData.lineWidthBiasRate;
    documentData.animationSettingData = loadedData.animationSettingData;
    documentData.exportImageSetting = loadedData.exportImageSetting;
    documentData.loaded = true;
  }
}
class DocumentLoaderOraSettings {
  constructor() {
    this.scriptsPath = "./libs/ora_js/";
    this.vectorFileName = "mttf.json";
  }
}
class ResourceLoader {
  constructor() {
    this.posing3DViewRender = null;
    this.posing3DModel = null;
  }
  startLoadingModelFile(modelFile, url) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "json";
    modelFile.loaded = false;
    modelFile.error = false;
    xhr.addEventListener(
      "load",
      () => {
        let data;
        if (xhr.responseType == "json") {
          data = xhr.response;
        } else {
          data = JSON.parse(xhr.response);
        }
        for (const modelData of data.static_models) {
          const modelResource = new ModelResource();
          modelResource.modelName = modelData.name;
          this.posing3DViewRender.initializeModelBuffer(modelResource.model, modelData.vertices, modelData.indices, 4 * modelData.vertexStride);
          modelFile.modelResources.push(modelResource);
          modelFile.modelResourceDictionary.set(modelData.name, modelResource);
        }
        for (const modelData of data.skin_models) {
          modelFile.posingModelDictionary.set(modelData.name, this.posing3DModel.createPosingModel(modelData));
        }
        modelFile.loaded = true;
      }
    );
    xhr.addEventListener(
      "load",
      () => {
        modelFile.error = true;
      }
    );
    xhr.send();
  }
  startLoadingImageResource(imageResource, filePath, basePath) {
    const image = new Image();
    imageResource.loaded = false;
    imageResource.error = false;
    if (basePath.length > 0 && Platform.path.isRelativePath(filePath)) {
      const refFileBasePath = Platform.path.getDirectoryPath(basePath);
      const absPath = Platform.path.resolveRelativePath(refFileBasePath, filePath);
      imageResource.filePath = Platform.path.getPlatformOrientedPath(absPath);
    } else {
      imageResource.filePath = filePath;
    }
    image.addEventListener(
      "load",
      () => {
        imageResource.image.imageData = image;
        if (imageResource.isGLTexture) {
          this.posing3DViewRender.initializeImageTexture(imageResource.image);
        }
        imageResource.image.width = image.width;
        imageResource.image.height = image.height;
        imageResource.loaded = true;
      }
    );
    image.addEventListener(
      "error",
      () => {
        console.log(new Error("ERROR-0000: Error has occured while loading and image"), imageResource.filePath);
        imageResource.error = true;
      }
    );
    image.src = imageResource.filePath;
  }
}
class DocumentLoading {
  constructor() {
    this.documentLoader = new DocumentLoader();
    this.resourceLoader = new ResourceLoader();
    this.oraSettings = null;
    this.loading_DocumentFilePath = "";
    this.loading_DocumentData = null;
    this.loading_ImageResurces = [];
    this.resourceLoading_DocumentData = null;
  }
  link(posing3DViewRender, posing3DModel, oraSettings) {
    this.documentLoader.oraSettings = oraSettings;
    this.resourceLoader.posing3DModel = posing3DModel;
    this.resourceLoader.posing3DViewRender = posing3DViewRender;
    this.oraSettings = oraSettings;
  }
  isDocumentLoading() {
    return this.loading_DocumentData != null;
  }
  isDocumentLoaded() {
    if (this.isDocumentLoading()) {
      return this.loading_DocumentData.loaded;
    }
    return false;
  }
  startLoadingDocumentFromFile(file, url) {
    const fileType = DocumentFileNameLogic.getDocumentFileTypeFromName(url);
    if (fileType == DocumentFileType.none) {
      console.debug("error: not supported file type.");
      return;
    }
    let documentData = null;
    if (file != null) {
      if (fileType == DocumentFileType.json) {
        documentData = new DocumentData();
        this.documentLoader.startLoadingDocumentJsonFromFile(documentData, file);
      } else if (fileType == DocumentFileType.ora) {
        documentData = new DocumentData();
        this.documentLoader.startLoadingDocumentOraFromFile(documentData, file);
      }
    } else if (file == null && !Strings.isNullOrEmpty(url)) {
      documentData = new DocumentData();
      this.documentLoader.startLoadingDocumentFromURL(documentData, url);
    }
    this.loading_DocumentData = documentData;
    this.loading_DocumentFilePath = url;
    return this.isDocumentLoading();
  }
  startLoadingDocumentFromURL(documentData, url) {
    this.loading_DocumentData = documentData;
    this.loading_DocumentFilePath = url;
    this.documentLoader.startLoadingDocumentFromURL(documentData, url);
  }
  finishDocumentDataLoading() {
    this.loading_DocumentData = null;
  }
  hasErrorOnLoadingDocument() {
    return this.loading_DocumentData == null || this.loading_DocumentData.hasErrorOnLoading;
  }
  hasErrorOnLoadingDocumentResource() {
    return this.resourceLoading_DocumentData == null || this.resourceLoading_DocumentData.hasErrorOnLoading;
  }
  startLoadingDocumentResources(documentData, documentFilePath) {
    this.resourceLoading_DocumentData = documentData;
    this.loading_ImageResurces = [];
    for (const layer of documentData.rootLayer.childLayers) {
      this.startLoadingDocumentResourcesRecursive(layer, this.loading_ImageResurces, documentFilePath);
    }
  }
  startLoadingDocumentResourcesRecursive(layer, loadingDocumentImageResources, documentFilePath) {
    if (ImageFileReferenceLayer.isImageFileReferenceLayer(layer)) {
      const ifrLayer = layer;
      if (!Strings.isNullOrEmpty(ifrLayer.imageFilePath)) {
        this.resourceLoader.startLoadingImageResource(ifrLayer.runtime.imageResource, ifrLayer.imageFilePath, documentFilePath);
        loadingDocumentImageResources.push(ifrLayer.runtime.imageResource);
      }
    }
    for (const chldLayer of layer.childLayers) {
      this.startLoadingDocumentResourcesRecursive(chldLayer, loadingDocumentImageResources, documentFilePath);
    }
  }
  isDocumentResourceLoading() {
    if (this.loading_ImageResurces.find((item) => item.loaded == false && item.error == false)) {
      return true;
    }
    return false;
  }
}
class SystemResourceLoading {
  constructor() {
    this.resourceLoader = new ResourceLoader();
    this.loading_ModelFiles = [];
    this.loading_ImageResurces = [];
  }
  link(render, posing3DModel) {
    this.resourceLoader.posing3DModel = posing3DModel;
    this.resourceLoader.posing3DViewRender = render;
  }
  startLoadingSystemResources(modelFile, imageResurces) {
    this.loading_ModelFiles = [];
    this.resourceLoader.startLoadingModelFile(modelFile, "./res/" + modelFile.fileName);
    this.loading_ModelFiles.push(modelFile);
    this.loading_ImageResurces = [];
    for (const imageResource of imageResurces) {
      this.resourceLoader.startLoadingImageResource(imageResource, imageResource.filePath, "");
      this.loading_ImageResurces.push(imageResource);
    }
  }
  isLoading() {
    if (this.loading_ModelFiles.find((item) => item.loaded == false && item.error == false)) {
      return true;
    }
    if (this.loading_ImageResurces.find((item) => item.loaded == false && item.error == false)) {
      return true;
    }
    return false;
  }
}
class ColorMixerWindow {
  constructor() {
    this.canvasRender = null;
    this.uiRef = {};
    this.colorCanvas = new PointerInputWindow();
    this.isDrawingDone = false;
    this.tempColor4 = vec4.create();
    this.colorW = vec4.fromValues(1, 1, 1, 1);
  }
  link(canvasRender) {
    this.canvasRender = canvasRender;
  }
  updateInputControls(color) {
    if (color != null) {
      this.uiRef.update(color);
    }
  }
  drawPaletteColorMixer() {
    const colorCanvasWindow = this.colorCanvas;
    const canvasRender = this.canvasRender;
    const width = colorCanvasWindow.width;
    const height = colorCanvasWindow.height;
    if (width == 0 || height == 0) {
      return;
    }
    canvasRender.setContext(colorCanvasWindow);
    canvasRender.setBlendMode(CanvasRenderBlendMode.default);
    canvasRender.setFillColorV(this.colorW);
    canvasRender.fillRect(0, 0, width, height);
    canvasRender.setBlendMode(CanvasRenderBlendMode.default);
    const divisionW = 40;
    const divisionH = 25;
    const unitWidth = width / divisionW;
    const unitHeight = height / divisionH;
    let drawX = 0;
    for (let x2 = 0; x2 <= divisionW; x2++) {
      let drawY = 0;
      for (let y2 = 1; y2 <= divisionH; y2++) {
        const h = x2 / divisionW;
        let s = 0;
        let v2 = 0;
        const iy = y2 / divisionH;
        if (iy <= 0.5) {
          s = iy * 2;
          v2 = 1;
        } else {
          s = 1;
          v2 = 1 - (iy - 0.5) * 2;
        }
        ColorLogic.hsvToRGB(this.tempColor4, h, s, v2);
        this.tempColor4[3] = 1;
        canvasRender.setFillColorV(this.tempColor4);
        canvasRender.fillRect(drawX, drawY, unitWidth + 1, unitHeight + 1);
        drawY += unitHeight;
      }
      drawX += unitWidth;
    }
    canvasRender.setBlendMode(CanvasRenderBlendMode.default);
  }
}
var MainCommandButtonID = /* @__PURE__ */ ((MainCommandButtonID2) => {
  MainCommandButtonID2[MainCommandButtonID2["none"] = 0] = "none";
  MainCommandButtonID2[MainCommandButtonID2["openFile"] = 1] = "openFile";
  MainCommandButtonID2[MainCommandButtonID2["newFile"] = 2] = "newFile";
  MainCommandButtonID2[MainCommandButtonID2["saveFile"] = 3] = "saveFile";
  MainCommandButtonID2[MainCommandButtonID2["saveAs"] = 4] = "saveAs";
  MainCommandButtonID2[MainCommandButtonID2["export"] = 5] = "export";
  MainCommandButtonID2[MainCommandButtonID2["shortcutKeys"] = 6] = "shortcutKeys";
  MainCommandButtonID2[MainCommandButtonID2["undo"] = 7] = "undo";
  MainCommandButtonID2[MainCommandButtonID2["redo"] = 8] = "redo";
  MainCommandButtonID2[MainCommandButtonID2["copy"] = 9] = "copy";
  MainCommandButtonID2[MainCommandButtonID2["paste"] = 10] = "paste";
  MainCommandButtonID2[MainCommandButtonID2["cut"] = 11] = "cut";
  MainCommandButtonID2[MainCommandButtonID2["touchOperationPanel"] = 12] = "touchOperationPanel";
  MainCommandButtonID2[MainCommandButtonID2["layerWindow"] = 13] = "layerWindow";
  MainCommandButtonID2[MainCommandButtonID2["layer_addLayer"] = 14] = "layer_addLayer";
  MainCommandButtonID2[MainCommandButtonID2["layer_deleteLayer"] = 15] = "layer_deleteLayer";
  MainCommandButtonID2[MainCommandButtonID2["layer_moveUp"] = 16] = "layer_moveUp";
  MainCommandButtonID2[MainCommandButtonID2["layer_moveDown"] = 17] = "layer_moveDown";
  MainCommandButtonID2[MainCommandButtonID2["paletteWindow"] = 18] = "paletteWindow";
  MainCommandButtonID2[MainCommandButtonID2["colorMixerWindow"] = 19] = "colorMixerWindow";
  MainCommandButtonID2[MainCommandButtonID2["timeLineWindow"] = 20] = "timeLineWindow";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_inertKeyframe"] = 21] = "timeLine_inertKeyframe";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_deleteKeyframe"] = 22] = "timeLine_deleteKeyframe";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_moveKeyframe_minus"] = 23] = "timeLine_moveKeyframe_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_moveKeyframe_plus"] = 24] = "timeLine_moveKeyframe_plus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeMaxFrame_minus"] = 25] = "timeLine_changeMaxFrame_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeMaxFrame_plus"] = 26] = "timeLine_changeMaxFrame_plus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeLoopStartFrame_minus"] = 27] = "timeLine_changeLoopStartFrame_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeLoopStartFrame_plus"] = 28] = "timeLine_changeLoopStartFrame_plus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeLoopEndFrame_minus"] = 29] = "timeLine_changeLoopEndFrame_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeLoopEndFrame_plus"] = 30] = "timeLine_changeLoopEndFrame_plus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeOnionSkinBackwardLevel_minus"] = 31] = "timeLine_changeOnionSkinBackwardLevel_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeOnionSkinBackwardLevel_plus"] = 32] = "timeLine_changeOnionSkinBackwardLevel_plus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeOnionSkinForwardLevel_minus"] = 33] = "timeLine_changeOnionSkinForwardLevel_minus";
  MainCommandButtonID2[MainCommandButtonID2["timeLine_changeOnionSkinForwardLevel_plus"] = 34] = "timeLine_changeOnionSkinForwardLevel_plus";
  return MainCommandButtonID2;
})(MainCommandButtonID || {});
var NumberInputControlID = /* @__PURE__ */ ((NumberInputControlID2) => {
  NumberInputControlID2[NumberInputControlID2["none"] = 0] = "none";
  NumberInputControlID2[NumberInputControlID2["onionSkinMode"] = 1] = "onionSkinMode";
  return NumberInputControlID2;
})(NumberInputControlID || {});
var RibbonUIControlID = /* @__PURE__ */ ((RibbonUIControlID2) => {
  RibbonUIControlID2[RibbonUIControlID2["none"] = 0] = "none";
  RibbonUIControlID2[RibbonUIControlID2["pointerBaseSize"] = 1] = "pointerBaseSize";
  RibbonUIControlID2[RibbonUIControlID2["brushBaseSize"] = 2] = "brushBaseSize";
  RibbonUIControlID2[RibbonUIControlID2["brushMinSize"] = 3] = "brushMinSize";
  RibbonUIControlID2[RibbonUIControlID2["edit_operationUnit"] = 4] = "edit_operationUnit";
  RibbonUIControlID2[RibbonUIControlID2["edit_operationOrigin"] = 5] = "edit_operationOrigin";
  RibbonUIControlID2[RibbonUIControlID2["document_lineWidthBiasRate"] = 6] = "document_lineWidthBiasRate";
  RibbonUIControlID2[RibbonUIControlID2["document_hideOuterArea"] = 7] = "document_hideOuterArea";
  RibbonUIControlID2[RibbonUIControlID2["layer_name"] = 8] = "layer_name";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_drawLineType"] = 9] = "vectorLayer_drawLineType";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_fillAreaType"] = 10] = "vectorLayer_fillAreaType";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_lineWidthBiasRate"] = 11] = "vectorLayer_lineWidthBiasRate";
  RibbonUIControlID2[RibbonUIControlID2["layer_isRenderTarget"] = 12] = "layer_isRenderTarget";
  RibbonUIControlID2[RibbonUIControlID2["layer_isMaskedByBelowLayer"] = 13] = "layer_isMaskedByBelowLayer";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_enableEyesSymmetry"] = 14] = "vectorLayer_enableEyesSymmetry";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_eyesSymmetryInputSide"] = 15] = "vectorLayer_eyesSymmetryInputSide";
  RibbonUIControlID2[RibbonUIControlID2["vectorLayer_posingLayer"] = 16] = "vectorLayer_posingLayer";
  RibbonUIControlID2[RibbonUIControlID2["imageFileRef_openImageFile"] = 17] = "imageFileRef_openImageFile";
  return RibbonUIControlID2;
})(RibbonUIControlID || {});
var SideBarContentID = /* @__PURE__ */ ((SideBarContentID2) => {
  SideBarContentID2[SideBarContentID2["none"] = 0] = "none";
  SideBarContentID2[SideBarContentID2["layerWindow"] = 1] = "layerWindow";
  SideBarContentID2[SideBarContentID2["paletteWindow"] = 2] = "paletteWindow";
  SideBarContentID2[SideBarContentID2["colorMixerWindow"] = 3] = "colorMixerWindow";
  return SideBarContentID2;
})(SideBarContentID || {});
var NewLayerTypeID = /* @__PURE__ */ ((NewLayerTypeID2) => {
  NewLayerTypeID2[NewLayerTypeID2["none"] = 0] = "none";
  NewLayerTypeID2[NewLayerTypeID2["vectorLayer"] = 1] = "vectorLayer";
  NewLayerTypeID2[NewLayerTypeID2["surroundingFill"] = 2] = "surroundingFill";
  NewLayerTypeID2[NewLayerTypeID2["autoFill"] = 3] = "autoFill";
  NewLayerTypeID2[NewLayerTypeID2["pointBrushFill"] = 4] = "pointBrushFill";
  NewLayerTypeID2[NewLayerTypeID2["vectorLayerReferenceLayer"] = 5] = "vectorLayerReferenceLayer";
  NewLayerTypeID2[NewLayerTypeID2["imageFileReferenceLayer"] = 6] = "imageFileReferenceLayer";
  NewLayerTypeID2[NewLayerTypeID2["posingLayer"] = 7] = "posingLayer";
  NewLayerTypeID2[NewLayerTypeID2["groupLayer"] = 8] = "groupLayer";
  return NewLayerTypeID2;
})(NewLayerTypeID || {});
var NewKeyframeTypeID = /* @__PURE__ */ ((NewKeyframeTypeID2) => {
  NewKeyframeTypeID2[NewKeyframeTypeID2["none"] = 0] = "none";
  NewKeyframeTypeID2[NewKeyframeTypeID2["insertToCurrentFrameAllLayer"] = 1] = "insertToCurrentFrameAllLayer";
  NewKeyframeTypeID2[NewKeyframeTypeID2["insertToCurrentFrameActiveLayer"] = 2] = "insertToCurrentFrameActiveLayer";
  NewKeyframeTypeID2[NewKeyframeTypeID2["insertEmptyToAllLayer"] = 3] = "insertEmptyToAllLayer";
  NewKeyframeTypeID2[NewKeyframeTypeID2["insertEmptyToActiveLayer"] = 4] = "insertEmptyToActiveLayer";
  return NewKeyframeTypeID2;
})(NewKeyframeTypeID || {});
var DeleteKeyframeTypeID = /* @__PURE__ */ ((DeleteKeyframeTypeID2) => {
  DeleteKeyframeTypeID2[DeleteKeyframeTypeID2["none"] = 0] = "none";
  DeleteKeyframeTypeID2[DeleteKeyframeTypeID2["deleteCurrentFrameAllLayer"] = 1] = "deleteCurrentFrameAllLayer";
  DeleteKeyframeTypeID2[DeleteKeyframeTypeID2["deleteCurrentFrameActiveLayer"] = 2] = "deleteCurrentFrameActiveLayer";
  return DeleteKeyframeTypeID2;
})(DeleteKeyframeTypeID || {});
var OpenFileDialogTargetID = /* @__PURE__ */ ((OpenFileDialogTargetID2) => {
  OpenFileDialogTargetID2[OpenFileDialogTargetID2["none"] = 0] = "none";
  OpenFileDialogTargetID2[OpenFileDialogTargetID2["openDocument"] = 1] = "openDocument";
  OpenFileDialogTargetID2[OpenFileDialogTargetID2["saveDocument"] = 2] = "saveDocument";
  OpenFileDialogTargetID2[OpenFileDialogTargetID2["imageFileReferenceLayerFilePath"] = 3] = "imageFileReferenceLayerFilePath";
  return OpenFileDialogTargetID2;
})(OpenFileDialogTargetID || {});
class DialogScreenLogic {
  constructor() {
    this.currentModalDialogResult = null;
    this.uiDocumentFilerRef = {};
    this.uiShortcutKeysRef = {};
    this._isOpened = false;
    this.currentModalDialogWindow = null;
    this.currentModalDialogID = null;
    this.currentModalFocusElementID = null;
    this.modalOverlayOption = {
      speedIn: 0,
      speedOut: 100,
      opacity: 0
    };
    this.modalLoaderOption = {
      active: false
    };
    this.dialogWindowContext = null;
    this.setCallbacks(this.uiDocumentFilerRef);
    this.setCallbacks(this.uiShortcutKeysRef);
  }
  setCallbacks(ref) {
    ref.onDialogScreenOpened = () => {
      this._isOpened = true;
    };
    ref.onDialogScreenClosed = () => {
      this._isOpened = false;
    };
  }
  isActive() {
    return this._isOpened;
  }
  link(main, dom, selectBoxRef) {
    this.dialogWindowContext = {
      dialog: this,
      dom: dom.value,
      ID: dom.ID,
      main
    };
    this.uiShortcutKeysRef.selectBoxPopoverRef = selectBoxRef;
  }
  openDocumentFilerDialog(dialogType, filePath, userSetting) {
    this.uiDocumentFilerRef.show(
      dialogType,
      filePath,
      userSetting
    );
  }
  openShortcutKeysDialog(userSetting, shortcutKey) {
    this.uiShortcutKeysRef.show(
      userSetting,
      shortcutKey
    );
  }
  openDialogWindow(modalID, focusElementName, dialogWindow = null) {
    if (this.isDialogWindowOpened()) {
      return;
    }
    this.currentModalDialogID = modalID;
    this.currentModalFocusElementID = focusElementName;
    this.currentModalDialogWindow = dialogWindow;
    const option = {
      content: {
        target: this.currentModalDialogID,
        close: true,
        speedIn: 0,
        delay: 0,
        positionX: "center",
        positionY: "center",
        speedOut: 100
      },
      overlay: this.modalOverlayOption,
      loader: this.modalLoaderOption
    };
    const modal = new Custombox.modal(option);
    modal.open();
  }
  closeDialogWindow() {
    Custombox.modal.closeAll();
  }
  onDialogWindowClosed() {
    if (this.currentModalDialogWindow) {
      this.currentModalDialogWindow.onClose(this.dialogWindowContext);
    }
    this.currentModalDialogWindow = null;
    this.currentModalDialogID = this.dialogWindowContext.ID.none;
    this.currentModalDialogResult = this.dialogWindowContext.ID.none;
  }
  isDialogWindowOpened() {
    return !Strings.isNullOrEmpty(this.currentModalDialogID) && this.currentModalDialogID != this.dialogWindowContext.ID.none;
  }
  onDialogWindowShown() {
    if (!Strings.isNullOrEmpty(this.currentModalFocusElementID)) {
      const element = this.dialogWindowContext.dom.getElement(this.currentModalFocusElementID);
      element.focus();
    }
  }
  messageBox(text) {
    if (this.isDialogWindowOpened()) {
      return;
    }
    this.dialogWindowContext.dom.setElementText(this.dialogWindowContext.ID.messageDialogModal_message, text);
    this.openDialogWindow(this.dialogWindowContext.ID.messageDialogModal, this.dialogWindowContext.ID.messageDialogModal_ok);
  }
}
class FooterWindow {
  constructor() {
    this.dom = null;
    this.footerText = "";
    this.footerTextBefore = "";
    this.uiFooterOperationpanelRef = { isForMobile: false };
  }
  link(dom) {
    this.dom = dom;
  }
  setFooterText(text) {
    this.footerText = text;
  }
  updateFooterText() {
    if (this.footerText != this.footerTextBefore) {
      this.dom.getElement(this.dom.ID.footer).innerHTML = this.footerText;
      this.footerTextBefore = this.footerText;
    }
  }
}
class HeaderWindow {
  constructor() {
    this.dom = null;
    this.uiHeaderWindowRef = {};
  }
  link(dom) {
    this.dom = dom;
  }
  setHeaderDocumentFileName(lastURL) {
    this.dom.value.setInputElementText(this.dom.ID.fileName, lastURL);
  }
}
class LayerWindow {
  constructor() {
    this.uiRef = {};
  }
  scrollToItem(_item) {
  }
  update(docContext, currentLayer) {
    for (const item of docContext.layerListItems) {
      item.isVisible = Layer.isVisible(item.layer);
      item.isCurrentLayer = Layer.isSelected(item.layer) && item.layer == currentLayer;
      item.isSelected = Layer.isSelected(item.layer) && !item.isCurrentLayer;
    }
  }
  scrollToLayer(layer, docContext) {
    const listItem = docContext.layerListItems.find((item) => item.layer == layer);
    if (listItem) {
      this.uiRef.scrollIntoView(listItem);
    }
  }
}
class ModalWindowLogic {
  constructor() {
    this.uiRadioSelectionRef = {};
    this.uiImageFileReferenceRef = {};
    this.uiExportImageRef = {};
    this._isOpened = false;
    this.setCallbacks(this.uiRadioSelectionRef);
    this.setCallbacks(this.uiImageFileReferenceRef);
    this.setCallbacks(this.uiExportImageRef);
  }
  setCallbacks(ref) {
    ref.onModalWindowOpened = () => {
      this._isOpened = true;
    };
    ref.onModalWindowClosed = () => {
      this._isOpened = false;
    };
  }
  isActive() {
    return this._isOpened;
  }
  showRadioSelectionModal(windowTitle, options, selectedIndex, callback) {
    this.uiRadioSelectionRef.selection_Fixed = callback;
    this.uiRadioSelectionRef.show(
      windowTitle,
      options,
      selectedIndex
    );
  }
  openImageFileReferenceModal() {
    this.uiImageFileReferenceRef.show();
  }
  openExportImageModal(docContext, localSetting) {
    this.uiExportImageRef.show(
      docContext,
      localSetting
    );
  }
}
var PaletteSelectorWindowButtonID = /* @__PURE__ */ ((PaletteSelectorWindowButtonID2) => {
  PaletteSelectorWindowButtonID2[PaletteSelectorWindowButtonID2["none"] = 0] = "none";
  PaletteSelectorWindowButtonID2[PaletteSelectorWindowButtonID2["lineColor"] = 1] = "lineColor";
  PaletteSelectorWindowButtonID2[PaletteSelectorWindowButtonID2["fillColor"] = 2] = "fillColor";
  PaletteSelectorWindowButtonID2[PaletteSelectorWindowButtonID2["adjustmentMode"] = 3] = "adjustmentMode";
  return PaletteSelectorWindowButtonID2;
})(PaletteSelectorWindowButtonID || {});
class PaletteSelectorWindow {
  constructor() {
    this.uiRef = {};
    this.commandButtonAreas = [];
    this.itemAreas = [];
    this.currentTargetID = 1;
    this.currentPaletteIndex = 0;
  }
  setCurrentPaletteIndex(index2) {
    this.currentPaletteIndex = index2;
  }
  setCurrentTarget(targetID) {
    this.currentTargetID = targetID;
  }
  getCurrentLayerTargetColorRef(ctx) {
    switch (this.currentTargetID) {
      case 1:
        return ctx.getCurrentLayerLineColor();
      case 2:
        return ctx.getCurrentLayerFillColor();
      case 3:
        return ctx.documentData.paletteColors[this.currentPaletteIndex].color;
    }
  }
  updateCurrentLayerColor(newColor, keepAlpha, ctx) {
    const destColor = this.getCurrentLayerTargetColorRef(ctx);
    if (destColor) {
      destColor[0] = newColor[0];
      destColor[1] = newColor[1];
      destColor[2] = newColor[2];
      if (!keepAlpha) {
        destColor[3] = newColor[3];
      }
      switch (this.currentTargetID) {
        case 1:
          if (ctx.currentStrokeDrawable != null && ctx.currentStrokeDrawable.drawLineType == DrawLineTypeID.paletteColor) {
            vec4.copy(ctx.currentStrokeDrawable.layerColor, destColor);
          }
          break;
        case 2:
          if (ctx.currentFillDrawable != null && ctx.currentFillDrawable.fillAreaType == FillAreaTypeID.paletteColor) {
            vec4.copy(ctx.currentFillDrawable.fillColor, destColor);
          }
          break;
      }
      return true;
    } else {
      return false;
    }
  }
  initialize() {
    this.commandButtonAreas = [];
    this.commandButtonAreas.push(new RectangleLayoutArea().setIndex(1));
    this.commandButtonAreas.push(new RectangleLayoutArea().setIndex(2));
    this.commandButtonAreas.push(new RectangleLayoutArea().setIndex(3));
    this.caluculateLayout();
  }
  caluculateLayout() {
    this.itemAreas = [];
    for (let paletteColorIndex = 0; paletteColorIndex < DocumentData.maxPaletteColors; paletteColorIndex++) {
      const layoutArea = new RectangleLayoutArea();
      layoutArea.index = paletteColorIndex;
      this.itemAreas.push(layoutArea);
    }
  }
  updateCommandButtons() {
    for (const layoutArea of this.commandButtonAreas) {
      const isSelected = this.currentTargetID == layoutArea.index;
      this.uiRef.setCommandButtonState(layoutArea.index - 1, isSelected);
    }
  }
  updatePaletteItems(ctx) {
    let currentPaletteColorIndex = -1;
    switch (this.currentTargetID) {
      case 1:
        if (ctx.currentStrokeDrawable != null) {
          currentPaletteColorIndex = ctx.currentStrokeDrawable.line_PaletteColorIndex;
        }
        break;
      case 2:
        if (ctx.currentFillDrawable != null) {
          currentPaletteColorIndex = ctx.currentFillDrawable.fill_PaletteColorIndex;
        }
        break;
      case 3:
        currentPaletteColorIndex = this.currentPaletteIndex;
        break;
    }
    for (const layoutArea of this.itemAreas) {
      const paletteColorIndex = layoutArea.index;
      if (paletteColorIndex > ctx.documentData.paletteColors.length) {
        break;
      }
      const paletteColor = ctx.documentData.paletteColors[paletteColorIndex];
      paletteColor.isSelected = paletteColorIndex == currentPaletteColorIndex;
    }
  }
  setCurrentTargetForLayer(ctx) {
    if (ctx.currentFillDrawable != null && ctx.currentFillDrawable.fillAreaType != FillAreaTypeID.none) {
      this.currentTargetID = 2;
    } else if (ctx.currentStrokeDrawable != null && ctx.currentStrokeDrawable.drawLineType != DrawLineTypeID.none) {
      this.currentTargetID = 1;
    }
  }
}
class DOMElementID {
  constructor() {
    this.none = "none";
    this.fileName = "fileName";
    this.screenMain = "screen-main";
    this.header = "header-ui";
    this.ribbonUI = "ribbon-ui";
    this.footerUI = "footer-ui";
    this.footer = "footer";
    this.subtoolWindow = "subtoolWindow";
    this.leftSidePanel = "side-panel-left";
    this.leftSidePanelDock = "side-panel-left-dock";
    this.rightSidePanel = "side-panel-right";
    this.rightSidePanelDock = "side-panel-right-dock";
    this.popoverDockContainer = "popover-dock-container";
    this.mainCanvas = "mainCanvas";
    this.editorCanvas = "editorCanvas";
    this.webglCanvas = "webglCanvas";
    this.layerCanvas = "layerCanvas";
    this.colorMixerWindow_colorCanvas = "colorMixer_colorCanvas";
    this.timeLineWindow = "time-line-window";
    this.timeLineCanvas = "timeLineCanvas";
    this.messageDialogModal = "#messageDialogModal";
    this.messageDialogModal_message = "messageDialogModal_message";
    this.messageDialogModal_ok = "messageDialogModal_ok";
    this.openFileDialogModal = "#openFileDialogModal";
    this.openFileDialogModal_file = "openFileDialogModal_file";
    this.openFileDialogModal_ok = "openFileDialogModal_ok";
    this.openFileDialogModal_cancel = "openFileDialogModal_cancel";
    this.newKeyframeModal = "#newKeyframeModal";
    this.newKeyframeModal_InsertType = "newKeyframeModal_InsertType";
    this.newKeyframeModal_ok = "newKeyframeModal_ok";
    this.newKeyframeModal_cancel = "newKeyframeModal_cancel";
    this.deleteKeyframeModal = "#deleteKeyframeModal";
    this.deleteKeyframeModal_InsertType = "deleteKeyframeModal_InsertType";
    this.deleteKeyframeModal_ok = "deleteKeyframeModal_ok";
    this.deleteKeyframeModal_cancel = "deleteKeyframeModal_cancel";
  }
}
class DOMValueLogic {
  getElement(id2) {
    const element = document.getElementById(id2);
    if (element == null) {
      throw new Error('ERROR 0051:Could not find element "' + id2 + '"');
    }
    return element;
  }
  setElementText(id2, text) {
    const element = document.getElementById(id2);
    element.innerText = text;
    return element;
  }
  setInputElementText(id2, text) {
    const element = document.getElementById(id2);
    element.value = text;
    return element;
  }
  getInputElementText(id2) {
    const element = document.getElementById(id2);
    return element.value;
  }
  setInputElementNumber(id2, value) {
    const element = document.getElementById(id2);
    element.value = value.toString();
    return element;
  }
  setInputElementNumber2Decimal(id2, value) {
    const element = document.getElementById(id2);
    element.value = value.toFixed(2);
    return element;
  }
  getInputElementNumber(id2, defaultValue) {
    const element = document.getElementById(id2);
    if (element.value == "") {
      return defaultValue;
    }
    return Number(element.value);
  }
  setInputElementRangeValue(id2, value, max) {
    const element = document.getElementById(id2);
    element.value = (value / max * Number(element.max)).toString();
    return element;
  }
  getInputElementRangeValue(id2, max, defaultValue) {
    const element = document.getElementById(id2);
    if (Strings.isNullOrEmpty(element.value)) {
      return defaultValue;
    }
    const value = Number(element.value) / Number(element.max) * max;
    return value;
  }
  setRadioElementIntValue(elementName, value) {
    const valueText = value.toString();
    const elements = document.getElementsByName(elementName);
    for (let i = 0; i < elements.length; i++) {
      const radio = elements[i];
      radio.checked = radio.value == valueText;
    }
  }
  getRadioElementIntValue(elementName, defaultValue) {
    let value = defaultValue;
    const elements = document.getElementsByName(elementName);
    for (let i = 0; i < elements.length; i++) {
      const radio = elements[i];
      if (radio.checked) {
        value = Number(radio.value);
      }
    }
    return value;
  }
  setInputElementBoolean(id2, checked) {
    const element = document.getElementById(id2);
    element.checked = checked;
  }
  getInputElementBoolean(id2) {
    const element = document.getElementById(id2);
    return element.checked;
  }
  setInputElementColor(id2, color) {
    const colorText = "#" + ColorLogic.rgbToHex2String(color);
    const element = document.getElementById(id2);
    element.value = colorText;
    return color;
  }
  getInputElementColor(id2, result) {
    const element = document.getElementById(id2);
    const colorText = element.value;
    ColorLogic.hex2StringToRGB(result, colorText);
    return result;
  }
  getInputElementFilePath(id2) {
    const element = document.getElementById(id2);
    if (element.files.length == 0) {
      return null;
    }
    const file = element.files[0];
    return file["path"];
  }
  setColorMixerValue(id2, colorValue, colorMixer_id_number, colorMixer_id_range) {
    this.setInputElementNumber2Decimal(id2 + colorMixer_id_number, colorValue);
    this.setInputElementRangeValue(id2 + colorMixer_id_range, colorValue, 1);
  }
}
class DOMResizingLogic {
  constructor() {
    this.dom = new DOMValueLogic();
  }
  resizeCanvasToParent(canvasWindow, withStyle = true) {
    const rect = canvasWindow.canvas.parentElement.getBoundingClientRect();
    this.setCanvasElementSize(canvasWindow, rect.width, rect.height);
    if (withStyle) {
      this.setCanvasElementStyle(canvasWindow, rect.width, rect.height);
    }
  }
  resizeCanvasToBoundingClientRect(canvasWindow, withStyle = true) {
    const rect = canvasWindow.canvas.getBoundingClientRect();
    this.setCanvasElementSize(canvasWindow, rect.width, rect.height);
    if (withStyle) {
      this.setCanvasElementStyle(canvasWindow, rect.width, rect.height);
    }
  }
  resizeCanvasToCanvasWindow(canvasWindow, fitToWindow, scale) {
    canvasWindow.width = fitToWindow.width * scale;
    canvasWindow.height = fitToWindow.height * scale;
    canvasWindow.canvas.width = canvasWindow.width;
    canvasWindow.canvas.height = canvasWindow.height;
    canvasWindow.canvas.style.width = fitToWindow.canvas.style.width;
    canvasWindow.canvas.style.height = fitToWindow.canvas.style.height;
  }
  setCanvasElementSize(canvasWindow, width, height) {
    canvasWindow.width = Math.floor(width * canvasWindow.devicePixelRatio);
    canvasWindow.height = Math.floor(height * canvasWindow.devicePixelRatio);
    if (canvasWindow.canvas.width != canvasWindow.width || canvasWindow.canvas.height != canvasWindow.height) {
      canvasWindow.canvas.width = canvasWindow.width;
      canvasWindow.canvas.height = canvasWindow.height;
    }
  }
  setCanvasElementStyle(canvasWindow, width, height) {
    canvasWindow.canvas.style.width = `${width}px`;
    canvasWindow.canvas.style.height = `${height}px`;
  }
  fitFixedPositionToBoundingClientRect(target_ID, destination_ID, withWidth = true, withHeight = true) {
    const target = this.dom.getElement(target_ID);
    const destination = this.dom.getElement(destination_ID);
    const rect = destination.getBoundingClientRect();
    target.style.top = `${rect.top}px`;
    target.style.left = `${rect.left}px`;
    if (withWidth) {
      target.style.width = `${rect.width}px`;
    }
    if (withHeight) {
      target.style.height = `${rect.height}px`;
    }
  }
}
class DOMLogic {
  constructor() {
    this.ID = new DOMElementID();
    this.value = new DOMValueLogic();
    this.resizing = new DOMResizingLogic();
  }
  getElement(id2) {
    const element = document.getElementById(id2);
    if (element == null) {
      throw new Error('ERROR 0051:Could not find element "' + id2 + '"');
    }
    return element;
  }
}
function UI_Icon_MaterialIcon({ iconName }) {
  return /* @__PURE__ */ react.exports.createElement("i", {
    className: "material-icons"
  }, iconName);
}
function UI_CheckBox({ trueValue = true, falseValue = false, value = false, onChange = null }) {
  function box_Clicked() {
    if (onChange) {
      const new_checked = !(value == trueValue);
      onChange(new_checked, new_checked ? trueValue : falseValue);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-checkbox-container selectable-item",
    onPointerDown: box_Clicked
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "content"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: value == trueValue ? "check" : ""
  })));
}
function UI_ColorSlider({ min = 0, max = 100, step = 1, railColor = "#ddd", trackColor = "#000", value = 0, showText = false, onChange = null }) {
  const head_Ref = react.exports.useRef();
  const tail_Ref = react.exports.useRef();
  function slider_PointerDown(e) {
    if (!onChange) {
      return;
    }
    const div = e.nativeEvent.target;
    const railRect = div.getBoundingClientRect();
    const headRect = head_Ref.current.getBoundingClientRect();
    const tailRect = tail_Ref.current.getBoundingClientRect();
    let position = (e.nativeEvent.offsetX - headRect.width) / (railRect.width - headRect.width - tailRect.width);
    if (position > 1) {
      position = 1;
    }
    if (position < 0) {
      position = 0;
    }
    let newValue = Number((min + position * (max - min)).toFixed(2));
    newValue = Math.floor(newValue / step) * step;
    onChange(newValue);
    e.currentTarget.setPointerCapture(e.pointerId);
  }
  function slider_PointerMove(e) {
    if (!onChange) {
      return;
    }
    if (e.buttons != 0) {
      slider_PointerDown(e);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-color-slider-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "rail",
    onPointerDown: slider_PointerDown,
    onPointerMove: slider_PointerMove
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: `rail-body head ${value > min ? "filled" : "not-filled"}`,
    ref: head_Ref,
    style: { backgroundColor: value > min ? trackColor : railColor }
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "rail-body track filled",
    style: {
      width: `${((value - min) / (max - min) * 100).toFixed(2)}%`,
      backgroundColor: trackColor
    }
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "rail-body rest not-filled",
    style: { backgroundColor: railColor }
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: `rail-body head ${value >= max ? "filled" : "not-filled"}`,
    ref: tail_Ref,
    style: { backgroundColor: value >= max ? trackColor : railColor }
  })), showText && /* @__PURE__ */ react.exports.createElement("div", {
    className: "text-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "text"
  }, value.toFixed(2))));
}
function UI_CommandButton({ commandButtonItem: item, border = false, menuButton = false, onClick }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ui-command-button selectable-item${item.isSelected ? " selected" : ""}${border ? " button-border" : ""}${menuButton ? " menu-button-border" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    title: item.title ? item.title : null,
    className: ` selectable-item-inner`,
    onMouseDown: (e) => {
      if (onClick) {
        onClick(item);
      }
      e.preventDefault();
    }
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: item.icon
  })));
}
function UI_CommandButtons({ uiRef, border = false }) {
  react.exports.useEffect(() => {
    uiRef.setCommandButtonState = (index2, isSelected) => {
      uiRef.items[index2].isSelected = isSelected;
    };
    return function cleanup() {
      uiRef.setCommandButtonState = null;
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-command-buttons-container"
  }, uiRef.items.map((item) => item.isSeparator ? /* @__PURE__ */ react.exports.createElement("div", {
    key: item.index,
    className: "separator"
  }) : /* @__PURE__ */ react.exports.createElement(UI_CommandButton, {
    key: item.index,
    commandButtonItem: item,
    onClick: uiRef.commandButton_Clicked,
    border
  })));
}
function UI_NumberInput({ digit = 2, step = 0.05, min = 0, max = 100, value, onChange }) {
  let valueText = "";
  if (typeof value == "number") {
    valueText = value.toFixed(digit);
  }
  function handleChange(event) {
    let inputValue = Number(event.target.value);
    if (isNaN(inputValue)) {
      inputValue = null;
    } else {
      if (inputValue < min) {
        inputValue = min;
      }
      if (inputValue > max) {
        inputValue = max;
      }
    }
    if (onChange) {
      onChange(inputValue);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("input", {
    className: "number-input",
    type: "number",
    step: step.toString(),
    value: valueText,
    onChange: handleChange
  });
}
function UI_NumberSpinner({ value, title = "", border = false, buttonIndexs, onClick }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ui-number-spinner-container${border ? " button-border" : ""}`,
    title
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-number-spinner-button",
    onPointerDown: () => onClick(buttonIndexs[0])
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandleft"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-number-spinner-text"
  }, value), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-number-spinner-button",
    onPointerDown: () => onClick(buttonIndexs[1])
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandright"
  })));
}
function UI_RadioButton({ index: index2 = 0, selectedIndex = -1, label = "", onClick = null }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "radio-button selectable-item",
    onPointerDown: () => onClick(index2)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "radio-button-marker"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: index2 == selectedIndex ? "radiochecked" : "radiounchecked"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "radio-button-label"
  }, /* @__PURE__ */ react.exports.createElement("span", null, label)));
}
function UI_RadioButtons({ options, selectedIndex, onClick = null }) {
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, options.map((option) => /* @__PURE__ */ react.exports.createElement(UI_RadioButton, {
    key: option.index,
    index: option.index,
    selectedIndex,
    label: option.label,
    onClick: () => {
      if (onClick) {
        onClick(option);
      }
    }
  })));
}
function UI_ScrollView({ children, wheelScrollY = 16, direction = "vertical", alignment = "", shrink = true }) {
  var _a, _b;
  const containerRef = react.exports.useRef(null);
  const scroll = react.exports.useCallback(
    ({ dx, dy }) => {
      if (direction == "vertical") {
        containerRef.current.scrollTop += dy;
      } else {
        containerRef.current.scrollLeft += dx;
      }
    },
    [direction == "vertical" ? (_a = containerRef.current) == null ? void 0 : _a.scrollTop : (_b = containerRef.current) == null ? void 0 : _b.scrollLeft]
  );
  const internalState = react.exports.useRef({
    lastMouseX: null,
    lastMouseY: null,
    isMouseDown: false,
    isTouch: false,
    isScrolling: false,
    isFocused: false
  });
  const endScroll = () => {
    internalState.current.isMouseDown = false;
    internalState.current.isTouch = false;
    internalState.current.lastMouseX = null;
    internalState.current.lastMouseY = null;
    internalState.current.isScrolling = false;
  };
  const view_PointerDown = (e) => {
    let x2 = e.pageX;
    let y2 = e.pageY;
    internalState.current.isMouseDown = true;
    internalState.current.lastMouseX = x2;
    internalState.current.lastMouseY = y2;
  };
  const view_PointerEnter = (e) => {
    internalState.current.isFocused = true;
  };
  const view_PointerLeave = (e) => {
    internalState.current.isFocused = false;
  };
  const view_Wheel = (e) => {
    let scrollDistance = e.deltaY > 0 ? wheelScrollY : -wheelScrollY;
    let dx = direction == "horizontal" ? scrollDistance : 0;
    let dy = direction == "vertical" ? scrollDistance : 0;
    scroll({ dx, dy });
  };
  const window_onPointerMove = (e) => {
    let x2 = e.pageX;
    let y2 = e.pageY;
    if (!internalState.current.isMouseDown) {
      internalState.current.lastMouseX = x2;
      internalState.current.lastMouseY = y2;
      return;
    }
    if (internalState.current.isFocused && internalState.current.isMouseDown) {
      containerRef.current.setPointerCapture(e.pointerId);
    }
    internalState.current.isScrolling = true;
    const dx = -(x2 - internalState.current.lastMouseX);
    const dy = -(y2 - internalState.current.lastMouseY);
    internalState.current.lastMouseX = x2;
    internalState.current.lastMouseY = y2;
    scroll({ dx, dy });
  };
  const window_PointerUp = () => {
    endScroll();
  };
  const window_KeyDown = (e) => {
    if (e.key === " ") {
      if (internalState.current.isFocused) {
        internalState.current.isMouseDown = true;
      }
    }
  };
  const window_KeyUp = (e) => {
    if (e.key === " ") {
      endScroll();
    }
  };
  react.exports.useEffect(() => {
    window.addEventListener("keydown", window_KeyDown);
    window.addEventListener("keyup", window_KeyUp);
    window.addEventListener("pointerup", window_PointerUp);
    window.addEventListener("pointermove", window_onPointerMove);
    return function cleanup() {
      window.removeEventListener("keydown", window_KeyDown);
      window.removeEventListener("keyup", window_KeyUp);
      window.removeEventListener("pointerup", window_PointerUp);
      window.removeEventListener("pointermove", window_onPointerMove);
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: containerRef,
    className: `ui-scroll-view-container ${direction == "vertical" ? "vertical" : "horizontal"} ${alignment == "center" ? "center" : ""} ${shrink ? "" : "no-shrink"}`,
    onPointerDown: view_PointerDown,
    onPointerEnter: view_PointerEnter,
    onPointerLeave: view_PointerLeave,
    onWheel: view_Wheel
  }, children);
}
class PopoverRef {
  onPopoverOpened() {
  }
  onPopoverClosed() {
  }
}
var UI_PopoverContainerAlign = /* @__PURE__ */ ((UI_PopoverContainerAlign2) => {
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["bottom"] = 0] = "bottom";
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["left"] = 1] = "left";
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["right"] = 2] = "right";
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["top"] = 3] = "top";
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["topLeft"] = 4] = "topLeft";
  UI_PopoverContainerAlign2[UI_PopoverContainerAlign2["topRight"] = 5] = "topRight";
  return UI_PopoverContainerAlign2;
})(UI_PopoverContainerAlign || {});
class UI_PopoverContainerRef {
  show(popoverRef, popoverParentElement, align) {
  }
  close(popoverRef) {
  }
  isShown() {
    return false;
  }
}
function UI_PopoverContent({ children, uiRef, fullHeight, offset, onDissmiss, onEscape, onVisibilityChange }) {
  const hidden_ContainerRef = react.exports.useRef(null);
  const content_ContainerRef = react.exports.useRef(null);
  const [visible, set_visible] = react.exports.useState(false);
  const visiblity_Ref = react.exports.useRef(false);
  const backDropClickedRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    uiRef.show = (popoverRef, popoverParentElement, align = 1) => {
      var _a, _b;
      if (!hidden_ContainerRef.current || !content_ContainerRef.current) {
        return;
      }
      const anchorRect = popoverParentElement.getBoundingClientRect();
      const documentBodyRect = document.body.getBoundingClientRect();
      const horizontalOffset = (_a = offset == null ? void 0 : offset.x) != null ? _a : 0;
      const verticalOffset = (_b = offset == null ? void 0 : offset.y) != null ? _b : 0;
      const alignLeft = align == 1 || align == 4;
      const alignRight = align == 2 || align == 5;
      const alignBottom = align == 0;
      const alignTop = align == 3 || align == 4 || align == 5;
      let left = anchorRect.left;
      let right = documentBodyRect.width - anchorRect.right;
      if (alignLeft) {
        left += horizontalOffset;
        right = 0;
      }
      if (alignRight) {
        left = 0;
        right += horizontalOffset;
      }
      if (alignBottom) {
        left += horizontalOffset;
        right -= horizontalOffset;
      }
      content_ContainerRef.current.style.left = `${left}px`;
      content_ContainerRef.current.style.right = `${right}px`;
      if (alignTop) {
        content_ContainerRef.current.style.top = "unset";
        content_ContainerRef.current.style.bottom = `${documentBodyRect.height - anchorRect.top + verticalOffset}px`;
      } else {
        content_ContainerRef.current.style.top = `${anchorRect.bottom + verticalOffset}px`;
        content_ContainerRef.current.style.bottom = "unset";
        content_ContainerRef.current.style.maxHeight = `${documentBodyRect.height - anchorRect.bottom - 10}px`;
      }
      if (fullHeight) {
        content_ContainerRef.current.style.bottom = "0";
      }
      setVisibility(true);
      hidden_ContainerRef.current.parentElement.classList.remove("hidden");
      if (onVisibilityChange) {
        onVisibilityChange(true);
      }
      backDropClickedRef.current = false;
      window.setTimeout(() => {
        content_ContainerRef.current.focus();
      }, 100);
      popoverRef.onPopoverOpened();
    };
    uiRef.close = (popoverRef) => {
      if (hidden_ContainerRef.current && content_ContainerRef.current) {
        hidden_ContainerRef.current.parentElement.classList.add("hidden");
        setVisibility(false);
        if (onVisibilityChange) {
          onVisibilityChange(false);
        }
      }
      popoverRef.onPopoverClosed();
    };
    uiRef.isShown = () => {
      return visiblity_Ref.current;
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.close = null;
    };
  }, []);
  function setVisibility(visiblity) {
    set_visible(visiblity);
    visiblity_Ref.current = visiblity;
  }
  function popoverContainer_KeyDown(e) {
    if (e.key == "Escape") {
      if (onEscape) {
        onEscape(e);
        e.stopPropagation();
      }
    }
  }
  function backdrop_PointerDown(e) {
    e.preventDefault();
    backDropClickedRef.current = true;
  }
  function backdrop_PointerUp(e) {
    e.preventDefault();
    if (backDropClickedRef.current) {
      backDropClickedRef.current = false;
      if (onDissmiss) {
        onDissmiss();
      }
    }
  }
  function contentContainer_PointerMove(e) {
    backDropClickedRef.current = false;
  }
  function stopPropagation(e) {
    e.stopPropagation();
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: hidden_ContainerRef,
    className: `popover-hidden-container ${visible ? "visible" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "popover-content-backdrop",
    onPointerDown: backdrop_PointerDown,
    onPointerUp: backdrop_PointerUp,
    onPointerMove: stopPropagation
  }, /* @__PURE__ */ react.exports.createElement("div", {
    ref: content_ContainerRef,
    className: "popover-content-container",
    tabIndex: 0,
    onClick: stopPropagation,
    onPointerDown: stopPropagation,
    onKeyDown: popoverContainer_KeyDown,
    onPointerMove: contentContainer_PointerMove
  }, children)));
}
class UI_BrushPropertyBoxRef extends PopoverRef {
  constructor() {
    super(...arguments);
    this.docContext = null;
  }
  updateBox() {
  }
  resize() {
  }
  updatePopover() {
  }
  showPopover(parentNode) {
  }
  numberInput_Changed(id2, value) {
  }
}
function UI_BrushPropertyBox({ uiRef }) {
  const popoverAnchor_Ref = react.exports.useRef(null);
  const [pointerParams, set_pointerParams] = react.exports.useState({
    isUsingPointerParameter: false,
    isUsingBrushParameter: false,
    pointerType: PointerTypeID.brush,
    pointerBaseSize: 0,
    brushBaseSize: 0,
    brushMinSize: 1,
    baseColor: vec4.fromValues(0, 0, 0, 1)
  });
  react.exports.useEffect(() => {
    uiRef.resize = () => {
    };
    uiRef.updateBox = () => {
      if (uiRef.docContext.currentPointerParameter != null) {
        set_pointerParams(getPointerParameters(uiRef.docContext));
      }
    };
    return function cleanup() {
      uiRef.updateBox = null;
    };
  }, []);
  function box_Clicked() {
    uiRef.showPopover(popoverAnchor_Ref.current);
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-property-box",
    ref: popoverAnchor_Ref
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-property-box-inner-container",
    onPointerDown: box_Clicked
  }, /* @__PURE__ */ react.exports.createElement(BrushThumbnailBox, {
    pointerType: pointerParams.pointerType,
    drawLineBaseWidth: pointerParams.isUsingBrushParameter ? pointerParams.brushBaseSize : pointerParams.pointerBaseSize,
    drawLineMinWidth: pointerParams.isUsingBrushParameter ? pointerParams.brushMinSize : 1,
    baseColor: pointerParams.baseColor,
    drawStyle: uiRef.docContext.drawStyle
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "expand"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandmore"
  }))));
}
function UI_BrushPropertyBoxPopover({ uiRef }) {
  const previewCanvas_Ref = react.exports.useRef(null);
  const [isPopoverShown, set_isPopoverShown] = react.exports.useState(false);
  const [isCanvasShown, set_isCanvasShown] = react.exports.useState(false);
  const [brushParams, set_brushParams] = react.exports.useState({
    isUsingPointerParameter: false,
    isUsingBrushParameter: false,
    pointerType: PointerTypeID.brush,
    pointerBaseSize: 0,
    brushBaseSize: 0,
    brushMinSize: 1,
    baseColor: vec4.fromValues(0, 0, 0, 1)
  });
  const brushPresetGroups = react.exports.useMemo(() => {
    const groups = [
      {
        index: 0,
        presets: [
          { index: 0, baseWidth: 1, minWidth: 1 },
          { index: 0, baseWidth: 2, minWidth: 1 },
          { index: 0, baseWidth: 3, minWidth: 1 },
          { index: 0, baseWidth: 4, minWidth: 1 },
          { index: 0, baseWidth: 5, minWidth: 1 }
        ]
      },
      {
        index: 0,
        presets: [
          { index: 0, baseWidth: 1, minWidth: 0.5 },
          { index: 0, baseWidth: 2, minWidth: 0.5 },
          { index: 0, baseWidth: 3, minWidth: 0.5 },
          { index: 0, baseWidth: 4, minWidth: 0.5 },
          { index: 0, baseWidth: 5, minWidth: 0.5 }
        ]
      },
      {
        index: 0,
        presets: [
          { index: 0, baseWidth: 1, minWidth: 0.2 },
          { index: 0, baseWidth: 2, minWidth: 0.2 },
          { index: 0, baseWidth: 3, minWidth: 0.2 },
          { index: 0, baseWidth: 4, minWidth: 0.2 },
          { index: 0, baseWidth: 5, minWidth: 0.2 }
        ]
      },
      {
        index: 0,
        presets: [
          { index: 0, baseWidth: 7.5, minWidth: 1 },
          { index: 0, baseWidth: 10, minWidth: 1 },
          { index: 0, baseWidth: 20, minWidth: 1 },
          { index: 0, baseWidth: 30, minWidth: 1 },
          { index: 0, baseWidth: 40, minWidth: 1 },
          { index: 0, baseWidth: 50, minWidth: 1 },
          { index: 0, baseWidth: 7.5, minWidth: 0.5 },
          { index: 0, baseWidth: 10, minWidth: 0.5 },
          { index: 0, baseWidth: 20, minWidth: 0.5 },
          { index: 0, baseWidth: 30, minWidth: 0.5 },
          { index: 0, baseWidth: 40, minWidth: 0.5 },
          { index: 0, baseWidth: 50, minWidth: 0.5 },
          { index: 0, baseWidth: 7.5, minWidth: 0.2 },
          { index: 0, baseWidth: 10, minWidth: 0.2 },
          { index: 0, baseWidth: 20, minWidth: 0.2 },
          { index: 0, baseWidth: 30, minWidth: 0.2 },
          { index: 0, baseWidth: 40, minWidth: 0.2 },
          { index: 0, baseWidth: 50, minWidth: 0.2 }
        ]
      },
      {
        index: 0,
        presets: [
          { index: 0, baseWidth: 60, minWidth: 0.5 },
          { index: 0, baseWidth: 70, minWidth: 0.5 },
          { index: 0, baseWidth: 80, minWidth: 0.5 },
          { index: 0, baseWidth: 90, minWidth: 0.5 },
          { index: 0, baseWidth: 100, minWidth: 0.5 }
        ]
      }
    ];
    initializePresets(groups);
    return groups;
  }, []);
  const the = react.exports.useMemo(() => ({
    canvasRender: new CanvasRender(),
    domResizing: new DOMResizingLogic(),
    previewCanvasWindow: new CanvasWindow(),
    buttonCanvasWindow: new CanvasWindow(),
    popoverContentRef: new UI_PopoverContainerRef(),
    location: vec3.create(),
    localLocation: vec3.create(),
    direction: vec3.create(),
    capMatrix: mat4.create(),
    blackColor: vec4.fromValues(0, 0, 0, 1)
  }), []);
  react.exports.useEffect(() => {
    uiRef.updatePopover = () => {
      if (uiRef.docContext.currentPointerParameter != null) {
        set_brushParams(getPointerParameters(uiRef.docContext));
      }
    };
    uiRef.showPopover = (parentNode) => {
      if (uiRef.docContext.currentPointerParameter != null) {
        set_brushParams(getPointerParameters(uiRef.docContext));
      }
      the.popoverContentRef.show(uiRef, parentNode);
      set_isPopoverShown(true);
      setTimeout(() => {
        set_isCanvasShown(true);
      }, 200);
    };
    return function cleanup() {
      uiRef.showPopover = null;
    };
  }, []);
  react.exports.useEffect(() => {
    if (isCanvasShown) {
      the.previewCanvasWindow.attachCanvas(previewCanvas_Ref.current);
      the.domResizing.resizeCanvasToParent(the.previewCanvasWindow, false);
      the.previewCanvasWindow.initializeContext();
    }
  }, [isCanvasShown]);
  react.exports.useEffect(() => {
    if (isCanvasShown) {
      drawPreview();
    }
  }, [isCanvasShown, brushParams]);
  function initializePresets(presetGroups) {
    let groupIndex = 1;
    for (const group of presetGroups) {
      group.index = groupIndex;
      groupIndex++;
      let presetIndex = 1;
      for (const preset of group.presets) {
        preset.index = presetIndex;
        presetIndex++;
      }
    }
  }
  function drawPreview() {
    drawBrushPreview(
      the.previewCanvasWindow,
      brushParams.pointerType,
      brushParams.isUsingBrushParameter ? brushParams.brushBaseSize : brushParams.pointerBaseSize,
      brushParams.isUsingBrushParameter ? brushParams.brushMinSize : 1,
      brushParams.pointerBaseSize,
      uiRef.docContext.currentPaintParameter.baseColor,
      uiRef.docContext.drawStyle,
      the.canvasRender,
      the
    );
  }
  function popover_Exit() {
    the.popoverContentRef.close(uiRef);
  }
  function pointerBaseSize_sliderChanged(value) {
    uiRef.numberInput_Changed(RibbonUIControlID.pointerBaseSize, value);
  }
  function brushBaseSize_sliderChanged(value) {
    uiRef.numberInput_Changed(RibbonUIControlID.brushBaseSize, value);
  }
  function brushMinSize_sliderChanged(value) {
    uiRef.numberInput_Changed(RibbonUIControlID.brushMinSize, value);
  }
  function preset_Clicked(preset) {
    if (brushParams.isUsingBrushParameter) {
      uiRef.numberInput_Changed(RibbonUIControlID.brushBaseSize, preset.baseWidth);
      uiRef.numberInput_Changed(RibbonUIControlID.brushMinSize, preset.minWidth);
    } else {
      uiRef.numberInput_Changed(RibbonUIControlID.pointerBaseSize, preset.baseWidth);
    }
  }
  return /* @__PURE__ */ react.exports.createElement(UI_PopoverContent, {
    uiRef: the.popoverContentRef,
    fullHeight: true,
    offset: { x: 0, y: -3 },
    onDissmiss: popover_Exit,
    onEscape: popover_Exit
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-property-popover-locator"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-property-popover",
    onClick: (e) => e.stopPropagation()
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "preview-canvas-frame"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "preview-canvas-size-calculator"
  }, /* @__PURE__ */ react.exports.createElement("canvas", {
    className: "preview-canvas alpha-checker-background",
    ref: previewCanvas_Ref
  }))), /* @__PURE__ */ react.exports.createElement("div", {
    className: `param-slider-container${!brushParams.isUsingBrushParameter ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label-text"
  }, "\u57FA\u672C\u5E45")), /* @__PURE__ */ react.exports.createElement(UI_ColorSlider, {
    min: 0,
    max: 100,
    step: 0.05,
    trackColor: "#222",
    showText: true,
    value: brushParams.brushBaseSize,
    onChange: brushBaseSize_sliderChanged
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: `param-slider-container${!brushParams.isUsingBrushParameter ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label-text"
  }, "\u6700\u5C0F\u5E45")), /* @__PURE__ */ react.exports.createElement(UI_ColorSlider, {
    min: 0,
    max: 1,
    step: 0.01,
    trackColor: "#666",
    showText: true,
    value: brushParams.brushMinSize,
    onChange: brushMinSize_sliderChanged
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: `param-slider-container${!brushParams.isUsingPointerParameter ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label-text"
  }, "\u7BC4\u56F2")), /* @__PURE__ */ react.exports.createElement(UI_ColorSlider, {
    min: 0,
    max: 50,
    step: 0.05,
    trackColor: "#f88",
    showText: true,
    value: brushParams.pointerBaseSize,
    onChange: pointerBaseSize_sliderChanged
  })), isPopoverShown && /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-presets-container"
  }, brushPresetGroups.map(
    (group) => /* @__PURE__ */ react.exports.createElement("div", {
      className: "brush-preset-group-container",
      key: group.index
    }, group.presets.map(
      (preset) => /* @__PURE__ */ react.exports.createElement("div", {
        className: "brush-preset-frame",
        key: preset.index
      }, /* @__PURE__ */ react.exports.createElement(BrushThumbnailBox, {
        pointerType: PointerTypeID.brush,
        drawLineBaseWidth: preset.baseWidth,
        drawLineMinWidth: preset.minWidth,
        baseColor: the.blackColor,
        preset,
        drawStyle: uiRef.docContext.drawStyle,
        onPresetClicked: preset_Clicked
      }))
    ))
  )))));
}
function BrushThumbnailBox({ pointerType, drawLineBaseWidth, drawLineMinWidth, drawStyle, baseColor, preset, onPresetClicked }) {
  const canvas_Ref = react.exports.useRef(null);
  const the = react.exports.useMemo(() => ({
    canvasRender: new CanvasRender(),
    domResizing: new DOMResizingLogic(),
    canvasWindow: new CanvasWindow()
  }), []);
  react.exports.useEffect(() => {
    resizeCanvas();
  }, []);
  react.exports.useEffect(() => {
    drawThumbnail();
  }, [pointerType, drawLineBaseWidth, drawLineMinWidth, baseColor[0], baseColor[1], baseColor[2], baseColor[3]]);
  function resizeCanvas() {
    the.canvasWindow.attachCanvas(canvas_Ref.current);
    the.domResizing.resizeCanvasToBoundingClientRect(the.canvasWindow, false);
    the.canvasWindow.initializeContext();
  }
  function drawThumbnail() {
    if (the.canvasWindow.isInitialized()) {
      drawBrushThumbnail(
        the.canvasWindow,
        pointerType,
        drawLineBaseWidth,
        drawLineMinWidth,
        baseColor != null ? baseColor : vec4.fromValues(0, 0, 0, 1),
        drawStyle,
        the.canvasRender
      );
    }
  }
  function thumbnailClicked() {
    if (onPresetClicked && preset) {
      onPresetClicked(preset);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-thumbnail-frame",
    onPointerDown: thumbnailClicked
  }, /* @__PURE__ */ react.exports.createElement("canvas", {
    className: "brush-thumbnail-canvas",
    ref: canvas_Ref
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-size-text-frame back"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-size-text"
  }, drawLineBaseWidth.toFixed(2))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-size-text-frame front"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "brush-size-text"
  }, drawLineBaseWidth.toFixed(2))));
}
function getPointerParameters(docContext) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    isUsingPointerParameter: docContext.currentPointerParameter.parameterID != PointerParameterID.none ? true : false,
    isUsingBrushParameter: docContext.currentBrushParameter.parameterID != BrushParameterID.none ? true : false,
    pointerType: (_b = (_a = docContext.currentSubToolParameter) == null ? void 0 : _a.pointerType) != null ? _b : PointerTypeID.none,
    pointerBaseSize: (_d = (_c = docContext.currentPointerParameter) == null ? void 0 : _c.baseSize) != null ? _d : 0,
    brushBaseSize: (_f = (_e = docContext.currentBrushParameter) == null ? void 0 : _e.baseSize) != null ? _f : 0,
    brushMinSize: (_h = (_g = docContext.currentBrushParameter) == null ? void 0 : _g.minSize) != null ? _h : 0,
    baseColor: (_j = (_i = docContext.currentPaintParameter) == null ? void 0 : _i.baseColor) != null ? _j : vec4.fromValues(0, 0, 0, 1)
  };
}
function drawBrushThumbnail(canvasWindow, pointerType, drawLineBaseWidth, drawLineMinWidth, baseColor, drawStyle, canvasRender) {
  const scaleSettings = [
    { minRadius: 0, maxRadius: 5, scale: 0.4 },
    { minRadius: 5, maxRadius: 50, scale: 0.8 },
    { minRadius: 50, maxRadius: 100, scale: 1 }
  ];
  let scaleSetting = scaleSettings[0];
  for (const setting of scaleSettings) {
    if (drawLineBaseWidth > setting.minRadius) {
      scaleSetting = setting;
    }
  }
  const maxBrushVisualPadding = 0.1;
  const maxBrushVisualWidth = canvasWindow.width * (0.5 - maxBrushVisualPadding);
  const maxBrushWidthScale = maxBrushVisualWidth / scaleSetting.maxRadius;
  let maxRadius = drawLineBaseWidth * maxBrushWidthScale * scaleSetting.scale;
  const minRadius = maxRadius * drawLineMinWidth;
  const centerX = canvasWindow.width / 2;
  const centerY = canvasWindow.height / 2;
  canvasRender.setContext(canvasWindow);
  canvasRender.clear();
  switch (pointerType) {
    case PointerTypeID.brush:
    case PointerTypeID.brushWithCircularRange:
      if (minRadius != maxRadius) {
        canvasRender.setFillColor(0.7, 0.7, 0.7, 1);
        canvasRender.beginPath();
        canvasRender.circle(centerX, centerY, maxRadius);
        canvasRender.fill();
      }
      canvasRender.setFillColor(1, 1, 1, 1);
      canvasRender.beginPath();
      canvasRender.circle(centerX, centerY, minRadius);
      canvasRender.fill();
      canvasRender.setFillColorV(baseColor);
      canvasRender.beginPath();
      canvasRender.circle(centerX, centerY, minRadius);
      canvasRender.fill();
      break;
    case PointerTypeID.circularRange:
      canvasRender.setStrokeColorV(drawStyle.mouseCursorCircleColor);
      canvasRender.beginPath();
      canvasRender.circle(centerX, centerY, maxRadius);
      canvasRender.stroke();
      break;
  }
}
function drawBrushPreview(canvasWindow, pointerType, drawLineBaseWidth, drawLineMinWidth, pointerBaseSize, baseColor, drawStyle, canvasRender, temp) {
  const scaleSettings = [
    { minRadius: 0, maxRadius: 5, scale: 1 },
    { minRadius: 5, maxRadius: 50, scale: 1 },
    { minRadius: 50, maxRadius: 100, scale: 0.5 }
  ];
  let scaleSetting = scaleSettings[0];
  for (const setting of scaleSettings) {
    if (drawLineBaseWidth > setting.minRadius) {
      scaleSetting = setting;
    }
  }
  const radiusVisualScale = 1;
  const maxRadius = drawLineBaseWidth * radiusVisualScale * scaleSetting.scale;
  const minRadius = maxRadius * drawLineMinWidth;
  const target = canvasWindow;
  const previewPadding = 30;
  const previewWidth = target.width - previewPadding * 2;
  const previewXResolution = 20;
  const previewCapUnitAngle = 0.2;
  const corePositionStroke = new VectorStroke();
  for (let xCount = 0; xCount <= previewXResolution - 1; xCount++) {
    const normX = xCount / (previewXResolution - 1);
    const localY = Math.sin(normX * 2 * Math.PI) * target.height / 6;
    const x2 = previewPadding + previewWidth * normX;
    const y2 = target.height / 2 + localY;
    const radius = minRadius + Math.sin(normX * Math.PI) * (maxRadius - minRadius);
    const point = new VectorPoint();
    vec3.copy(point.location, vec3.set(temp.location, x2, y2, 0));
    point.lineWidth = radius;
    corePositionStroke.points.push(point);
  }
  VectorStrokeLogic.smooth(corePositionStroke);
  const resamplingUnitLength = target.width / 40;
  const resampledLine = VectorStrokeLogic.createResampledLine(corePositionStroke, resamplingUnitLength);
  const resampled_FirstPoint = resampledLine.points[0];
  const resampled_SecondPoint = resampledLine.points[1];
  const resampled_LastPreviousPoint = resampledLine.points[resampledLine.points.length - 2];
  const resampled_LastPoint = resampledLine.points[resampledLine.points.length - 1];
  const leftStroke = new VectorStroke();
  const rightStroke = new VectorStroke();
  Logic_Points.segmentMat(temp.capMatrix, resampled_FirstPoint.location, resampled_SecondPoint.location);
  for (let angle = 0; angle < 1; angle += previewCapUnitAngle) {
    const radius = resampled_FirstPoint.lineWidth;
    const x2 = Math.cos(Math.PI - angle * Math.PI / 2) * radius;
    const y2 = -Math.sin(Math.PI - angle * Math.PI / 2) * radius;
    {
      vec3.set(temp.localLocation, x2, y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      leftStroke.points.push(point);
    }
    {
      vec3.set(temp.localLocation, x2, -y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      rightStroke.points.push(point);
    }
  }
  for (let index2 = 0; index2 < resampledLine.points.length - 1; index2++) {
    const point_From = resampledLine.points[index2];
    const point_To = resampledLine.points[index2 + 1];
    Logic_Points.segmentMat(temp.capMatrix, point_From.location, point_To.location);
    const radius = point_From.lineWidth;
    const x2 = 0;
    const y2 = -radius;
    {
      vec3.set(temp.localLocation, x2, y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      leftStroke.points.push(point);
    }
    {
      vec3.set(temp.localLocation, x2, -y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      rightStroke.points.push(point);
    }
  }
  Logic_Points.segmentMat(temp.capMatrix, resampled_LastPreviousPoint.location, resampled_LastPoint.location);
  temp.capMatrix[12] = resampled_LastPoint.location[0];
  temp.capMatrix[13] = resampled_LastPoint.location[1];
  for (let angle = previewCapUnitAngle; angle <= 1; angle += previewCapUnitAngle) {
    const radius = resampled_LastPoint.lineWidth;
    const x2 = Math.cos(Math.PI / 2 - angle * Math.PI / 2) * radius;
    const y2 = -Math.sin(Math.PI / 2 - angle * Math.PI / 2) * radius;
    {
      vec3.set(temp.localLocation, x2, y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      leftStroke.points.push(point);
    }
    {
      vec3.set(temp.localLocation, x2, -y2, 0);
      vec3.transformMat4(temp.location, temp.localLocation, temp.capMatrix);
      const point = new VectorPoint();
      vec3.copy(point.location, temp.location);
      rightStroke.points.push(point);
    }
  }
  canvasRender.setContext(target);
  canvasRender.clear();
  const boundingStroke = new VectorStroke();
  boundingStroke.points = [...leftStroke.points, ...Lists.reverse(rightStroke.points)];
  canvasRender.setStrokeWidth(1);
  canvasRender.beginPath();
  canvasRender.moveToV(boundingStroke.points[0].location);
  for (const point of boundingStroke.points) {
    canvasRender.lineToV(point.location);
  }
  switch (pointerType) {
    case PointerTypeID.brush:
    case PointerTypeID.brushWithCircularRange:
      canvasRender.setFillColorV(baseColor);
      canvasRender.fill();
      break;
    case PointerTypeID.circularRange:
      canvasRender.setStrokeColorV(drawStyle.mouseCursorCircleColor);
      canvasRender.stroke();
      break;
  }
  switch (pointerType) {
    case PointerTypeID.brushWithCircularRange:
      canvasRender.setStrokeColorV(drawStyle.mouseCursorCircleColor);
      canvasRender.beginPath();
      canvasRender.circle(resampled_FirstPoint.location[0], resampled_FirstPoint.location[1], pointerBaseSize);
      canvasRender.stroke();
      break;
  }
}
class UI_MainMenuButtonRef extends PopoverRef {
  constructor() {
    super(...arguments);
    this.docContext = null;
  }
  showPopover(parentNode) {
  }
  commandButton_Clicked(id2) {
  }
}
function UI_MainMenuButton({ uiRef }) {
  const popoverParent_Ref = react.exports.useRef(null);
  const [commandButtonItem] = react.exports.useState(() => ({ index: 1, icon: "menu" }));
  function box_Clicked() {
    uiRef.showPopover(popoverParent_Ref.current);
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "main-menu-button",
    ref: popoverParent_Ref
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButton, {
    commandButtonItem,
    menuButton: true,
    onClick: box_Clicked
  }));
}
function UI_MainMenuPopover({ uiRef }) {
  const popoverContentRef = react.exports.useMemo(() => new UI_PopoverContainerRef(), []);
  const menuItems = react.exports.useMemo(() => {
    return [
      { index: MainCommandButtonID.newFile, icon: "filenew", title: "\u65B0\u898F\u4F5C\u6210" },
      { index: MainCommandButtonID.openFile, icon: "fileopen", title: "\u958B\u304F" },
      { index: MainCommandButtonID.saveFile, icon: "save", title: "\u4FDD\u5B58" },
      { index: MainCommandButtonID.saveAs, icon: "saveas", title: "\u540D\u524D\u3092\u3064\u3051\u3066\u4FDD\u5B58" },
      { index: MainCommandButtonID.export, icon: "export", title: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8" },
      { index: MainCommandButtonID.shortcutKeys, icon: "settings", title: "\u30AD\u30FC\u30DC\u30FC\u30C9\u8A2D\u5B9A" }
    ];
  }, []);
  const [documentFilePath, set_documentFilePath] = react.exports.useState("");
  react.exports.useEffect(() => {
    uiRef.showPopover = (parentNode) => {
      var _a, _b;
      set_documentFilePath(getFileName((_b = (_a = uiRef.docContext) == null ? void 0 : _a.documentFilePath) != null ? _b : ""));
      popoverContentRef.show(uiRef, parentNode);
    };
    return function cleanup() {
      uiRef.showPopover = null;
    };
  }, []);
  function getFileName(filePath) {
    if (Strings.isNullOrEmpty(filePath)) {
      return "";
    }
    return Platform.path.getFileName(filePath);
  }
  function popover_Exit() {
    popoverContentRef.close(uiRef);
  }
  function item_Clicked(item, e) {
    e.stopPropagation();
    popoverContentRef.close(uiRef);
    uiRef.commandButton_Clicked(item.index);
  }
  return /* @__PURE__ */ react.exports.createElement(UI_PopoverContent, {
    uiRef: popoverContentRef,
    offset: { x: 6, y: -3 },
    onDissmiss: popover_Exit,
    onEscape: popover_Exit
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "main-menu-popover",
    onClick: (e) => e.stopPropagation()
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "file-name"
  }, /* @__PURE__ */ react.exports.createElement("input", {
    type: "text",
    readOnly: true,
    value: documentFilePath
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "main-menu-commands-container"
  }, menuItems.map((item) => /* @__PURE__ */ react.exports.createElement("div", {
    key: item.index,
    className: "main-menu-item selectable-item",
    onClick: (e) => item_Clicked(item, e)
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: item.icon
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "main-menu-item-text"
  }, item.title))))));
}
class UI_SelectBoxPopoverRef extends PopoverRef {
  showPopover(parentNode, options, values, popoverAlign, large, onChange) {
  }
}
function UI_SelectBox({
  selectBoxPopoverRef,
  options,
  values,
  placeholder = "",
  title = "",
  className = "",
  popoberAlign = UI_PopoverContainerAlign.bottom,
  border = false,
  large = false,
  onChange
}) {
  const popoverParent_Ref = react.exports.useRef(null);
  function box_Clicked() {
    if (!selectBoxPopoverRef) {
      throw new Error(`ERROR 0000:Please provide select box popover ref for '${title}'`);
    }
    selectBoxPopoverRef.showPopover(popoverParent_Ref.current, options, values, popoberAlign, large, onChange);
  }
  const isSelectionExists = values.length > 0;
  return /* @__PURE__ */ react.exports.createElement("div", {
    title,
    className: `ui-select-box${className ? " " + className : ""}${border ? " button-border" : ""}${large ? " large" : ""}`,
    ref: popoverParent_Ref,
    onClick: box_Clicked
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: `ui-select-box-label${!isSelectionExists ? " placeholder" : ""}`
  }, isSelectionExists ? values[0].label : placeholder), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-select-box-expand"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandmore"
  })));
}
function UI_SelectBoxPopover({ uiRef }) {
  const [options, set_options] = react.exports.useState([]);
  const [values, set_values] = react.exports.useState([]);
  const [large, set_large] = react.exports.useState(false);
  const onChange = react.exports.useRef(null);
  const popoverContentRef = react.exports.useMemo(() => new UI_PopoverContainerRef(), []);
  react.exports.useEffect(() => {
    uiRef.showPopover = (parentNode, new_options, new_values, new_popoverAlign, new_large, new_OnChange) => {
      set_options(new_options);
      set_values(new_values);
      set_large(new_large);
      onChange.current = new_OnChange;
      popoverContentRef.show(uiRef, parentNode, new_popoverAlign);
    };
    return function cleanup() {
      uiRef.showPopover = null;
    };
  }, []);
  function popover_Exit() {
    popoverContentRef.close(uiRef);
  }
  function option_Clicked(item, e) {
    e.stopPropagation();
    popoverContentRef.close(uiRef);
    if (onChange.current) {
      onChange.current(item);
    }
  }
  return /* @__PURE__ */ react.exports.createElement(UI_PopoverContent, {
    uiRef: popoverContentRef,
    onDissmiss: popover_Exit,
    onEscape: popover_Exit
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "ui-select-box-popover",
    onClick: (e) => e.stopPropagation()
  }, options.map((item) => /* @__PURE__ */ react.exports.createElement("div", {
    key: item.index,
    className: `ui-select-box-list-item ${large ? "large" : ""} selectable-item ${values.find((val) => val.index == item.index) ? "selected" : ""}`,
    onClick: (e) => option_Clicked(item, e)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "selectable-item-inner"
  }, item.label)))));
}
function UI_PopoverRouter({ mainMenuUIRef, brushPropertyBoxRef, selectBoxRef }) {
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(UI_MainMenuPopover, {
    uiRef: mainMenuUIRef
  }), /* @__PURE__ */ react.exports.createElement(UI_BrushPropertyBoxPopover, {
    uiRef: brushPropertyBoxRef
  }), /* @__PURE__ */ react.exports.createElement(UI_SelectBoxPopover, {
    uiRef: selectBoxRef
  }));
}
class PopoverLogic {
  constructor() {
    this.mainMenuUIRef = new UI_MainMenuButtonRef();
    this.brushPropertyBoxRef = new UI_BrushPropertyBoxRef();
    this.selectBoxPopoverRef = new UI_SelectBoxPopoverRef();
    this._isOpened = false;
    this.setCallbacks(this.mainMenuUIRef);
    this.setCallbacks(this.brushPropertyBoxRef);
    this.setCallbacks(this.selectBoxPopoverRef);
  }
  setCallbacks(ref) {
    ref.onPopoverOpened = () => {
      this._isOpened = true;
    };
    ref.onPopoverClosed = () => {
      this._isOpened = false;
    };
  }
  isActive() {
    return this._isOpened;
  }
}
class RibbonUIWindow {
  constructor() {
    this.uiRibbonUIRef = {
      docContext: null,
      ribbonUITabsRef: {},
      mainMenuButtonRef: null,
      brushPropertyBoxRef: null,
      selectBoxPopoverRef: null,
      updateMainToolTabFunctionInfos: [],
      posingLayerOptions: [],
      posingLayerOptions_Selected: []
    };
  }
  link(mainMenuButtonRef, brushPropertyBoxRef, selectBoxPopoverRef) {
    this.uiRibbonUIRef.mainMenuButtonRef = mainMenuButtonRef;
    this.uiRibbonUIRef.brushPropertyBoxRef = brushPropertyBoxRef;
    this.uiRibbonUIRef.selectBoxPopoverRef = selectBoxPopoverRef;
    this.uiRibbonUIRef.registerTabFunctionInfo = (info) => {
      this.uiRibbonUIRef.updateMainToolTabFunctionInfos.push(info);
    };
    this.uiRibbonUIRef.unregisterTabFunctionInfo = (info) => {
      this.uiRibbonUIRef.updateMainToolTabFunctionInfos = this.uiRibbonUIRef.updateMainToolTabFunctionInfos.filter((i) => i !== info);
    };
  }
  setContext(docContext) {
    this.uiRibbonUIRef.docContext = docContext;
    this.uiRibbonUIRef.mainMenuButtonRef.docContext = docContext;
    this.uiRibbonUIRef.brushPropertyBoxRef.docContext = docContext;
  }
  switchTabAndRibbon(docContext) {
    this.setContext(docContext);
    if (this.uiRibbonUIRef.ribbonUITabsRef.update) {
      this.uiRibbonUIRef.ribbonUITabsRef.update(docContext);
    }
    if (this.uiRibbonUIRef.setMainToolTab) {
      this.uiRibbonUIRef.setMainToolTab(docContext.mainToolTabID);
    }
    this.getFilteredTabFunctionInfos(docContext).forEach((info) => {
      if (info.onActivated) {
        info.onActivated(docContext);
      }
    });
  }
  updateMainToolRibbonUI(docContext) {
    this.setContext(docContext);
    this.getFilteredTabFunctionInfos(docContext).forEach((info) => {
      info.update(docContext);
    });
  }
  getFilteredTabFunctionInfos(docContext) {
    return this.uiRibbonUIRef.updateMainToolTabFunctionInfos.filter((info) => info.tabID.findIndex((tabID) => tabID == docContext.mainToolTabID) != -1).filter((info) => !info.filter || info.filter(docContext.currentLayer));
  }
  updateLayerRibbonUI(docContext, posingLayerOptions) {
    this.setContext(docContext);
    if (docContext.mainToolTabID == MainToolTabID.layer && docContext.currentVectorLayer != null) {
      this.uiRibbonUIRef.posingLayerOptions = posingLayerOptions;
      this.uiRibbonUIRef.posingLayerOptions_Selected = posingLayerOptions.filter((option) => option.data == docContext.currentVectorLayer.runtime.posingLayer);
      this.updateMainToolRibbonUI(docContext);
    }
  }
}
class SubToolViewItemOptionButton extends RectangleLayoutArea {
}
class SubToolViewItem extends RectangleLayoutArea {
  constructor() {
    super(...arguments);
    this.subToolID = SubToolID.none;
    this.isAvailable = false;
    this.buttonStateID = InputSideID.front;
    this.tool = null;
    this.buttons = [];
  }
}
class SubToolWindow {
  constructor() {
    this.subToolViewItems = [];
    this.uiSubToolWindowRef = { items: [] };
    this.subToolItemSelectedColor = vec4.fromValues(0.9, 0.9, 1, 1);
    this.subToolItemSeperatorLineColor = vec4.fromValues(0, 0, 0, 0.5);
  }
  collectViewItems(subTools, ctx) {
    this.subToolViewItems = [];
    for (const subtool of subTools) {
      const viewItem = new SubToolViewItem();
      viewItem.subToolID = subtool.subtoolID;
      viewItem.tool = subtool;
      for (let buttonIndex = 0; buttonIndex < subtool.inputOptionButtonCount; buttonIndex++) {
        const button = new SubToolViewItemOptionButton();
        button.index = buttonIndex;
        viewItem.buttons.push(button);
      }
      this.updateItemState(viewItem, ctx);
      this.subToolViewItems.push(viewItem);
    }
    this.uiSubToolWindowRef.items = this.subToolViewItems;
  }
  updateViewItemState(ctx) {
    for (const viewItem of this.subToolViewItems) {
      this.updateItemState(viewItem, ctx);
    }
  }
  updateItemState(viewItem, ctx) {
    viewItem.isAvailable = viewItem.tool.isAvailable(ctx);
    if (viewItem.buttons.length > 0) {
      viewItem.buttonStateID = viewItem.tool.getOptionButtonState(0, ctx);
    }
  }
}
class TimeLineWindow {
  constructor() {
    this.uiTimeLineWindowRef = {};
    this.canvasWindow = new PointerInputWindow();
    this.canvasRender = null;
    this.drawStyle = null;
    this.systemImage = null;
    this.dom = null;
    this.leftPanelWidth = 100;
    this.frameUnitWidth = 8;
  }
  link(canvasRender, drawStyle, dom, selectBoxRef) {
    this.canvasRender = canvasRender;
    this.drawStyle = drawStyle;
    this.dom = dom;
    this.uiTimeLineWindowRef.selectBoxPopoverRef = selectBoxRef;
  }
  isVisible() {
    const container = this.getContainer();
    return this.isContainerVisible(container);
  }
  setVisibility(visible) {
    const container = this.getContainer();
    if (visible) {
      container.classList.remove("hidden");
    } else {
      container.classList.add("hidden");
    }
  }
  toggleVisibility() {
    const container = this.getContainer();
    if (this.isContainerVisible(container)) {
      this.setVisibility(false);
    } else {
      this.setVisibility(true);
    }
  }
  getContainer() {
    return this.dom.getElement(this.dom.ID.timeLineWindow);
  }
  isContainerVisible(container) {
    return !container.classList.contains("hidden");
  }
  getFrameUnitWidth(aniSetting) {
    return this.frameUnitWidth * aniSetting.timeLineWindowScale;
  }
  getTimeLineLeft() {
    return this.leftPanelWidth;
  }
  getTimeLineRight() {
    return this.getTimeLineLeft() + this.canvasWindow.width - 1;
  }
  getFrameByLocation(x2, aniSetting) {
    const left = this.getTimeLineLeft();
    const right = this.getTimeLineRight();
    if (x2 < left) {
      return -1;
    }
    if (x2 > right) {
      return -1;
    }
    const frameUnitWidth = this.getFrameUnitWidth(aniSetting);
    const absoluteX = x2 - (left - aniSetting.timeLineWindowViewLocationX);
    let frame = Math.floor(absoluteX / frameUnitWidth);
    if (frame < 0) {
      frame = 0;
    }
    return frame;
  }
  getFrameLocation(frame, aniSetting) {
    const left = this.getTimeLineLeft();
    const frameUnitWidth = this.getFrameUnitWidth(aniSetting);
    const x2 = left - aniSetting.timeLineWindowViewLocationX + frame * frameUnitWidth;
    return x2;
  }
  drawCommandButton(ctx) {
    this.canvasRender.setContext(this.canvasWindow);
    {
      let srcX = 0;
      const srcY = 196;
      const srcW = 128;
      const srcH = 128;
      const dstW = 45;
      const dstH = 45;
      const dstX = this.getTimeLineLeft() / 2 - dstW / 2 + 1;
      const dstY = this.canvasWindow.height / 2 - dstH / 2 + 1;
      if (ctx.animationPlaying) {
        srcX = 128;
      }
      this.canvasRender.drawImage(this.systemImage.image.imageData, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
    }
    this.uiTimeLineWindowRef.update(ctx);
  }
  drawTimeLine(ctx) {
    this.canvasRender.setContext(this.canvasWindow);
    const viewKeyframes = ctx.keyframes;
    const currentVectorLayer = ctx.currentLayer;
    const aniSetting = ctx.documentData.animationSettingData;
    const left = this.getTimeLineLeft();
    const right = this.getTimeLineRight();
    const bottom = this.canvasWindow.height;
    const frameUnitWidth = this.getFrameUnitWidth(aniSetting);
    const frameNumberHeight = 16;
    const frameLineBottom = this.canvasWindow.height - 1 - frameNumberHeight;
    const frameLineHeight = 10;
    const secondFrameLineHeight = 30;
    const currentFrameX = left - aniSetting.timeLineWindowViewLocationX + aniSetting.currentTimeFrame * frameUnitWidth;
    this.canvasRender.setStrokeWidth(1);
    this.canvasRender.setFillColorV(this.drawStyle.timeLineCurrentFrameColor);
    this.canvasRender.fillRect(currentFrameX, 0, frameUnitWidth, bottom);
    let minFrame = this.getFrameByLocation(left, aniSetting);
    if (minFrame < 0) {
      minFrame = 0;
    }
    let maxFrame = this.getFrameByLocation(right, aniSetting);
    if (maxFrame > aniSetting.maxFrame) {
      maxFrame = aniSetting.maxFrame;
    }
    this.canvasRender.setStrokeWidth(1);
    this.canvasRender.setFillColorV(this.drawStyle.timeLineKeyFrameColor);
    for (const viewKeyframe of viewKeyframes) {
      const frame = viewKeyframe.frame;
      if (frame < minFrame) {
        continue;
      }
      if (frame > maxFrame) {
        break;
      }
      const frameX = this.getFrameLocation(frame, aniSetting);
      this.canvasRender.fillRect(frameX, 0, frameUnitWidth - 1, frameLineBottom);
    }
    this.canvasRender.setFillColorV(this.drawStyle.timeLineOutOfLoopingColor);
    {
      const frameX = this.getFrameLocation(aniSetting.loopStartFrame, aniSetting);
      if (frameX > left) {
        this.canvasRender.fillRect(left, 0, frameX - left, bottom);
      }
    }
    {
      const frameX = this.getFrameLocation(aniSetting.loopEndFrame + 1, aniSetting);
      if (frameX < right) {
        this.canvasRender.fillRect(frameX, 0, right - frameX, bottom);
      }
    }
    this.canvasRender.setStrokeWidth(1);
    this.canvasRender.setFillColorV(this.drawStyle.timeLineLayerKeyFrameColor);
    if (currentVectorLayer != null) {
      const viewKeyFrame = ViewKeyframe.findViewKeyframe(viewKeyframes, aniSetting.currentTimeFrame);
      let layerIndex = -1;
      if (viewKeyFrame != null) {
        layerIndex = ViewKeyframe.findViewKeyframeLayerIndex(viewKeyFrame, currentVectorLayer);
      }
      if (layerIndex != -1) {
        for (const viewKeyframe of viewKeyframes) {
          const frame = viewKeyframe.frame;
          if (frame < minFrame) {
            continue;
          }
          if (frame > maxFrame) {
            break;
          }
          const viewKeyFrameLayer = viewKeyframe.layers[layerIndex];
          if (viewKeyFrameLayer.hasActualFrame) {
            const frameX = this.getFrameLocation(frame, aniSetting);
            this.canvasRender.fillRect(frameX + 2, 0, frameUnitWidth - 5, frameLineBottom);
          }
        }
      }
    }
    this.canvasRender.setGlobalAlpha(1);
    this.canvasRender.setStrokeWidth(1);
    this.canvasRender.setStrokeColorV(this.drawStyle.timeLineUnitFrameColor);
    this.canvasRender.drawLine(left, 0, left, this.canvasWindow.height);
    {
      let x2 = left;
      for (let frame = minFrame; frame <= maxFrame + 1; frame++) {
        if (frame % aniSetting.animationFrameParSecond == 0 || frame == maxFrame + 1) {
          this.canvasRender.drawLine(x2, frameLineBottom - secondFrameLineHeight, x2, frameLineBottom);
        }
        this.canvasRender.drawLine(x2, frameLineBottom - frameLineHeight, x2, frameLineBottom);
        x2 += frameUnitWidth;
      }
    }
    this.canvasRender.drawLine(left, frameLineBottom, right, frameLineBottom);
  }
}
class LocalSetting {
  constructor() {
    this.currentDirectoryPath = null;
    this.referenceDirectoryPath = "";
    this.autoNumberingEnabled = false;
    this.exportPath = null;
    this.lastUsedFilePaths = [];
    this.maxLastUsedFilePaths = 5;
    this.fileSections = [];
    this.uiStates = [];
    this.shortcutKeySettings = [];
  }
}
class UIStateNames {
}
UIStateNames.touchOperationPanel = "touchOperationPanel";
UIStateNames.layerWindow = "layerWindow";
UIStateNames.paletteSelectorWindow = "paletteSelectorWindow";
UIStateNames.colorMixerWindow = "colorMixerWindow";
UIStateNames.timeLineWindow = "timeLineWindow";
var ShortcutCommandID = /* @__PURE__ */ ((ShortcutCommandID2) => {
  ShortcutCommandID2[ShortcutCommandID2["none"] = 0] = "none";
  ShortcutCommandID2[ShortcutCommandID2["setting_shortcutKey"] = 101] = "setting_shortcutKey";
  ShortcutCommandID2[ShortcutCommandID2["document_new"] = 201] = "document_new";
  ShortcutCommandID2[ShortcutCommandID2["document_save"] = 202] = "document_save";
  ShortcutCommandID2[ShortcutCommandID2["document_saveAs"] = 203] = "document_saveAs";
  ShortcutCommandID2[ShortcutCommandID2["document_open"] = 204] = "document_open";
  ShortcutCommandID2[ShortcutCommandID2["document_export"] = 205] = "document_export";
  ShortcutCommandID2[ShortcutCommandID2["view_pan"] = 301] = "view_pan";
  ShortcutCommandID2[ShortcutCommandID2["view_zoomIn"] = 302] = "view_zoomIn";
  ShortcutCommandID2[ShortcutCommandID2["view_zoomOut"] = 303] = "view_zoomOut";
  ShortcutCommandID2[ShortcutCommandID2["view_rotateCW"] = 304] = "view_rotateCW";
  ShortcutCommandID2[ShortcutCommandID2["view_rotateCCW"] = 305] = "view_rotateCCW";
  ShortcutCommandID2[ShortcutCommandID2["view_mirrorX"] = 306] = "view_mirrorX";
  ShortcutCommandID2[ShortcutCommandID2["view_mirrorY"] = 307] = "view_mirrorY";
  ShortcutCommandID2[ShortcutCommandID2["view_reset"] = 308] = "view_reset";
  ShortcutCommandID2[ShortcutCommandID2["view_toggleHome"] = 309] = "view_toggleHome";
  ShortcutCommandID2[ShortcutCommandID2["view_toggleLayerPanel"] = 310] = "view_toggleLayerPanel";
  ShortcutCommandID2[ShortcutCommandID2["view_togglePalletePanel"] = 311] = "view_togglePalletePanel";
  ShortcutCommandID2[ShortcutCommandID2["view_toggleMixerPanel"] = 312] = "view_toggleMixerPanel";
  ShortcutCommandID2[ShortcutCommandID2["edit_undo"] = 401] = "edit_undo";
  ShortcutCommandID2[ShortcutCommandID2["edit_redo"] = 402] = "edit_redo";
  ShortcutCommandID2[ShortcutCommandID2["edit_copy"] = 403] = "edit_copy";
  ShortcutCommandID2[ShortcutCommandID2["edit_cut"] = 404] = "edit_cut";
  ShortcutCommandID2[ShortcutCommandID2["edit_paste"] = 405] = "edit_paste";
  ShortcutCommandID2[ShortcutCommandID2["edit_delete"] = 406] = "edit_delete";
  ShortcutCommandID2[ShortcutCommandID2["edit_fix"] = 407] = "edit_fix";
  ShortcutCommandID2[ShortcutCommandID2["edit_selectAll"] = 409] = "edit_selectAll";
  ShortcutCommandID2[ShortcutCommandID2["edit_cancel"] = 408] = "edit_cancel";
  ShortcutCommandID2[ShortcutCommandID2["edit_unselectAll"] = 410] = "edit_unselectAll";
  ShortcutCommandID2[ShortcutCommandID2["edit_grabMove"] = 411] = "edit_grabMove";
  ShortcutCommandID2[ShortcutCommandID2["edit_rotate"] = 412] = "edit_rotate";
  ShortcutCommandID2[ShortcutCommandID2["edit_scale"] = 413] = "edit_scale";
  ShortcutCommandID2[ShortcutCommandID2["edit_setPibot"] = 414] = "edit_setPibot";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool1"] = 501] = "tool_subTool1";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool2"] = 502] = "tool_subTool2";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool3"] = 503] = "tool_subTool3";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool4"] = 504] = "tool_subTool4";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool5"] = 505] = "tool_subTool5";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool6"] = 506] = "tool_subTool6";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool7"] = 507] = "tool_subTool7";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool8"] = 508] = "tool_subTool8";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool9"] = 509] = "tool_subTool9";
  ShortcutCommandID2[ShortcutCommandID2["tool_subTool0"] = 510] = "tool_subTool0";
  ShortcutCommandID2[ShortcutCommandID2["tool_toggleMainEdit"] = 511] = "tool_toggleMainEdit";
  ShortcutCommandID2[ShortcutCommandID2["tool_togglePenEraser"] = 512] = "tool_togglePenEraser";
  ShortcutCommandID2[ShortcutCommandID2["layer_newLayer"] = 601] = "layer_newLayer";
  ShortcutCommandID2[ShortcutCommandID2["layer_pickLayer"] = 602] = "layer_pickLayer";
  ShortcutCommandID2[ShortcutCommandID2["layer_previousLayer"] = 603] = "layer_previousLayer";
  ShortcutCommandID2[ShortcutCommandID2["layer_nextLayer"] = 604] = "layer_nextLayer";
  ShortcutCommandID2[ShortcutCommandID2["timeline_previousKeyframe"] = 701] = "timeline_previousKeyframe";
  ShortcutCommandID2[ShortcutCommandID2["timeline_nextKeyframe"] = 702] = "timeline_nextKeyframe";
  return ShortcutCommandID2;
})(ShortcutCommandID || {});
class ShortcutKeyLogic {
  constructor() {
    this.shortcutKeys = [];
    this.modifierKeys = [];
    this.shortcutCategorys = [];
    this.shortcutCommands = [];
    this.shortcutKeySettings = [];
    this.cache_key = "";
    this.cache_shiftKey = false;
    this.cacche_ctrlKey = false;
    this.cache_altKey = false;
    this.cached_shortcutKeySettings = [];
  }
  initializeDefaultSettings() {
    const keys = this.createDefaultShortcutKeys();
    const commands = this.createDefaultShortcutCommands();
    this.shortcutKeys = keys.shortcutKeys;
    this.modifierKeys = keys.modifierKeys;
    this.shortcutCategorys = commands.shortcutCategorys;
    this.shortcutCommands = commands.shortcutCommands;
    this.shortcutKeySettings = this.createDefaultShortcutKeySettings();
  }
  createDefaultShortcutKeys() {
    const shortcutKeys = [
      { shortcutKeyID: 1, keyName: "1", keyString: "1", lineNumber: 0 },
      { shortcutKeyID: 2, keyName: "2", keyString: "2", lineNumber: 0 },
      { shortcutKeyID: 3, keyName: "3", keyString: "3", lineNumber: 0 },
      { shortcutKeyID: 4, keyName: "4", keyString: "4", lineNumber: 0 },
      { shortcutKeyID: 5, keyName: "5", keyString: "5", lineNumber: 0 },
      { shortcutKeyID: 6, keyName: "6", keyString: "6", lineNumber: 0 },
      { shortcutKeyID: 7, keyName: "7", keyString: "7", lineNumber: 0 },
      { shortcutKeyID: 8, keyName: "8", keyString: "8", lineNumber: 0 },
      { shortcutKeyID: 9, keyName: "9", keyString: "9", lineNumber: 0 },
      { shortcutKeyID: 10, keyName: "0", keyString: "0", lineNumber: 0 },
      { shortcutKeyID: 11, keyName: "A", keyString: "A", lineNumber: 0 },
      { shortcutKeyID: 12, keyName: "B", keyString: "B", lineNumber: 0 },
      { shortcutKeyID: 13, keyName: "C", keyString: "C", lineNumber: 0 },
      { shortcutKeyID: 14, keyName: "D", keyString: "D", lineNumber: 0 },
      { shortcutKeyID: 15, keyName: "E", keyString: "E", lineNumber: 0 },
      { shortcutKeyID: 16, keyName: "F", keyString: "F", lineNumber: 0 },
      { shortcutKeyID: 17, keyName: "G", keyString: "G", lineNumber: 0 },
      { shortcutKeyID: 18, keyName: "H", keyString: "H", lineNumber: 0 },
      { shortcutKeyID: 19, keyName: "I", keyString: "I", lineNumber: 0 },
      { shortcutKeyID: 20, keyName: "J", keyString: "J", lineNumber: 0 },
      { shortcutKeyID: 21, keyName: "K", keyString: "K", lineNumber: 0 },
      { shortcutKeyID: 22, keyName: "L", keyString: "L", lineNumber: 0 },
      { shortcutKeyID: 23, keyName: "M", keyString: "M", lineNumber: 0 },
      { shortcutKeyID: 24, keyName: "N", keyString: "N", lineNumber: 0 },
      { shortcutKeyID: 25, keyName: "O", keyString: "O", lineNumber: 0 },
      { shortcutKeyID: 26, keyName: "P", keyString: "P", lineNumber: 0 },
      { shortcutKeyID: 27, keyName: "Q", keyString: "Q", lineNumber: 0 },
      { shortcutKeyID: 28, keyName: "R", keyString: "R", lineNumber: 0 },
      { shortcutKeyID: 29, keyName: "S", keyString: "S", lineNumber: 0 },
      { shortcutKeyID: 30, keyName: "T", keyString: "T", lineNumber: 0 },
      { shortcutKeyID: 31, keyName: "U", keyString: "U", lineNumber: 0 },
      { shortcutKeyID: 32, keyName: "V", keyString: "V", lineNumber: 0 },
      { shortcutKeyID: 33, keyName: "W", keyString: "W", lineNumber: 0 },
      { shortcutKeyID: 34, keyName: "X", keyString: "X", lineNumber: 0 },
      { shortcutKeyID: 35, keyName: "Y", keyString: "Y", lineNumber: 0 },
      { shortcutKeyID: 36, keyName: "Z", keyString: "Z", lineNumber: 0 },
      { shortcutKeyID: 37, keyName: "-", keyString: "-", lineNumber: 0 },
      { shortcutKeyID: 38, keyName: "^", keyString: "^", lineNumber: 0 },
      { shortcutKeyID: 39, keyName: "|", keyString: "|", lineNumber: 0 },
      { shortcutKeyID: 40, keyName: "@", keyString: "@", lineNumber: 0 },
      { shortcutKeyID: 41, keyName: "[", keyString: "[", lineNumber: 0 },
      { shortcutKeyID: 42, keyName: "]", keyString: "]", lineNumber: 0 },
      { shortcutKeyID: 43, keyName: ";", keyString: ";", lineNumber: 0 },
      { shortcutKeyID: 44, keyName: ":", keyString: ":", lineNumber: 0 },
      { shortcutKeyID: 45, keyName: ",", keyString: ",", lineNumber: 0 },
      { shortcutKeyID: 46, keyName: ".", keyString: ".", lineNumber: 0 },
      { shortcutKeyID: 47, keyName: "/", keyString: "/", lineNumber: 0 },
      { shortcutKeyID: 48, keyName: "\\", keyString: "\\", lineNumber: 0 },
      { shortcutKeyID: 49, keyName: "Up", keyString: "ArrowUp", lineNumber: 0 },
      { shortcutKeyID: 50, keyName: "Right", keyString: "ArrowRight", lineNumber: 0 },
      { shortcutKeyID: 51, keyName: "Down", keyString: "ArrowDown", lineNumber: 0 },
      { shortcutKeyID: 52, keyName: "Left", keyString: "ArrowLeft", lineNumber: 0 },
      { shortcutKeyID: 53, keyName: "Space", keyString: " ", lineNumber: 0 },
      { shortcutKeyID: 54, keyName: "Delete", keyString: "Delete", lineNumber: 0 },
      { shortcutKeyID: 55, keyName: "BackSpace", keyString: "BackSpace", lineNumber: 0 },
      { shortcutKeyID: 56, keyName: "Enter", keyString: "Enter", lineNumber: 0 },
      { shortcutKeyID: 57, keyName: "Escape", keyString: "Escape", lineNumber: 0 },
      { shortcutKeyID: 58, keyName: "Tab", keyString: "Tab", lineNumber: 0 },
      { shortcutKeyID: 59, keyName: "Home", keyString: "Home", lineNumber: 0 }
    ];
    {
      let lineNumber = 1;
      shortcutKeys.forEach((item) => item.lineNumber = lineNumber++);
    }
    const modifierKeys = [
      { modifierKeyID: 1, keyName: "", lineNumber: 0 },
      { modifierKeyID: 2, keyName: "Ctrl", lineNumber: 0 },
      { modifierKeyID: 3, keyName: "Shift", lineNumber: 0 },
      { modifierKeyID: 4, keyName: "Alt", lineNumber: 0 }
    ];
    {
      let lineNumber = 1;
      modifierKeys.forEach((item) => item.lineNumber = lineNumber++);
    }
    return {
      shortcutKeys,
      modifierKeys
    };
  }
  createDefaultShortcutCommands() {
    var _a;
    const shortcutCategorys = [
      { categoryID: 1, categoryName: "\u30E1\u30CB\u30E5\u30FC", lineNumber: 0 },
      { categoryID: 2, categoryName: "\u8868\u793A", lineNumber: 0 },
      { categoryID: 3, categoryName: "\u30C4\u30FC\u30EB", lineNumber: 0 },
      { categoryID: 4, categoryName: "\u7DE8\u96C6", lineNumber: 0 },
      { categoryID: 5, categoryName: "\u30EC\u30A4\u30E4\u30FC", lineNumber: 0 },
      { categoryID: 6, categoryName: "\u30E9\u30A4\u30E0\u30E9\u30A4\u30F3", lineNumber: 0 }
    ];
    {
      let lineNumber2 = 1;
      shortcutCategorys.forEach((item) => item.lineNumber = lineNumber2++);
    }
    const shortcutCommands = [];
    let categoryID = 1;
    this.addCommand(shortcutCommands, 201, "\u65B0\u898F\u4F5C\u6210", categoryID);
    this.addCommand(shortcutCommands, 202, "\u4FDD\u5B58", categoryID);
    this.addCommand(shortcutCommands, 203, "\u540D\u524D\u3092\u3064\u3051\u3066\u4FDD\u5B58", categoryID);
    this.addCommand(shortcutCommands, 204, "\u958B\u304F", categoryID);
    this.addCommand(shortcutCommands, 205, "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8", categoryID);
    this.addCommand(shortcutCommands, 101, "\u30AD\u30FC\u30DC\u30FC\u30C9\u8A2D\u5B9A", categoryID);
    categoryID = 2;
    this.addCommand(shortcutCommands, 301, "\u30D3\u30E5\u30FC\u3092\u79FB\u52D5", categoryID);
    this.addCommand(shortcutCommands, 302, "\u30D3\u30E5\u30FC\u3092\u62E1\u5927", categoryID);
    this.addCommand(shortcutCommands, 303, "\u30D3\u30E5\u30FC\u3092\u7E2E\u5C0F", categoryID);
    this.addCommand(shortcutCommands, 304, "\u30D3\u30E5\u30FC\u3092\u53F3\u306B\u56DE\u8EE2", categoryID);
    this.addCommand(shortcutCommands, 305, "\u30D3\u30E5\u30FC\u3092\u5DE6\u306B\u56DE\u8EE2", categoryID);
    this.addCommand(shortcutCommands, 306, "\u5DE6\u53F3\u53CD\u8EE2", categoryID);
    this.addCommand(shortcutCommands, 308, "\u30D3\u30E5\u30FC\u3092\u30EA\u30BB\u30C3\u30C8", categoryID);
    this.addCommand(shortcutCommands, 309, "\u30D3\u30E5\u30FC\u306E\u4F4D\u7F6E\u3092\u623B\u3059", categoryID);
    this.addCommand(shortcutCommands, 310, "\u30EC\u30A4\u30E4\u30FC\u30D1\u30CD\u30EB\u306E\u8868\u793A", categoryID);
    this.addCommand(shortcutCommands, 311, "\u30D1\u30EC\u30C3\u30C8\u30D1\u30CD\u30EB\u306E\u8868\u793A", categoryID);
    this.addCommand(shortcutCommands, 312, "\u30AB\u30E9\u30FC\u30DF\u30AD\u30B5\u30FC\u30D1\u30CD\u30EB\u306E\u8868\u793A", categoryID);
    categoryID = 4;
    this.addCommand(shortcutCommands, 401, "\u3082\u3068\u306B\u623B\u3059", categoryID);
    this.addCommand(shortcutCommands, 402, "\u3084\u308A\u306A\u304A\u3059", categoryID);
    this.addCommand(shortcutCommands, 403, "\u30B3\u30D4\u30FC", categoryID);
    this.addCommand(shortcutCommands, 404, "\u5207\u308A\u53D6\u308A", categoryID);
    this.addCommand(shortcutCommands, 405, "\u8CBC\u308A\u4ED8\u3051", categoryID);
    this.addCommand(shortcutCommands, 406, "\u524A\u9664", categoryID);
    this.addCommand(shortcutCommands, 407, "\u78BA\u5B9A", categoryID);
    this.addCommand(shortcutCommands, 408, "\u30AD\u30E3\u30F3\u30BB\u30EB", categoryID);
    this.addCommand(shortcutCommands, 409, "\u5168\u3066\u9078\u629E", categoryID);
    this.addCommand(shortcutCommands, 410, "\u9078\u629E\u89E3\u9664", categoryID);
    this.addCommand(shortcutCommands, 411, "\u79FB\u52D5", categoryID);
    this.addCommand(shortcutCommands, 412, "\u56DE\u8EE2", categoryID);
    this.addCommand(shortcutCommands, 413, "\u62E1\u5927/\u7E2E\u5C0F", categoryID);
    this.addCommand(shortcutCommands, 414, "\u30D4\u30DC\u30C3\u30C8\u306E\u6307\u5B9A", categoryID);
    categoryID = 3;
    this.addCommand(shortcutCommands, 501, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF11", categoryID);
    this.addCommand(shortcutCommands, 502, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF12", categoryID);
    this.addCommand(shortcutCommands, 503, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF13", categoryID);
    this.addCommand(shortcutCommands, 504, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF14", categoryID);
    this.addCommand(shortcutCommands, 505, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF15", categoryID);
    this.addCommand(shortcutCommands, 506, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF16", categoryID);
    this.addCommand(shortcutCommands, 507, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF17", categoryID);
    this.addCommand(shortcutCommands, 508, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF18", categoryID);
    this.addCommand(shortcutCommands, 509, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF19", categoryID);
    this.addCommand(shortcutCommands, 510, "\u30B5\u30D6\u30C4\u30FC\u30EB\uFF10", categoryID);
    this.addCommand(shortcutCommands, 511, "\u30E1\u30A4\u30F3/\u7DE8\u96C6", categoryID);
    this.addCommand(shortcutCommands, 512, "\u30DA\u30F3/\u6D88\u3057\u30B4\u30E0", categoryID);
    categoryID = 5;
    this.addCommand(shortcutCommands, 601, "\u30EC\u30A4\u30E4\u30FC\u3092\u4F5C\u6210", categoryID);
    this.addCommand(shortcutCommands, 602, "\u30EC\u30A4\u30E4\u30FC\u306E\u9078\u629E", categoryID);
    this.addCommand(shortcutCommands, 603, "\u4E0A\u306E\u30EC\u30A4\u30E4\u30FC\u3092\u9078\u629E", categoryID);
    this.addCommand(shortcutCommands, 604, "\u4E0B\u306E\u30EC\u30A4\u30E4\u30FC\u3092\u9078\u629E", categoryID);
    categoryID = 6;
    this.addCommand(shortcutCommands, 701, "\u524D\u306E\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0", categoryID);
    this.addCommand(shortcutCommands, 702, "\u6B21\u306E\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0", categoryID);
    let lineNumber = 1;
    for (const command of shortcutCommands) {
      command.lineNumber = lineNumber++;
      command.category = (_a = shortcutCategorys.find((category) => category.categoryID == command.categoryID)) != null ? _a : null;
    }
    return {
      shortcutCategorys,
      shortcutCommands
    };
  }
  createDefaultShortcutKeySettings() {
    const tempSettings = [];
    tempSettings.push({ commandID: 201, key: "N", modifier: "Ctrl" });
    tempSettings.push({ commandID: 202, key: "S", modifier: "Ctrl" });
    tempSettings.push({ commandID: 301, key: "Space", modifier: "" });
    tempSettings.push({ commandID: 302, key: "F", modifier: "" });
    tempSettings.push({ commandID: 303, key: "D", modifier: "" });
    tempSettings.push({ commandID: 304, key: "R", modifier: "" });
    tempSettings.push({ commandID: 305, key: "T", modifier: "" });
    tempSettings.push({ commandID: 306, key: "M", modifier: "" });
    tempSettings.push({ commandID: 309, key: "Q", modifier: "Shift" });
    tempSettings.push({ commandID: 309, key: "Q", modifier: "" });
    tempSettings.push({ commandID: 309, key: "Home", modifier: "" });
    tempSettings.push({ commandID: 401, key: "Z", modifier: "" });
    tempSettings.push({ commandID: 401, key: "Z", modifier: "Ctrl" });
    tempSettings.push({ commandID: 402, key: "Y", modifier: "" });
    tempSettings.push({ commandID: 402, key: "Y", modifier: "Ctrl" });
    tempSettings.push({ commandID: 403, key: "C", modifier: "Ctrl" });
    tempSettings.push({ commandID: 404, key: "X", modifier: "Ctrl" });
    tempSettings.push({ commandID: 405, key: "V", modifier: "Ctrl" });
    tempSettings.push({ commandID: 406, key: "Delete", modifier: "" });
    tempSettings.push({ commandID: 406, key: "X", modifier: "" });
    tempSettings.push({ commandID: 407, key: "Enter", modifier: "" });
    tempSettings.push({ commandID: 408, key: "Escape", modifier: "" });
    tempSettings.push({ commandID: 409, key: "A", modifier: "Ctrl" });
    tempSettings.push({ commandID: 410, key: "A", modifier: "Alt" });
    tempSettings.push({ commandID: 411, key: "G", modifier: "Shift" });
    tempSettings.push({ commandID: 412, key: "R", modifier: "Shift" });
    tempSettings.push({ commandID: 413, key: "S", modifier: "Shift" });
    tempSettings.push({ commandID: 501, key: "1", modifier: "" });
    tempSettings.push({ commandID: 502, key: "2", modifier: "" });
    tempSettings.push({ commandID: 503, key: "3", modifier: "" });
    tempSettings.push({ commandID: 504, key: "4", modifier: "" });
    tempSettings.push({ commandID: 505, key: "5", modifier: "" });
    tempSettings.push({ commandID: 506, key: "6", modifier: "" });
    tempSettings.push({ commandID: 507, key: "7", modifier: "" });
    tempSettings.push({ commandID: 508, key: "8", modifier: "" });
    tempSettings.push({ commandID: 509, key: "9", modifier: "" });
    tempSettings.push({ commandID: 510, key: "0", modifier: "" });
    tempSettings.push({ commandID: 511, key: "Tab", modifier: "" });
    tempSettings.push({ commandID: 512, key: "E", modifier: "" });
    tempSettings.push({ commandID: 602, key: "W", modifier: "" });
    tempSettings.push({ commandID: 603, key: "A", modifier: "" });
    tempSettings.push({ commandID: 604, key: "S", modifier: "" });
    tempSettings.push({ commandID: 701, key: "C", modifier: "" });
    tempSettings.push({ commandID: 702, key: "V", modifier: "" });
    const settings = [];
    let tempID = 1;
    for (const tempSetting of tempSettings) {
      const shortcutKey = this.shortcutKeys.find((k) => k.keyName == tempSetting.key);
      if (!shortcutKey) {
        throw new Error("ERROR-0000: Invalid key for default shortcut key");
      }
      const modifierKey = this.modifierKeys.find((k) => k.keyName == tempSetting.modifier);
      if (!modifierKey) {
        throw new Error("ERROR-0000: Invalid modifier for default shortcut key");
      }
      const command = this.shortcutCommands.find((com) => com.commandID == tempSetting.commandID);
      if (!command) {
        throw new Error("ERROR-0000: Invalid command for default shortcut key");
      }
      settings.push({
        id: tempID,
        commandID: tempSetting.commandID,
        shortcutKeyID: shortcutKey.shortcutKeyID,
        modifierKeyID: modifierKey.modifierKeyID
      });
      tempID++;
    }
    return settings;
  }
  addCommand(target, commandID, commandName, categoryID) {
    target.push({ commandID, commandName, categoryID, lineNumber: 0, category: null });
  }
  addShortcutKeySetting(setting) {
    this.shortcutKeySettings.sort((a, b) => a.id - b.id);
    const new_id = this.shortcutKeySettings.reduce((previous, current) => {
      if (previous == current.id) {
        return current.id + 1;
      } else {
        return previous;
      }
    }, 1);
    setting.id = new_id;
    this.shortcutKeySettings.push(setting);
  }
  removeShortcutKeySetting(setting) {
    this.shortcutKeySettings = this.shortcutKeySettings.filter((skt) => skt != setting);
  }
  getCommandIDFromKeyInput(key, shiftKey, ctrlKey, altKey) {
    let shortcutKeySettings;
    if (key == this.cache_key && shiftKey == this.cache_shiftKey && ctrlKey == this.cacche_ctrlKey && altKey == this.cache_altKey) {
      shortcutKeySettings = this.cached_shortcutKeySettings;
    } else {
      const upperCase_key = key.length == 1 ? key.toUpperCase() : key;
      const shortcutKey = this.shortcutKeys.find((sk2) => sk2.keyString == upperCase_key);
      const modifierKeyName = this.getModifierKeyNameFromKeyState(shiftKey, ctrlKey, altKey);
      const modifierKey = this.modifierKeys.find((mk2) => mk2.keyName == modifierKeyName);
      if (shortcutKey && modifierKey) {
        shortcutKeySettings = this.shortcutKeySettings.filter(
          (setting) => setting.shortcutKeyID == shortcutKey.shortcutKeyID && setting.modifierKeyID == modifierKey.modifierKeyID
        );
      } else {
        shortcutKeySettings = [];
      }
    }
    this.cached_shortcutKeySettings = shortcutKeySettings;
    if (shortcutKeySettings.length > 0) {
      return shortcutKeySettings[0].commandID;
    } else {
      return 0;
    }
  }
  getModifierKeyNameFromKeyState(shiftKey, ctrlKey, altKey) {
    if (shiftKey) {
      return "Shift";
    } else if (ctrlKey) {
      return "Ctrl";
    } else if (altKey) {
      return "Alt";
    } else {
      return "";
    }
  }
}
const _UserSettingFileLogic = class {
  constructor() {
    this.localSetting = new LocalSetting();
    this.uiState = null;
    this.shortcutKey = null;
  }
  link(uiState, shortcutKey) {
    this.uiState = uiState;
    this.shortcutKey = shortcutKey;
  }
  loadSettings() {
    const activeSettingName = UserStorage.getItem(_UserSettingFileLogic.localStorage_ActiveSettingNameKey);
    const localSetting = UserStorage.getItem(activeSettingName);
    if (!localSetting) {
      return;
    }
    this.uiState.fixLoadedUIStates(localSetting);
    if (localSetting.fileSections == void 0) {
      localSetting.fileSections = [];
    }
    if (localSetting.shortcutKeySettings == void 0) {
      localSetting.shortcutKeySettings = this.shortcutKey.createDefaultShortcutKeySettings();
    }
    if (localSetting.autoNumberingEnabled == void 0) {
      localSetting.autoNumberingEnabled = false;
    }
    this.localSetting = localSetting;
    this.shortcutKey.shortcutKeySettings = localSetting.shortcutKeySettings;
  }
  saveSettings() {
    this.localSetting.shortcutKeySettings = this.shortcutKey.shortcutKeySettings;
    const activeSettingName = UserStorage.getItem(_UserSettingFileLogic.localStorage_ActiveSettingNameKey);
    UserStorage.setItem(activeSettingName, this.localSetting);
  }
  getOpenFileEnvironments() {
    return {
      fileSections: this.localSetting.fileSections,
      lastUsedFilePaths: this.localSetting.lastUsedFilePaths
    };
  }
  addFileSection(fileSection) {
    const new_FileSections = this.localSetting.fileSections.filter((section) => section.path != fileSection.path);
    new_FileSections.push(fileSection);
    this.setFileSections(new_FileSections);
    this.saveSettings();
  }
  removeFileSection(fileSection) {
    const new_FileSections = this.localSetting.fileSections.filter((section) => section != fileSection);
    this.setFileSections(new_FileSections);
    this.saveSettings();
  }
  registerLastUsedFile(filePath) {
    Platform.path.getFileName(filePath);
    let paths = this.localSetting.lastUsedFilePaths;
    for (let index2 = 0; index2 < paths.length; index2++) {
      if (paths[index2] == filePath) {
        Lists.removeAt(paths, index2);
      }
    }
    Lists.insertAt(paths, 0, filePath);
    if (paths.length > this.localSetting.maxLastUsedFilePaths) {
      paths = Lists.getRange(paths, 0, this.localSetting.maxLastUsedFilePaths);
    }
    this.localSetting.lastUsedFilePaths = paths;
    this.localSetting.currentDirectoryPath = Platform.path.getDirectoryPath(filePath);
    this.saveSettings();
  }
  setFileSections(new_FileSections) {
    let index2 = 0;
    new_FileSections.forEach((item) => item.index = index2++);
    this.localSetting.fileSections = new_FileSections;
  }
};
let UserSettingFileLogic = _UserSettingFileLogic;
UserSettingFileLogic.localStorage_ActiveSettingNameKey = "activeSettingName";
UserSettingFileLogic.localStorage_DefaultDocumentDataKey = "Manual tracing tool save data";
class UserUIStateLogic {
  constructor() {
    this.settingFile = null;
  }
  link(settingFile) {
    this.settingFile = settingFile;
  }
  static createDefaultUIStates() {
    return [
      { name: UIStateNames.touchOperationPanel, visible: true },
      { name: UIStateNames.layerWindow, visible: true },
      { name: UIStateNames.paletteSelectorWindow, visible: false },
      { name: UIStateNames.colorMixerWindow, visible: false },
      { name: UIStateNames.timeLineWindow, visible: false }
    ];
  }
  fixLoadedUIStates(localSetting) {
    const defaultStates = UserUIStateLogic.createDefaultUIStates();
    if (localSetting.uiStates == void 0) {
      localSetting.uiStates = [];
    }
    for (const defaultState of defaultStates) {
      if (localSetting.uiStates.findIndex((state) => state.name == defaultState.name) == -1) {
        localSetting.uiStates.push(defaultState);
      }
    }
  }
  getUIState(uiStateName) {
    const uiState = this.settingFile.localSetting.uiStates.find((state) => state.name == uiStateName);
    return uiState != null ? uiState : null;
  }
}
class App_Document {
  constructor() {
    this.documentLoading = new DocumentLoading();
    this.oraSettings = new DocumentLoaderOraSettings();
    this.posing3D = new Posing3DLogic();
    this.posing3DModel = new Posing3DModelLogic();
    this.appView = null;
    this.appDrawing = null;
    this.appTool = null;
    this.userSetting = null;
    this.docContext = null;
    this.subtoolContext = null;
  }
  link(appView, appDrawing, appTool, userSetting) {
    this.appView = appView;
    this.appDrawing = appDrawing;
    this.appTool = appTool;
    this.userSetting = userSetting;
    this.documentLoading.link(this.appDrawing.posing3DViewRender, this.posing3DModel, this.oraSettings);
  }
  linkContexts(docContext, toolContext) {
    this.docContext = docContext;
    this.subtoolContext = toolContext;
  }
  fixLoadedDocumentData(documentData, modelFile) {
    const state = new DocumentDataSerializingState();
    state.modelFile = modelFile;
    const loadedVersiotn = documentData.version;
    DocumentDeserializingLogic.fixLoadedDocumentData(documentData, state);
    if (documentData.version != loadedVersiotn) {
      console.log("Document migrated:", loadedVersiotn, "->", documentData.version);
    }
  }
  saveDocumentData(save_filePath, documentData, forceToLocal) {
    const save_DocumentData = this.createSaveDocumentData(documentData, save_filePath);
    this.userSetting.registerLastUsedFile(save_filePath);
    if (forceToLocal) {
      UserStorage.setItem(UserSettingFileLogic.localStorage_DefaultDocumentDataKey, save_DocumentData);
      return;
    }
    const fileType = DocumentFileNameLogic.getDocumentFileTypeFromName(save_filePath);
    const documentDataString = JSON.stringify(save_DocumentData);
    if (fileType == DocumentFileType.json) {
      this.saveDocumentJsonFile(save_filePath, documentDataString);
    } else if (fileType == DocumentFileType.ora) {
      const margedImage = this.createExportImage(documentData, this.docContext.currentViewKeyframe, 1, documentData.exportImageSetting.backGroundType);
      this.saveDocumentOraFile(save_filePath, documentDataString, margedImage);
    }
  }
  saveDocumentJsonFile(filePath, documentDataString) {
    Platform.fileSystem.writeFile(filePath, documentDataString, "utf8");
  }
  saveDocumentOraFile(filePath, documentDataString, margedImage) {
    ora.scriptsPath = this.documentLoading.oraSettings.scriptsPath;
    ora.enableWorkers = false;
    const oraFile = new ora.Ora(margedImage.width, margedImage.height);
    const layer = oraFile.addLayer("marged", 0);
    layer.image = margedImage;
    oraFile.save(
      this.documentLoading.oraSettings.vectorFileName,
      documentDataString,
      (dataURL) => {
        Platform.fileSystem.writeFile(filePath, dataURL, "base64");
      }
    );
  }
  createSaveDocumentData(documentData, save_filePath) {
    return DocumentSerializingLogic.duplicateDocumentDataForSave(documentData, save_filePath);
  }
  createExportImage(documentData, viewKeyframe, scale, backGroundType) {
    const layout = DocumentData.getDocumentLayout(documentData, scale);
    if (layout.width <= 0 || layout.height <= 0) {
      return null;
    }
    const exportRenderWindow = new CanvasWindow();
    exportRenderWindow.createCanvas(layout.width, layout.height);
    this.appDrawing.drawExportImage(
      exportRenderWindow,
      documentData,
      viewKeyframe,
      layout.left,
      layout.top,
      layout.width,
      layout.height,
      scale,
      backGroundType
    );
    const canvas = exportRenderWindow.releaseCanvas();
    return canvas;
  }
  exportImageFile(fileName, exportPath, scale, imageFileType, backGroundType, exportingCount) {
    const documentData = this.docContext.documentData;
    const viewKeyframe = this.docContext.currentViewKeyframe;
    const canvas = this.createExportImage(documentData, viewKeyframe, scale, backGroundType);
    if (canvas == null) {
      return;
    }
    let extText = ".png";
    if (imageFileType == 2) {
      extText = ".jpg";
    }
    const fileFullPath = Platform.path.join(exportPath, fileName + extText);
    let imageFileTypeText = "image/png";
    if (imageFileType == 2) {
      imageFileTypeText = "image/jpeg";
    }
    const dataURL = canvas.toDataURL(imageFileTypeText, 0.9);
    Platform.fileSystem.writeFile(fileFullPath, dataURL, "base64");
    canvas.width = 10;
    canvas.height = 10;
    documentData.exportImageSetting.exportingCount = exportingCount + 1;
  }
  findLayers(layers, matchingCallback) {
    const result = [];
    this.findLayerRecursive(result, layers, matchingCallback);
    return result;
  }
  findLayerRecursive(result, layers, matchingCallback) {
    for (const layer of layers) {
      if (matchingCallback(layer)) {
        result.push(layer);
      }
      this.findLayerRecursive(result, layer.childLayers, matchingCallback);
    }
  }
  createDefaultDocumentData() {
    const localData = UserStorage.getItem(UserSettingFileLogic.localStorage_DefaultDocumentDataKey);
    if (!Strings.isNullOrEmpty(localData)) {
      const documentData2 = JSON.parse(localData);
      documentData2.loaded = true;
      return documentData2;
    }
    const documentData = new DocumentData();
    const createCommand = new Command_Layer_CreateDefaultDocumentLayers();
    createCommand.executeWithoutRedraw(documentData, this.subtoolContext);
    documentData.loaded = true;
    return documentData;
  }
  executeNewKeyframe(typeID) {
    switch (typeID) {
      case NewKeyframeTypeID.insertToCurrentFrameAllLayer:
        {
          const command = new Command_Animation_InsertKeyframeAllLayer();
          command.rootLayer = this.subtoolContext.documentData.rootLayer;
          command.frame = this.subtoolContext.documentData.animationSettingData.currentTimeFrame;
          command.prepareEditData(this.subtoolContext);
          if (command.isAvailable(this.subtoolContext)) {
            this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
          }
        }
        break;
      case NewKeyframeTypeID.insertToCurrentFrameActiveLayer:
        break;
      case NewKeyframeTypeID.insertEmptyToAllLayer:
        break;
      case NewKeyframeTypeID.insertEmptyToActiveLayer:
        break;
    }
  }
  executeDeleteKeyframe(typeID) {
    switch (typeID) {
      case DeleteKeyframeTypeID.deleteCurrentFrameAllLayer: {
        const command = new Command_Animation_DeleteKeyframeAllLayer();
        command.rootLayer = this.subtoolContext.documentData.rootLayer;
        command.frame = this.subtoolContext.documentData.animationSettingData.currentTimeFrame;
        command.prepareEditData(this.subtoolContext);
        if (command.isAvailable(this.subtoolContext)) {
          this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
        }
        break;
      }
      case DeleteKeyframeTypeID.deleteCurrentFrameActiveLayer:
        break;
    }
  }
  executeLayerCommand(layerCommand) {
    const currentLayerWindowItem = this.appView.viewLayerList.findItemForLayer(this.docContext, this.subtoolContext.currentLayer);
    if (currentLayerWindowItem == null) {
      return;
    }
    this.appTool.setLayerCommandParameters(layerCommand, currentLayerWindowItem, this.subtoolContext.documentData);
    if (layerCommand.isAvailable(this.subtoolContext)) {
      this.subtoolContext.commandHistory.executeCommand(layerCommand, this.subtoolContext);
    }
  }
  moveKeyframe(moveForward) {
    const done = EditAnimationFrameLogic.moveKeyframeData(
      this.docContext.currentViewKeyframe,
      this.docContext.previousKeyframe,
      this.docContext.nextKeyframe,
      moveForward
    );
    if (done) {
      this.subtoolContext.setRedrawMainWindowEditorWindow();
      this.subtoolContext.setRedrawTimeLineWindow();
    }
  }
  changeAnimationMaxFrame(moveForward) {
    EditAnimationFrameLogic.changeAnimationMaxFrame(this.docContext.documentData.animationSettingData, moveForward);
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  changeLoopStartFrame(moveForward) {
    EditAnimationFrameLogic.changeLoopStartFrame(this.docContext.documentData.animationSettingData, moveForward);
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  changeLoopEndFrame(moveForward) {
    EditAnimationFrameLogic.changeLoopEndFrame(this.docContext.documentData.animationSettingData, moveForward);
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  changeOnionSkinMode(mode) {
    this.docContext.documentData.animationSettingData.onionSkinMode = mode;
    this.subtoolContext.updateLayerStructure();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  changeOnionSkinBackwardLevel(add) {
    const newValue = this.docContext.documentData.animationSettingData.onionSkinBackwardLevel + (add ? 1 : -1);
    this.docContext.documentData.animationSettingData.onionSkinBackwardLevel = Math.min(AnimationSettingData.MAX_ONION_SIKIN_FRAMES, Math.max(newValue, 0));
    this.subtoolContext.updateLayerStructure();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  changeOnionSkinForwardLevel(add) {
    const newValue = this.docContext.documentData.animationSettingData.onionSkinForwardLevel + (add ? 1 : -1);
    this.docContext.documentData.animationSettingData.onionSkinForwardLevel = Math.min(AnimationSettingData.MAX_ONION_SIKIN_FRAMES, Math.max(newValue, 0));
    this.subtoolContext.updateLayerStructure();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  getLayerBaseName(layerType) {
    let base_LayerName = "";
    switch (layerType) {
      case LayerTypeID.groupLayer:
        base_LayerName = "\u30B0\u30EB\u30FC\u30D7";
        break;
      case LayerTypeID.vectorLayer:
        base_LayerName = "\u7DDA\u753B";
        break;
      case LayerTypeID.surroundingFillLayer:
        base_LayerName = "\u56F2\u307F\u5857\u308A";
        break;
      case LayerTypeID.pointBrushFillLayer:
        base_LayerName = "\u30D6\u30E9\u30B7\u5857\u308A";
        break;
      case LayerTypeID.vectorLayerReferenceLayer:
        base_LayerName = "\u7DDA\u753B\u53C2\u7167";
        break;
      case LayerTypeID.imageFileReferenceLayer:
        base_LayerName = "\u753B\u50CF\u30D5\u30A1\u30A4\u30EB";
        break;
      case LayerTypeID.autoFillLayer:
        base_LayerName = "\u81EA\u52D5\u56F2\u307F\u5857\u308A";
        break;
      case LayerTypeID.posingLayer:
        base_LayerName = "\u30DD\u30FC\u30B8\u30F3\u30B0";
        break;
      default:
        throw new Error("ERROR 0000:No implementation for new layer name.");
    }
    return base_LayerName;
  }
  getNewLayerName(layerType, isForDefaultDocument = false) {
    let base_LayerName = this.getLayerBaseName(layerType);
    let new_index = 1;
    if (!isForDefaultDocument) {
      const sameName_Layers = this.findLayers(
        this.docContext.documentData.rootLayer.childLayers,
        (layer) => Strings.startsWith(layer.name, base_LayerName)
      );
      for (const layer of sameName_Layers) {
        const afterName_Text = Strings.substring(layer.name, base_LayerName.length);
        if (Strings.isNullOrEmpty(afterName_Text)) {
          continue;
        }
        const index2 = Number(afterName_Text);
        if (index2 && !isNaN(index2) && index2 >= new_index) {
          new_index = index2 + 1;
        }
      }
    }
    return `${base_LayerName}${new_index}`;
  }
}
class DrawPathCompositionBuffer {
  constructor() {
    this.isUsed = false;
    this.canvasWindow = null;
    this.width = 0;
    this.height = 0;
  }
}
class DrawPathBufferStore {
  constructor() {
    this.buffers = [];
  }
  clearBufferUsedFlags() {
    for (const buffer of this.buffers) {
      buffer.isUsed = false;
    }
  }
  getBufferForCanvas(canvasWindow) {
    return this.getBuffer(canvasWindow.width, canvasWindow.height);
  }
  getBuffer(width, height) {
    var _a;
    let buffer = (_a = this.buffers.find(
      (buffer2) => buffer2.isUsed == false && buffer2.width == width && buffer2.height == height
    )) != null ? _a : null;
    if (buffer == null) {
      buffer = new DrawPathCompositionBuffer();
      this.buffers.push(buffer);
    }
    buffer.isUsed = true;
    return buffer;
  }
  freeUnusedBuffers() {
    this.buffers = this.buffers.filter((buffer) => buffer.isUsed);
  }
}
class DrawPathRenderMaskData {
  constructor() {
    this.data = null;
    this.width = 0;
    this.height = 0;
    this.lineBytes = 0;
    this.pixelBytes = 0;
  }
  createDataArray(width, height) {
    this.data = new Uint8Array(width * height);
    this.width = width;
    this.height = height;
    this.pixelBytes = 1;
    this.lineBytes = this.pixelBytes * width;
  }
  clear() {
    this.data.fill(0);
  }
}
class DrawPathRenderMaskImageData {
  constructor() {
    this.canvasWindow = new CanvasWindow();
    this.imageData = null;
    this.width = 0;
    this.height = 0;
    this.lineBytes = 0;
    this.pixelBytes = 0;
  }
  clear() {
    this.imageData.data.fill(0);
  }
}
class DrawPathRenderCacheRelatedData {
  constructor() {
    this.geometries = null;
  }
}
class DrawPathRenderCache {
  constructor() {
    this.isUsed = false;
    this.layer = null;
    this.drawPathOperationType = DrawPathOperationTypeID.none;
    this.canvasWindow = null;
    this.maskData = null;
    this.maskImageData = null;
    this.relatedData = null;
    this.width = 0;
    this.height = 0;
    this.location = vec2.fromValues(0, 0);
  }
  isInitialized() {
    return this.canvasWindow != null;
  }
  free() {
    this.isUsed = false;
    this.canvasWindow = null;
    this.maskData = null;
    this.maskImageData = null;
    this.relatedData = null;
    this.width = 0;
    this.height = 0;
    vec2.set(this.location, 0, 0);
  }
  clearMaskData() {
    this.maskData.clear();
  }
}
class DrawPathRenderCacheStore {
  constructor() {
    this.caches = [];
  }
  clearUsedFlags() {
    for (const cache of this.caches) {
      cache.isUsed = false;
    }
  }
  getCache(layer, drawPathOperationType) {
    var _a;
    let cache = (_a = this.caches.find(
      (cache2) => cache2.isUsed == false && cache2.layer == layer && cache2.drawPathOperationType == drawPathOperationType
    )) != null ? _a : null;
    if (cache == null) {
      cache = new DrawPathRenderCache();
      cache.layer = layer;
      cache.drawPathOperationType = drawPathOperationType;
      this.caches.push(cache);
    }
    cache.isUsed = true;
    return cache;
  }
  freeUnusedBuffers() {
    this.caches = this.caches.filter((buffer) => buffer.isUsed);
  }
}
class DrawPathContext {
  constructor() {
    this.drawPathModeID = DrawPathModeID.none;
    this.steps = [];
    this.onionSkinLevel = 0;
    this.maxOnionSkinLevel = 0;
    this.render = null;
    this.local_render = null;
    this.documentData = null;
    this.drawCPUOnly = true;
    this.isEditModeDraw = false;
    this.redrawActiveLayerOnly = false;
    this.currentLayerOnly = false;
    this.isModalToolRunning = false;
    this.activeDrawPathStartIndex = -1;
    this.activeDrawPathEndIndex = -1;
    this.startIndex = 0;
    this.endIndex = 0;
    this.lastDrawPathIndex = -1;
    this.isNonActiveLayerBufferDrawingDone = false;
    this.bufferStack = [];
    this.bufferStore = new DrawPathBufferStore();
    this.renderCacheStore = new DrawPathRenderCacheStore();
    this.lazyDraw_compositionBuffer = new DrawPathCompositionBuffer();
    this.lazyUpdateState = null;
  }
  clearDrawingStates() {
    this.lastDrawPathIndex = -1;
    if (this.bufferStack.length > 0) {
      this.bufferStack = [];
    }
  }
  existsDrawnStepsAtLastTime() {
    return this.lastDrawPathIndex != -1;
  }
  isEditMode() {
    return this.isEditModeDraw;
  }
  isFinished() {
    return this.lazyUpdateState.processedIndex >= this.steps.length - 1;
  }
  isFullRendering() {
    return this.drawPathModeID == DrawPathModeID.exportRendering;
  }
  isExporting() {
    return this.drawPathModeID == DrawPathModeID.export || this.drawPathModeID == DrawPathModeID.exportRendering;
  }
  isLazyUpdate() {
    return this.drawPathModeID == DrawPathModeID.lazyUpdate;
  }
  isOnionSkin() {
    return this.drawPathModeID == DrawPathModeID.onionSkinBackward || this.drawPathModeID == DrawPathModeID.onionSkinForward;
  }
  getCurrentBuffer() {
    if (this.bufferStack.length == 0) {
      throw new Error("ERROR 0601:\u30D0\u30C3\u30D5\u30A1\u30B9\u30BF\u30C3\u30AF\u304C\u3042\u308A\u307E\u305B\u3093\u3002");
    }
    return this.bufferStack[this.bufferStack.length - 1];
  }
  log(tag) {
    console.log(tag, { startIndex: this.startIndex, endIndex: this.endIndex });
  }
}
var DrawPathOperationTypeID = /* @__PURE__ */ ((DrawPathOperationTypeID2) => {
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["none"] = 0] = "none";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["startDrawPaths"] = 1] = "startDrawPaths";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["finishDrawPaths"] = 2] = "finishDrawPaths";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["drawForeground"] = 3] = "drawForeground";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["drawBackground"] = 4] = "drawBackground";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["prepareRenderingForeground"] = 5] = "prepareRenderingForeground";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["flushRenderingForeground"] = 6] = "flushRenderingForeground";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["prepareBuffer"] = 7] = "prepareBuffer";
  DrawPathOperationTypeID2[DrawPathOperationTypeID2["flushBuffer"] = 8] = "flushBuffer";
  return DrawPathOperationTypeID2;
})(DrawPathOperationTypeID || {});
var DrawPathModeID = /* @__PURE__ */ ((DrawPathModeID2) => {
  DrawPathModeID2[DrawPathModeID2["none"] = 0] = "none";
  DrawPathModeID2[DrawPathModeID2["editor"] = 1] = "editor";
  DrawPathModeID2[DrawPathModeID2["lazyUpdate"] = 2] = "lazyUpdate";
  DrawPathModeID2[DrawPathModeID2["export"] = 3] = "export";
  DrawPathModeID2[DrawPathModeID2["exportRendering"] = 4] = "exportRendering";
  DrawPathModeID2[DrawPathModeID2["onionSkinBackward"] = 5] = "onionSkinBackward";
  DrawPathModeID2[DrawPathModeID2["onionSkinForward"] = 6] = "onionSkinForward";
  return DrawPathModeID2;
})(DrawPathModeID || {});
class DrawPathBufferingLogic {
  prepareForLazyDrawComposition(drawPathContext, width, height, isExporting) {
    drawPathContext.lazyDraw_compositionBuffer = this.createOrUpdateCompositionCanvas(drawPathContext.lazyDraw_compositionBuffer, width, height, isExporting, drawPathContext);
  }
  prepareDrawPathBuffers(drawPathContext, drawTo_CanvasWindow, isExporting = false) {
    drawPathContext.bufferStore.clearBufferUsedFlags();
    for (const drawPathStep of drawPathContext.steps) {
      if (drawPathStep.operationType == DrawPathOperationTypeID.prepareBuffer) {
        this.prepareForLayerComposition(drawPathStep, drawTo_CanvasWindow, isExporting, drawPathContext);
      }
    }
    drawPathContext.bufferStore.freeUnusedBuffers();
  }
  prepareForLayerComposition(drawPathStep, drawTo_CanvasWindow, isExporting, drawPathContext) {
    drawPathStep.buffer = this.createOrUpdateCompositionCanvas(drawPathStep.buffer, drawTo_CanvasWindow.width, drawTo_CanvasWindow.height, isExporting, drawPathContext);
  }
  createOrUpdateCompositionCanvas(buffer, width, height, isExporting, drawPathContext) {
    const needsUpdateBufferCanvas = buffer == null || buffer.canvasWindow == null || buffer.width != width || buffer.height != height;
    if (!needsUpdateBufferCanvas) {
      return;
    }
    if (isExporting) {
      buffer = new DrawPathCompositionBuffer();
    } else {
      buffer = drawPathContext.bufferStore.getBuffer(width, height);
    }
    const canvasWindow = new CanvasWindow();
    canvasWindow.createCanvas(width, height);
    buffer.canvasWindow = canvasWindow;
    buffer.width = width;
    buffer.height = height;
    return buffer;
  }
  setUpdateCacheToDrawPathSteps(layer, drawPathContext, needsRedraw) {
    for (const drawPathStep of drawPathContext.steps) {
      if (drawPathStep.layer == layer) {
        drawPathStep.needsUpdateCache = true;
        drawPathStep.needsRedraw = drawPathStep.needsRedraw || needsRedraw;
      }
    }
  }
  updateRenderCaches(drawPathContext, viewKeyframe) {
    for (const drawPathStep of drawPathContext.steps) {
      if (!drawPathStep.needsUpdateCache) {
        continue;
      }
      if (VectorLayer.isPointBrushFillLayer(drawPathStep.layer)) {
        const isCacheChanged = this.updateCacheForVectorLayer(drawPathStep, drawPathContext);
        if (isCacheChanged) {
          drawPathStep.needsRedraw = true;
        }
        if (drawPathStep.renderCache.isInitialized()) {
          if (drawPathStep.renderCache.relatedData == null) {
            drawPathStep.renderCache.relatedData = new DrawPathRenderCacheRelatedData();
          }
          drawPathStep.renderCache.relatedData.geometries = [];
          for (const vkfLayer of viewKeyframe.layers) {
            if (vkfLayer.layer == drawPathStep.layer || vkfLayer.layer.runtime.parentLayer != drawPathStep.layer.runtime.parentLayer) {
              continue;
            }
            if (VectorLayer.isVectorStrokeLayer(vkfLayer.layer)) {
              drawPathStep.renderCache.relatedData.geometries.push(vkfLayer.vectorLayerKeyframe.geometry);
              const vectorLaye = vkfLayer.layer;
              if (vectorLaye.eyesSymmetryEnabled && vectorLaye.runtime.eyesSymmetryGeometry != null) {
                drawPathStep.renderCache.relatedData.geometries.push(vectorLaye.runtime.eyesSymmetryGeometry);
              }
            }
          }
        }
      }
    }
  }
  updateCacheForVectorLayer(drawPathStep, drawPathContext) {
    const geometry = drawPathStep.viewKeyframeLayer.vectorLayerKeyframe.geometry;
    if (!geometry.runtime.area.existsValidArea()) {
      if (drawPathStep.renderCache.isInitialized()) {
        drawPathStep.renderCache.free();
      }
      return false;
    }
    const width = geometry.runtime.area.getBitmapWidth();
    const height = geometry.runtime.area.getBitmapHeight();
    const needsCacheReallocate = drawPathStep.renderCache.canvasWindow == null || drawPathStep.renderCache.maskData == null || drawPathStep.renderCache.width != width || drawPathStep.renderCache.height != height;
    const needsUpdate = needsCacheReallocate || drawPathStep.renderCache.location[0] != geometry.runtime.area.left || drawPathStep.renderCache.location[1] != geometry.runtime.area.top;
    if (!needsUpdate) {
      return false;
    }
    if (needsCacheReallocate) {
      const new_renderCache = drawPathContext.renderCacheStore.getCache(drawPathStep.layer, drawPathStep.operationType);
      const canvasWindow = new CanvasWindow();
      canvasWindow.createCanvas(width, height);
      new_renderCache.canvasWindow = canvasWindow;
      new_renderCache.width = width;
      new_renderCache.height = height;
      const maskData = new DrawPathRenderMaskData();
      maskData.createDataArray(width, height);
      new_renderCache.maskData = maskData;
      new_renderCache.maskImageData = new DrawPathRenderMaskImageData();
      new_renderCache.maskImageData.canvasWindow.createCanvas(width, height);
      new_renderCache.maskImageData.imageData = canvasWindow.context.createImageData(width, height);
      new_renderCache.maskImageData.pixelBytes = 4;
      new_renderCache.maskImageData.lineBytes = new_renderCache.maskImageData.pixelBytes * width;
      drawPathStep.renderCache = new_renderCache;
    }
    drawPathStep.renderCache.location[0] = geometry.runtime.area.left;
    drawPathStep.renderCache.location[1] = geometry.runtime.area.top;
    drawPathStep.renderCache.canvasWindow.viewLocation[0] = drawPathStep.renderCache.location[0];
    drawPathStep.renderCache.canvasWindow.viewLocation[1] = drawPathStep.renderCache.location[1];
    return true;
  }
  updateAllRenderCaches(drawPathContext, viewKeyframe) {
    drawPathContext.renderCacheStore.clearUsedFlags();
    for (const viewKeyframeLayer of viewKeyframe.layers) {
      this.setUpdateCacheToDrawPathSteps(viewKeyframeLayer.layer, drawPathContext, true);
    }
    this.updateRenderCaches(drawPathContext, viewKeyframe);
    drawPathContext.renderCacheStore.freeUnusedBuffers();
  }
}
class DrawPathStep {
  constructor() {
    this.operationType = DrawPathOperationTypeID.none;
    this.compositeOperation = CanvasRenderBlendMode.default;
    this.layer = null;
    this.viewKeyframeLayer = null;
    this.buffer = null;
    this.renderCache = new DrawPathRenderCache();
    this.useCache = false;
    this.needsUpdateCache = false;
    this.needsRedraw = false;
    this._debugText = "";
    this._debugText2 = "";
  }
  isCacheEnabled() {
    return this.useCache && this.renderCache.isInitialized();
  }
}
class TempVirtualLayer {
  constructor(type, layer) {
    this.type = type;
    this.layer = layer;
    this.children = [];
    if (!layer) {
      throw new Error("ERROR0000:virtual layer can not take layer value of null");
    }
  }
}
class DrawPathCollectingLogic {
  collectDrawPaths(drawPathContext, documentData, currentViewKeyframe, ouputDebugText = false) {
    const drawPathSteps = [];
    {
      const vLayer = new TempVirtualLayer(1, documentData.rootLayer);
      drawPathSteps.push(
        this.createDrawPathStep(vLayer, DrawPathOperationTypeID.startDrawPaths, false, "")
      );
    }
    const vLayers = [];
    this.collectVirtualLayerRecursive(vLayers, documentData.rootLayer.childLayers);
    this.collectDrawPathsRecursive(drawPathSteps, vLayers, drawPathContext.isFullRendering(), drawPathContext.isOnionSkin());
    {
      const vLayer = new TempVirtualLayer(1, documentData.rootLayer);
      drawPathSteps.push(
        this.createDrawPathStep(vLayer, DrawPathOperationTypeID.finishDrawPaths, false, "")
      );
    }
    this.updateViewKeyframeReferences(drawPathSteps, currentViewKeyframe.layers);
    drawPathContext.documentData = documentData;
    drawPathContext.steps = drawPathSteps;
    drawPathContext.isNonActiveLayerBufferDrawingDone = false;
    this.updateActiveDrawPathIndex(drawPathContext);
    if (ouputDebugText) {
      console.debug(`DrawPath collectDrawPaths`);
      let stepIndex = 0;
      for (const step of drawPathContext.steps) {
        console.debug(` ${stepIndex}: ${step._debugText} ${step.layer && step.layer.name ? "[" + step.layer.name + "]" : ""} ${CanvasRenderBlendMode[step.compositeOperation]}${step._debugText2}`);
        stepIndex++;
      }
    }
  }
  collectVirtualLayerRecursive(result, layers) {
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      const vLayer = new TempVirtualLayer(1, layer);
      this.collectVirtualLayerRecursive(vLayer.children, layer.childLayers);
      if (layer.isMaskedByBelowLayer) {
        const group_virtualLayer = new TempVirtualLayer(2, layer);
        group_virtualLayer.children.push(vLayer);
        let nextIndex = i + 1;
        while (nextIndex < layers.length) {
          const nextLayer = layers[nextIndex];
          const next_vLayer = new TempVirtualLayer(1, nextLayer);
          this.collectVirtualLayerRecursive(next_vLayer.children, nextLayer.childLayers);
          group_virtualLayer.children.push(next_vLayer);
          if (nextLayer.isMaskedByBelowLayer) {
            nextIndex++;
          } else {
            i = nextIndex;
            break;
          }
        }
        result.push(group_virtualLayer);
      } else {
        result.push(vLayer);
      }
    }
  }
  collectDrawPathsRecursive(result, vLayers, isFullRendering, isOnionSkin) {
    let isGPUDrawContinuing = false;
    for (let i = vLayers.length - 1; i >= 0; i--) {
      const vLayer = vLayers[i];
      if (vLayer.children.length > 0) {
        const debugText = vLayer.type == 2 ? " virtual" : "";
        const needsCompositionForSelf = vLayer.layer.isMaskedByBelowLayer;
        const needsCompositionForChildren = vLayer.children.findIndex(
          (child) => child.type != 2 && child.layer.isMaskedByBelowLayer
        ) != -1;
        const needsComposition = (needsCompositionForSelf || needsCompositionForChildren) && !isOnionSkin;
        if (needsComposition) {
          result.push(
            this.createDrawPathStep(vLayer, DrawPathOperationTypeID.prepareBuffer, isOnionSkin, debugText)
          );
        }
        this.collectDrawPathsRecursive(result, vLayer.children, isFullRendering, isOnionSkin);
        if (needsComposition) {
          result.push(
            this.createDrawPathStep(vLayer, DrawPathOperationTypeID.flushBuffer, isOnionSkin, debugText)
          );
        }
        continue;
      }
      const fillDrawable = this.isFillDrawableLayer(vLayer.layer) ? vLayer.layer : null;
      if (fillDrawable && fillDrawable.fillAreaType != FillAreaTypeID.none && !isOnionSkin) {
        result.push(
          this.createDrawPathStep(vLayer, DrawPathOperationTypeID.drawBackground, isOnionSkin)
        );
      }
      const strokeDrawable = this.isStrokeDrawableLayer(vLayer.layer) ? vLayer.layer : null;
      if (strokeDrawable && strokeDrawable.drawLineType != DrawLineTypeID.none) {
        if (isFullRendering && !isGPUDrawContinuing) {
          result.push(
            this.createDrawPathStep(vLayer, DrawPathOperationTypeID.prepareRenderingForeground, isOnionSkin)
          );
        }
        {
          const drawPathStep = this.createDrawPathStep(vLayer, DrawPathOperationTypeID.drawForeground, isOnionSkin);
          drawPathStep.useCache = this.isLayerUseCache(vLayer.layer);
          result.push(drawPathStep);
        }
        isGPUDrawContinuing = false;
        if (fillDrawable && fillDrawable.fillAreaType == FillAreaTypeID.none && i > 0) {
          const next_layer = vLayers[i - 1].layer;
          if (VectorLayer.isVectorLayer(next_layer)) {
            const next_vectorLayer = next_layer;
            if (next_vectorLayer.drawLineType != DrawLineTypeID.none && next_vectorLayer.fillAreaType == FillAreaTypeID.none) {
              isGPUDrawContinuing = true;
            }
          }
        }
        if (isFullRendering && !isGPUDrawContinuing) {
          result.push(
            this.createDrawPathStep(vLayer, DrawPathOperationTypeID.flushRenderingForeground, isOnionSkin)
          );
        }
      }
      if (strokeDrawable || fillDrawable) {
        continue;
      } else {
        if (!isOnionSkin) {
          result.push(
            this.createDrawPathStep(vLayer, DrawPathOperationTypeID.drawForeground, isOnionSkin)
          );
        }
      }
    }
  }
  isStrokeDrawableLayer(layer) {
    return VectorLayer.isVectorLayer(layer);
  }
  isFillDrawableLayer(layer) {
    return VectorLayer.isVectorLayer(layer) || AutoFillLayer.isAutoFillLayer(layer);
  }
  isLayerUseCache(layer) {
    return PointBrushFillLayer.isPointBrushFillLayer(layer);
  }
  createDrawPathStep(vLayer, operationType, isOnionSkin, debugText = "") {
    if (!vLayer.layer) {
      throw new Error("ERROR0000:drawPathStep can not take layer value of null");
    }
    const drawPathStep = new DrawPathStep();
    drawPathStep.layer = vLayer.layer;
    drawPathStep.operationType = operationType;
    if (vLayer.type != 2) {
      drawPathStep.compositeOperation = this.getBlendMode(vLayer.layer, isOnionSkin);
    }
    drawPathStep._debugText = DrawPathOperationTypeID[operationType];
    drawPathStep._debugText2 = debugText;
    return drawPathStep;
  }
  getBlendMode(layer, isOnionSkin) {
    return layer.isMaskedByBelowLayer && !isOnionSkin ? CanvasRenderBlendMode.sourceAtop : CanvasRenderBlendMode.default;
  }
  updateViewKeyframeReferences(drawPathSteps, viewKeyframeLayers) {
    for (const drawPathStep of drawPathSteps) {
      drawPathStep.viewKeyframeLayer = null;
      for (const viewKeyframeLayer of viewKeyframeLayers) {
        if (viewKeyframeLayer.layer == drawPathStep.layer) {
          drawPathStep.viewKeyframeLayer = viewKeyframeLayer;
          break;
        }
      }
    }
  }
  updateActiveDrawPathIndex(drawPathContext) {
    let firstSelectedIndex = -1;
    let lastSelectedIndex = -1;
    let bufferNestStartIndex = -1;
    let bufferNestLevel = 0;
    let isSelectedNest = false;
    for (let i = 0; i < drawPathContext.steps.length; i++) {
      const drawPathStep = drawPathContext.steps[i];
      if (Layer.isSelected(drawPathStep.layer)) {
        if (bufferNestLevel == 0) {
          if (firstSelectedIndex == -1) {
            firstSelectedIndex = i;
          }
          lastSelectedIndex = i;
        } else {
          isSelectedNest = true;
        }
      }
      if (drawPathStep.operationType == DrawPathOperationTypeID.prepareBuffer) {
        if (bufferNestLevel == 0) {
          bufferNestStartIndex = i;
        }
        bufferNestLevel++;
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.flushBuffer) {
        bufferNestLevel--;
        if (bufferNestLevel == 0) {
          if (isSelectedNest) {
            if (firstSelectedIndex == -1) {
              firstSelectedIndex = bufferNestStartIndex;
            }
            lastSelectedIndex = i;
            isSelectedNest = false;
          }
        }
      }
    }
    drawPathContext.activeDrawPathStartIndex = firstSelectedIndex;
    drawPathContext.activeDrawPathEndIndex = lastSelectedIndex;
  }
}
class DrawingEyesSymmetryLogic {
  constructor() {
    this.canvasRender = null;
    this.drawStyle = null;
    this.editorDrawer = null;
    this.location2D = vec3.create();
    this.eyeLocation = vec3.create();
    this.direction = vec3.create();
    this.localLocation = vec3.create();
    this.radiusLocation = vec3.create();
    this.radiusLocationWorld = vec3.create();
    this.radiusLocation2D = vec3.create();
  }
  link(canvasRender, drawStyle, editorDrawer) {
    this.canvasRender = canvasRender;
    this.drawStyle = drawStyle;
    this.editorDrawer = editorDrawer;
  }
  drawEyesSymmetries(layerWindowItems, ctx) {
    for (const item of layerWindowItems) {
      if (VectorLayer.isVectorLayerWithOwnData(item.layer)) {
        const vectorLayer = item.layer;
        this.drawEyesSymmetry(vectorLayer, ctx);
      }
    }
  }
  drawEyesSymmetry(vectorLayer, ctx) {
    if (vectorLayer == null || vectorLayer.eyesSymmetryEnabled == false || vectorLayer.runtime.posingLayer == null || !vectorLayer.isVisible || !vectorLayer.isSelected) {
      return;
    }
    const posingData = vectorLayer.runtime.posingLayer.posingData;
    if (!posingData.headLocationInputData.inputDone) {
      return;
    }
    ctx.posing3DLogic.getEyeSphereLocation(this.eyeLocation, posingData, vectorLayer.eyesSymmetryInputSide);
    ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2D, this.eyeLocation, posingData);
    const eyeSize = ctx.posing3DLogic.getEyeSphereSize();
    vec3.transformMat4(this.localLocation, this.eyeLocation, ctx.posing3DView.viewMatrix);
    vec3.set(this.direction, eyeSize, 0, 0);
    vec3.add(this.radiusLocation, this.localLocation, this.direction);
    vec3.transformMat4(this.radiusLocationWorld, this.radiusLocation, ctx.posing3DView.cameraMatrix);
    ctx.posing3DView.calculate2DLocationFrom3DLocation(this.radiusLocation2D, this.radiusLocationWorld, posingData);
    const raduis2D = vec3.distance(this.location2D, this.radiusLocation2D);
    const strokeWidth = this.editorDrawer.getCurrentViewScaleLineWidth(1);
    this.canvasRender.setStrokeColorV(this.drawStyle.eyesSymmetryGuideColor);
    this.canvasRender.setStrokeWidth(strokeWidth);
    this.canvasRender.beginPath();
    this.canvasRender.circle(this.location2D[0], this.location2D[1], raduis2D);
    this.canvasRender.stroke();
  }
}
class DrawingImageFileReferenceLayerLogic {
  constructor() {
    this.canvasRender = null;
    this.tempMat4 = mat4.create();
  }
  link(canvasRender) {
    this.canvasRender = canvasRender;
  }
  drawImageFileReferenceLayer(layer, isModalToolRunning) {
    if (layer.runtime.imageResource.image == null || layer.runtime.imageResource.image.imageData == null) {
      return;
    }
    const image = layer.runtime.imageResource.image.imageData;
    const location = isModalToolRunning ? layer.runtime.adjustingLocation : layer.location;
    const rotation = isModalToolRunning ? layer.runtime.adjustingRotation[0] : layer.rotation[0];
    const scale = isModalToolRunning ? layer.runtime.adjustingScale : layer.scale;
    mat4.identity(this.tempMat4);
    mat4.translate(this.tempMat4, this.tempMat4, location);
    mat4.rotateZ(this.tempMat4, this.tempMat4, rotation);
    mat4.scale(this.tempMat4, this.tempMat4, scale);
    this.canvasRender.setLocalTransform(this.tempMat4);
    this.canvasRender.setGlobalAlpha(layer.layerColor[3]);
    this.canvasRender.drawImage(
      image,
      0,
      0,
      image.width,
      image.height,
      0,
      0,
      image.width,
      image.height
    );
    this.canvasRender.cancelLocalTransform();
    this.canvasRender.setGlobalAlpha(1);
  }
}
class OcclusionMap {
  constructor() {
    this.data = new Float32Array(2e3);
    this.mapLength = 0;
  }
  clear() {
    this.data.fill(0, 0, this.mapLength);
  }
}
class DrawingPointBrushLogic {
  constructor() {
    this.drawStyle = null;
    this.occlusionMap = new OcclusionMap();
    this.local_Mat = mat4.create();
    this.local_center = vec2.create();
  }
  link(drawStyle) {
    this.drawStyle = drawStyle;
  }
  drawPointBrushStroke(render, stroke, color, useAdjustingLocation, renderCache) {
    const gradient = render.createRadialGradient(0, 0, 1);
    gradient.addColorStop(0, this.getRGBAText(color, 1));
    gradient.addColorStop(1, this.getRGBAText(color, 0));
    render.setFillGradiaent(gradient);
    mat4.identity(this.local_Mat);
    for (const point of stroke.points) {
      const lengthFrom = useAdjustingLocation ? point.adjustingLengthFrom : 1;
      const lengthTo = useAdjustingLocation ? point.adjustingLengthTo : 0;
      if (lengthFrom <= 0 && lengthTo >= 1) {
        continue;
      }
      const location = this.getPointLocation(point, useAdjustingLocation);
      const radius = VectorPointLogic.getPointRadius(point);
      this.local_Mat[0] = radius;
      this.local_Mat[5] = radius;
      this.local_Mat[12] = location[0];
      this.local_Mat[13] = location[1];
      render.setLocalTransform(this.local_Mat);
      render.fillRect(-1, -1, 2, 2);
      if (renderCache != null) {
        this.collectOcclusionMap(this.occlusionMap, location, radius, 2, renderCache);
        this.setMaskForBrushShape(renderCache, location, radius, this.occlusionMap);
      }
    }
  }
  getPointLocation(point, useAdjustingLocation) {
    return useAdjustingLocation ? point.adjustingLocation : point.location;
  }
  getRGBAText(color, alpha) {
    const r2 = color[0] * 255;
    const g = color[1] * 255;
    const b = color[2] * 255;
    const a = color[3] * alpha;
    return `rgba(${r2.toFixed(0)},${g.toFixed(0)},${b.toFixed(0)},${a.toFixed(3)})`;
  }
  collectOcclusionMap(occlusionMap, center_location, radius, division, renderCache) {
    const occlusionMapLength = Math.floor(radius * 2 * Math.PI / division);
    const occlusionMap_unitAngle = Math.PI * 2 / occlusionMapLength;
    if (occlusionMap.data.length < occlusionMapLength) {
      occlusionMap.data = new Float32Array(occlusionMapLength);
    }
    occlusionMap.mapLength = occlusionMapLength;
    occlusionMap.clear();
    const map_data = occlusionMap.data;
    const minDistanceSQ = radius * radius;
    const segmentMatrix = mat2d.create();
    const intersected_segments = [];
    for (const geometry of renderCache.relatedData.geometries) {
      if (!geometry.runtime.area.hittestLocationWithRadius(center_location, radius)) {
        continue;
      }
      VectorLayerGeometry.forEachStroke(geometry, (stroke) => {
        if (stroke.runtime.area.hittestLocationWithRadius(center_location, radius)) {
          for (let index2 = 0; index2 < stroke.points.length - 1; index2++) {
            const from_point = stroke.points[index2];
            const to_point = stroke.points[index2 + 1];
            const distanceSQ = Logic_Points.pointToLineSegment_SorroundingDistanceSQ(
              from_point.location,
              to_point.location,
              center_location
            );
            if (distanceSQ <= minDistanceSQ) {
              const dx = to_point.location[0] - from_point.location[0];
              const dy = to_point.location[1] - from_point.location[1];
              const segment_length = Math.sqrt(dx * dx + dy * dy);
              if (segment_length == 0) {
                continue;
              }
              const nx = dx / segment_length;
              const ny = dy / segment_length;
              const angle = this.atan2Rounded(ny, nx);
              segmentMatrix[0] = Math.cos(angle);
              segmentMatrix[1] = -Math.sin(angle);
              segmentMatrix[2] = Math.sin(angle);
              segmentMatrix[3] = Math.cos(angle);
              segmentMatrix[4] = from_point.location[0];
              segmentMatrix[5] = from_point.location[1];
              const invMat = [
                segmentMatrix[0],
                segmentMatrix[2],
                segmentMatrix[1],
                segmentMatrix[3],
                -(segmentMatrix[4] * segmentMatrix[0] + segmentMatrix[5] * segmentMatrix[1]),
                -(segmentMatrix[4] * segmentMatrix[2] + segmentMatrix[5] * segmentMatrix[3])
              ];
              intersected_segments.push({ from_point, to_point, length: segment_length, angle, invMat });
            }
          }
        }
      });
    }
    for (const segement of intersected_segments) {
      this.traslateMat2d(this.local_center, center_location, segement.invMat);
      if (Math.abs(this.local_center[1]) >= radius) {
        continue;
      }
      const dy = -this.local_center[1];
      const dx = Math.sqrt(radius * radius - dy * dy);
      let left_intersect_locationX = this.local_center[0] - dx;
      if (left_intersect_locationX < 0) {
        left_intersect_locationX = 0;
      }
      const local_leftSideAngle = this.atan2Rounded(dy, left_intersect_locationX - this.local_center[0]);
      const world_leftSideAngle = this.roundAngle(segement.angle + local_leftSideAngle);
      let right_intersect_locationX = this.local_center[0] + dx;
      if (right_intersect_locationX > segement.length) {
        right_intersect_locationX = segement.length;
      }
      const local_rightSideAngle = this.atan2Rounded(dy, right_intersect_locationX - this.local_center[0]);
      const angleDistance = local_rightSideAngle - local_leftSideAngle;
      const angleAdvanceDirection = Math.sign(angleDistance);
      let angleDistanceRouded = Math.abs(angleDistance);
      if (angleDistanceRouded >= Math.PI) {
        angleDistanceRouded -= Math.PI;
      }
      const max_angleIndexCount = Math.abs(Math.floor(angleDistanceRouded / occlusionMap_unitAngle)) + 1;
      const offset_y = -this.local_center[1];
      const scan_unitAngle = occlusionMap_unitAngle * angleAdvanceDirection;
      let angleIndex = Math.floor(world_leftSideAngle / occlusionMap_unitAngle);
      for (let angleIndexCount = 0; angleIndexCount < max_angleIndexCount; angleIndexCount++) {
        const angle = local_leftSideAngle + angleIndexCount * scan_unitAngle;
        const offset_x = offset_y / Math.tan(angle);
        const distanceSq = offset_x * offset_x + offset_y * offset_y;
        const existing_distanceSq = map_data[angleIndex];
        if (existing_distanceSq == 0 || existing_distanceSq > distanceSq) {
          map_data[angleIndex] = distanceSq;
        }
        angleIndex += angleAdvanceDirection;
        if (angleIndex >= occlusionMapLength) {
          angleIndex = 0;
        } else if (angleIndex < 0) {
          angleIndex += occlusionMapLength;
        }
      }
    }
  }
  atan2Rounded(y2, x2) {
    let angle = Math.atan2(-y2, x2);
    if (angle < 0) {
      angle += Math.PI * 2;
    }
    return this.roundAngle(angle);
  }
  roundAngle(angle) {
    if (angle < 0) {
      angle += Math.PI * 2;
    }
    if (angle >= Math.PI * 2) {
      angle -= Math.PI * 2;
    }
    return angle;
  }
  traslateMat2d(result, target, mat2d2) {
    const x2 = target[0];
    const y2 = target[1];
    result[0] = x2 * mat2d2[0] + y2 * mat2d2[2] + mat2d2[4];
    result[1] = x2 * mat2d2[1] + y2 * mat2d2[3] + mat2d2[5];
  }
  setMaskForBrushShape(renderCache, center_location, radius, occlusionMap) {
    const mask_array = renderCache.maskData.data;
    const pixelBytes = renderCache.maskData.pixelBytes;
    const lineBytes = renderCache.maskData.lineBytes;
    const center_x = center_location[0] - renderCache.location[0];
    const center_y = center_location[1] - renderCache.location[1];
    const bound_radius = Math.floor(radius + 1);
    const pixel_center_left = Math.floor(center_x - bound_radius);
    const pixel_center_right = Math.floor(center_x + bound_radius);
    const pixel_center_top = Math.floor(center_y - bound_radius);
    const pixel_center_bottom = Math.floor(center_y + bound_radius);
    const minX = Math.min(Math.max(pixel_center_left, 0), renderCache.width - 2);
    const minY = Math.min(Math.max(pixel_center_top, 0), renderCache.height - 2);
    const maxX = Math.min(Math.max(pixel_center_right, 0), renderCache.width - 2);
    const maxY = Math.min(Math.max(pixel_center_bottom, 0), renderCache.height - 2);
    const radiusSq = bound_radius * bound_radius;
    const pixel_centering_offset = 0.5;
    for (let y2 = minY; y2 <= maxY; y2++) {
      let mask_offset = y2 * lineBytes + minX * pixelBytes;
      for (let x2 = minX; x2 <= maxX; x2++) {
        if (mask_array[mask_offset] != 0) {
          mask_offset += pixelBytes;
          continue;
        }
        const dx = x2 + pixel_centering_offset - center_x;
        const dy = y2 + pixel_centering_offset - center_y;
        const distance = dx * dx + dy * dy;
        let angle = Math.atan2(-dy, dx);
        if (angle < 0) {
          angle = Math.PI * 2 + angle;
        }
        const angleIndex = Math.floor(angle / Math.PI / 2 * occlusionMap.mapLength);
        const occlusion_distance = occlusionMap.data[angleIndex];
        if (distance <= radiusSq && (occlusion_distance == 0 || distance <= occlusion_distance)) {
          mask_array[mask_offset] = 1;
        }
        mask_offset += pixelBytes;
      }
    }
  }
  drawRenderResult(render, renderCache) {
    this.setMaskImageToImageData(renderCache.maskImageData, renderCache.maskData, [255, 255, 0, 255]);
    render.setBlendMode(CanvasRenderBlendMode.destinationIn);
    render.resetTransform();
    render.drawImage(
      renderCache.maskImageData.canvasWindow.canvas,
      0,
      0,
      renderCache.maskImageData.canvasWindow.width,
      renderCache.maskImageData.canvasWindow.height,
      0,
      0,
      renderCache.maskImageData.canvasWindow.width,
      renderCache.maskImageData.canvasWindow.height
    );
    render.setBlendMode(CanvasRenderBlendMode.default);
  }
  setMaskImageToImageData(maskImageData, maskData, color) {
    const image_array = maskImageData.imageData.data;
    const mask_data = maskData.data;
    for (let y2 = 0; y2 < maskData.height; y2++) {
      let iamge_offset = y2 * maskImageData.lineBytes;
      let mask_offset = y2 * maskData.lineBytes;
      for (let x2 = 0; x2 < maskData.width; x2++) {
        if (mask_data[mask_offset] != 0) {
          image_array[iamge_offset] = color[0];
          image_array[iamge_offset + 1] = color[1];
          image_array[iamge_offset + 2] = color[2];
          image_array[iamge_offset + 3] = color[3];
        } else {
          image_array[iamge_offset] = 0;
          image_array[iamge_offset + 1] = 0;
          image_array[iamge_offset + 2] = 0;
          image_array[iamge_offset + 3] = 0;
        }
        iamge_offset += maskImageData.pixelBytes;
        mask_offset += maskData.pixelBytes;
      }
    }
    maskImageData.canvasWindow.context.putImageData(maskImageData.imageData, 0, 0);
  }
}
class DrawingPosing3DLogic {
  constructor() {
    this.posing3DViewRender = new WebGLRender();
    this.posing3dView = new Posing3DView();
  }
  link(posing3DViewRender, posing3dView) {
    this.posing3DViewRender = posing3DViewRender;
    this.posing3dView = posing3dView;
  }
  drawPosing3DView(webglWindow, layerWindowItems, mainWindow, ctx, redrawActiveLayerOnly) {
    this.posing3DViewRender.setViewport(0, 0, webglWindow.width, webglWindow.height);
    this.posing3dView.clear();
    mainWindow.copyTransformTo(webglWindow);
    for (const item of layerWindowItems) {
      if (!PosingLayer.isPosingLayer(item.layer)) {
        continue;
      }
      const posingLayer = item.layer;
      this.posing3dView.prepareDrawingStructures(posingLayer);
    }
    if (ctx.currentPosingLayer != null && Layer.isVisible(ctx.currentPosingLayer) && ctx.mainToolID == MainToolID.posing3D) {
      const posingLayer = ctx.currentPosingLayer;
      this.posing3dView.drawManipulaters(posingLayer, ctx);
    }
    for (let index2 = layerWindowItems.length - 1; index2 >= 0; index2--) {
      const item = layerWindowItems[index2];
      if (!PosingLayer.isPosingLayer(item.layer)) {
        continue;
      }
      if (redrawActiveLayerOnly) {
        if (!Layer.isSelected(item.layer)) {
          continue;
        }
      } else {
        if (!Layer.isVisible(item.layer)) {
          continue;
        }
      }
      const posingLayer = item.layer;
      this.posing3dView.drawPosingModel(posingLayer, ctx);
    }
  }
}
class StrokeDrawingState {
  constructor() {
    this.drawingMode = 0;
    this.color = null;
    this.useAdjustingLocation = false;
    this.isExporting = false;
    this.strokeWidthBiasRate = 1;
    this.strokeWidthBolding = 0;
    this.strokeStarted = false;
    this.drawingRemainging = false;
    this.currentLineWidth = -1;
    this.currentSelection = 0;
  }
  begin(drawingMode) {
    this.drawingMode = drawingMode;
    this.useAdjustingLocation = false;
    this.isExporting = false;
    this.strokeWidthBiasRate = 1;
    this.strokeWidthBolding = 0;
    this.strokeStarted = false;
    this.drawingRemainging = false;
    this.currentLineWidth = 0;
    this.currentSelection = 0;
  }
}
class DrawingStrokeLogic {
  constructor() {
    this.toLocation = vec3.create();
    this.fromLocation = vec3.create();
    this.drawingState = new StrokeDrawingState();
  }
  isStrokeInViewRectangle(render, stroke) {
    if (VectorStrokeLogic.isEmptyStroke(stroke)) {
      return true;
    }
    return render.isInViewRectangle(stroke.runtime.area.centerLocation, stroke.runtime.area.range);
  }
  beginStroke(color, strokeWidthBiasRate, strokeWidthBolding, useAdjustingLocation, isExporting) {
    this.drawingState.begin(0);
    this.drawingState.color = color;
    this.drawingState.useAdjustingLocation = useAdjustingLocation;
    this.drawingState.isExporting = isExporting;
    this.drawingState.strokeWidthBiasRate = strokeWidthBiasRate;
    this.drawingState.strokeWidthBolding = strokeWidthBolding;
    this.drawingState.isExporting = isExporting;
  }
  finishStroke(render) {
    if (this.drawingState.drawingRemainging) {
      render.stroke();
      this.drawingState.drawingRemainging = false;
    }
  }
  drawVectorStroke(render, stroke, color, strokeWidthBiasRate, strokeWidthBolding, useAdjustingLocation, isExporting) {
    this.beginStroke(color, strokeWidthBiasRate, strokeWidthBolding, useAdjustingLocation, isExporting);
    this.processStroke(render, stroke);
    this.finishStroke(render);
  }
  processStroke(render, stroke) {
    const state = this.drawingState;
    if (!state.isExporting && !this.isStrokeInViewRectangle(render, stroke) || VectorStrokeLogic.isEmptyStroke(stroke)) {
      return;
    }
    if (!state.strokeStarted) {
      render.setStrokeColorV(state.color);
      render.setLineCap(CanvasRenderLineCap.round);
    }
    for (let pointIndex = 0; pointIndex < stroke.points.length - 1; ) {
      const fromPoint = stroke.points[pointIndex];
      const lineWidth = state.useAdjustingLocation ? fromPoint.adjustingLineWidth : fromPoint.lineWidth;
      if (state.drawingMode == 0 && lineWidth != state.currentLineWidth) {
        if (state.drawingRemainging) {
          render.stroke();
          state.strokeStarted = false;
          state.drawingRemainging = false;
        }
        render.setStrokeWidth(lineWidth * state.strokeWidthBiasRate + state.strokeWidthBolding);
        state.currentLineWidth = lineWidth;
      }
      this.processStrokeSegment(render, stroke, pointIndex, state);
      pointIndex++;
    }
  }
  drawVectorStrokeSegment(render, stroke, color, selected_color, strokeWidthBiasRate, useAdjustingLocation) {
    if (!this.isStrokeInViewRectangle(render, stroke)) {
      return;
    }
    if (VectorStrokeLogic.isEmptyStroke(stroke)) {
      return;
    }
    const state = this.drawingState;
    state.begin(0);
    state.useAdjustingLocation = useAdjustingLocation;
    render.setLineCap(CanvasRenderLineCap.round);
    for (let pointIndex = 0; pointIndex < stroke.points.length - 1; pointIndex++) {
      const fromPoint = stroke.points[pointIndex];
      const lineWidth = this.getPointWidth(fromPoint, state.useAdjustingLocation);
      const selection = fromPoint.isSelected ? 1 : 2;
      if (lineWidth != state.currentLineWidth || selection != state.currentSelection) {
        if (state.drawingRemainging) {
          render.stroke();
          state.strokeStarted = false;
          state.drawingRemainging = false;
        }
        render.setStrokeWidth(lineWidth * strokeWidthBiasRate);
        state.currentLineWidth = lineWidth;
        render.setStrokeColorV(selection == 1 ? selected_color : color);
        state.currentSelection = selection;
      }
      this.processStrokeSegment(render, stroke, pointIndex, state);
    }
    if (state.drawingRemainging) {
      render.stroke();
      state.drawingRemainging = false;
    }
  }
  beginFill(color, useAdjustingLocation) {
    this.drawingState.begin(1);
    this.drawingState.color = color;
    this.drawingState.useAdjustingLocation = useAdjustingLocation;
  }
  finishFill(render) {
    if (this.drawingState.drawingRemainging) {
      render.fill();
      this.drawingState.drawingRemainging = false;
    }
  }
  processFill(render, stroke) {
    if (VectorStrokeLogic.isEmptyStroke(stroke)) {
      return;
    }
    const state = this.drawingState;
    if (!state.strokeStarted) {
      render.setLineCap(CanvasRenderLineCap.round);
      render.setFillColorV(state.color);
    }
    for (let pointIndex = 0; pointIndex < stroke.points.length - 1; pointIndex++) {
      this.processStrokeSegment(render, stroke, pointIndex, state);
    }
  }
  getPointLocation(point, useAdjustingLocation) {
    return useAdjustingLocation ? point.adjustingLocation : point.location;
  }
  getPointWidth(point, useAdjustingLocation) {
    return useAdjustingLocation ? point.adjustingLineWidth : point.lineWidth;
  }
  processStrokeSegment(render, stroke, pointIndex, state) {
    const fromPoint = stroke.points[pointIndex];
    const fromLocation = this.getPointLocation(fromPoint, state.useAdjustingLocation);
    const toPoint = stroke.points[pointIndex + 1];
    const toLocation = this.getPointLocation(toPoint, state.useAdjustingLocation);
    const lengthFrom = state.useAdjustingLocation ? fromPoint.adjustingLengthFrom : 1;
    const lengthTo = state.useAdjustingLocation ? fromPoint.adjustingLengthTo : 0;
    if (lengthFrom == 1) {
      if (!state.strokeStarted) {
        render.beginPath();
        render.moveToV(fromLocation);
        state.strokeStarted = true;
      } else if (pointIndex == 0) {
        render.lineToV(fromLocation);
      }
      render.lineToV(toLocation);
      state.drawingRemainging = true;
    } else {
      if (lengthFrom > 0) {
        if (!state.strokeStarted) {
          render.beginPath();
          render.moveToV(fromLocation);
          state.strokeStarted = true;
        }
        vec3.lerp(this.toLocation, fromLocation, toLocation, lengthFrom);
        render.lineToV(this.toLocation);
        state.drawingRemainging = true;
        if (state.drawingMode == 0) {
          render.stroke();
          state.strokeStarted = false;
          state.drawingRemainging = false;
        }
      }
      if (lengthTo > 0 && lengthTo < 1) {
        if (state.drawingMode == 0 && state.drawingRemainging) {
          render.stroke();
          state.strokeStarted = false;
          state.drawingRemainging = false;
        }
        vec3.lerp(this.fromLocation, fromLocation, toLocation, lengthTo);
        if (!state.strokeStarted) {
          render.beginPath();
          render.moveToV(this.fromLocation);
          state.strokeStarted = true;
        } else {
          render.lineToV(this.fromLocation);
          state.drawingRemainging = false;
        }
        render.lineToV(toLocation);
        state.drawingRemainging = true;
      }
    }
  }
}
class ToolDrawingStyle {
  constructor() {
    this.windowBorderColor = vec4.fromValues(8 / 16, 8 / 16, 8 / 16, 1);
    this.windowBackgroundColor = vec4.fromValues(246 / 255, 246 / 255, 248 / 255, 1);
    this.controlHoverColor = vec4.fromValues(0.91, 0.91, 0.91, 1);
    this.linePointColor = vec4.fromValues(0, 0, 0, 1);
    this.sampledPointColor = vec4.fromValues(0, 0.5, 1, 0.7);
    this.extrutePointColor = vec4.fromValues(0, 0, 0, 1);
    this.editingLineColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.selectedVectorLineColor = vec4.fromValues(1, 0.5, 0, 0.8);
    this.selectedLineColorVisibilityAdjustThreshold1 = 0.07;
    this.selectedLineColorVisibilityAdjustThreshold2 = 0.7;
    this.selectedLineColorVisibilityAdjustHue = 0.1;
    this.linePointVisualBrightnessAdjustRate = 0.4;
    this.editModeOtherLayerAlphaAdjustRate = 0.3;
    this.editorThinLineWidth = 1.5;
    this.strokeConnectionInfoColor = vec4.fromValues(0, 0, 0, 0.5);
    this.brushCursorCircleColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.mouseCursorCircleColor = vec4.fromValues(1, 0.5, 0.5, 1);
    this.operatorCursorCircleColor = vec4.fromValues(1, 0.5, 0.5, 1);
    this.operatorCurosrLineDash = [2, 2];
    this.operationPanelButtonBorderColor = vec4.fromValues(14 / 16, 14 / 16, 14 / 16, 1);
    this.rulerHeight = 13;
    this.rulerTextSize = 12;
    this.rulerTextMargin = { x: 3, y: 2 };
    this.rulerLineColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.rulerBackGroundColor = vec4.fromValues(0.8, 0.8, 0.8, 1);
    this.rulerDocumentAreaColor = vec4.fromValues(0.95, 0.95, 0.95, 1);
    this.documentFrameOutAreaColor = vec4.fromValues(0, 0, 0, 0.7);
    this.onionSkinForwardLineColor = vec4.fromValues(0, 0.5, 0, 0.6);
    this.onionSkinBackwardLineColor = vec4.fromValues(0.5, 0, 0, 0.6);
    this.modalToolSelectedAreaLineColor = vec4.fromValues(1, 0.5, 0.5, 1);
    this.latticePointRadius = 4;
    this.latticePointHitRadius = 10;
    this.latticePointPadding = 8;
    this.autoFillPointLineColor = vec4.fromValues(0, 0, 0, 1);
    this.autoFillPointEdgeColor = vec4.fromValues(1, 1, 1, 1);
    this.paletteSelectorItemEdgeColor = vec4.fromValues(0, 0, 0, 1);
    this.paletteSelectorItemSelectedColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.timeLineUnitFrameColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.timeLineCurrentFrameColor = vec4.fromValues(0.2, 1, 0.2, 0.5);
    this.timeLineKeyFrameColor = vec4.fromValues(0, 0, 1, 0.1);
    this.timeLineLayerKeyFrameColor = vec4.fromValues(0.8, 0.8, 0, 1);
    this.timeLineOutOfLoopingColor = vec4.fromValues(0, 0, 0, 0.1);
    this.posing3DBoneGrayColor = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.posing3DBoneHeadColor = vec4.fromValues(0.2, 0.2, 1, 1);
    this.posing3DBoneForwardColor = vec4.fromValues(0.2, 1, 0.2, 1);
    this.posing3DBoneInputCircleRadius = 15;
    this.posing3DBoneInputCircleHitRadius = 1.8;
    this.posing3DHelperGrayColor1 = vec4.fromValues(0.5, 0.5, 0.5, 1);
    this.posing3DHelperGrayColor2 = vec4.fromValues(0.5, 0.5, 0.5, 0.3);
    this.generalLinePointRadius = 2;
    this.selectedLinePointRadius = 3;
    this.viewZoomAdjustingSpeedRate = 0.2;
    this.eyesSymmetryGuideColor = vec4.fromValues(0, 0.5, 1, 0.3);
  }
}
class CanvasFrame {
  constructor() {
    this.drawStyle = null;
    this.documentFrameCornerIndexs = [[0, 1], [0, 3], [2, 3], [2, 1], [0, 1]];
    this.documentFrameCornerIndexsReverse = Lists.reverse(Lists.clone(this.documentFrameCornerIndexs));
    this.cornerPosition = vec3.fromValues(0, 0, 0);
    this.tempVec3 = vec3.create();
  }
  link(drawStyle) {
    this.drawStyle = drawStyle;
  }
  draw(render, documentData, mirrored) {
    render.resetTransform();
    render.setFillColorV(this.drawStyle.documentFrameOutAreaColor);
    const cornerIndeces = mirrored ? this.documentFrameCornerIndexs : this.documentFrameCornerIndexsReverse;
    render.beginPath();
    let index2 = 0;
    for (const cornerIndex of cornerIndeces) {
      const x2 = documentData.documentFrame[cornerIndex[0]];
      const y2 = documentData.documentFrame[cornerIndex[1]];
      vec3.set(this.tempVec3, x2, y2, 0);
      vec3.transformMat4(this.cornerPosition, this.tempVec3, render.transformMatrix);
      if (index2 == 0) {
        render.moveToV(this.cornerPosition);
      } else {
        render.lineToV(this.cornerPosition);
      }
      index2++;
    }
    render.moveTo(0, 0);
    render.lineTo(render.canvasWidth, 0);
    render.lineTo(render.canvasWidth, render.canvasHeight);
    render.lineTo(0, render.canvasHeight);
    render.lineTo(0, 0);
    render.fill();
  }
}
var CanvasRulerOrientation = /* @__PURE__ */ ((CanvasRulerOrientation2) => {
  CanvasRulerOrientation2[CanvasRulerOrientation2["horizontalTop"] = 0] = "horizontalTop";
  CanvasRulerOrientation2[CanvasRulerOrientation2["verticalLeft"] = 1] = "verticalLeft";
  return CanvasRulerOrientation2;
})(CanvasRulerOrientation || {});
class CanvasRuler {
  constructor() {
    this.drawStyle = null;
    this.orientation = 0;
    this.viewHeight = 0;
    this.width = 0;
    this.height = 13;
    this.documentFrameCornerIndexs = [[0, 1], [2, 3], [2, 1], [0, 3]];
    this.documentFramePositions = [0, 0, 0, 0];
    this.documentPositionInfo = {
      origin: 0,
      frameLeft: 0,
      frameRight: 0
    };
    this.unitScaleNumbers = [1, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1e3, 2e3, 2500, 5e3];
    this.origin = vec3.fromValues(0, 0, 0);
    this.cornerPosition = vec3.fromValues(0, 0, 0);
    this.tempVec3 = vec3.create();
    this.viewMatrix = mat4.create();
  }
  link(drawStyle) {
    this.drawStyle = drawStyle;
  }
  isHorizontal() {
    return this.orientation == 0;
  }
  updateLayout(canvasWindow, orientation) {
    this.orientation = orientation;
    this.viewHeight = canvasWindow.height;
    if (this.isHorizontal()) {
      this.width = canvasWindow.width;
    } else {
      this.width = canvasWindow.height;
    }
    this.height = this.drawStyle.rulerHeight;
  }
  draw(render, canvasWindow, documentData) {
    const isHorizontal = this.isHorizontal();
    const cornerPositionIndex = isHorizontal ? 0 : 1;
    const right = this.width;
    const bottom = this.height;
    const cornerMargin = this.height;
    const { frameLeft, frameRight, origin } = this.calculateDocumentFramePositionInfo(canvasWindow, documentData, cornerPositionIndex);
    this.setBaseTransform(render, isHorizontal);
    render.setStrokeWidth(1);
    render.setFillColorV(this.drawStyle.rulerBackGroundColor);
    this.fillRect(cornerMargin, 0, frameLeft, bottom, isHorizontal, render);
    render.setFillColorV(this.drawStyle.rulerDocumentAreaColor);
    this.fillRect(frameLeft, 0, frameRight - frameLeft, bottom, isHorizontal, render);
    render.setFillColorV(this.drawStyle.rulerBackGroundColor);
    this.fillRect(frameRight, 0, right - frameRight, bottom, isHorizontal, render);
    render.setStrokeColorV(this.drawStyle.rulerLineColor);
    this.drawLine(0, bottom + 0.5, right, bottom + 0.5, isHorizontal, render);
    render.setStrokeColorV(this.drawStyle.rulerLineColor);
    this.drawScales(render, canvasWindow, origin, bottom, isHorizontal, this.drawScaleLine);
    render.setFontSize(this.drawStyle.rulerTextSize);
    render.setFillColorV(this.drawStyle.rulerLineColor);
    this.drawScales(render, canvasWindow, origin, bottom, isHorizontal, this.drawScaleNumber);
  }
  calculateDocumentFramePositionInfo(canvasWindow, documentData, cornerPositionIndex) {
    let index2 = 0;
    for (const documentFrameCornerIndex of this.documentFrameCornerIndexs) {
      const x2 = documentData.documentFrame[documentFrameCornerIndex[0]];
      const y2 = documentData.documentFrame[documentFrameCornerIndex[1]];
      vec3.set(this.tempVec3, x2, y2, 0);
      vec3.transformMat4(this.cornerPosition, this.tempVec3, canvasWindow.transformMatrix);
      this.documentFramePositions[index2] = this.cornerPosition[cornerPositionIndex];
      index2++;
    }
    vec3.set(this.tempVec3, 0, 0, 0);
    vec3.transformMat4(this.origin, this.tempVec3, canvasWindow.transformMatrix);
    this.documentPositionInfo.frameLeft = this.documentFramePositions.reduce((a, b) => Math.min(a, b));
    this.documentPositionInfo.frameRight = this.documentFramePositions.reduce((a, b) => Math.max(a, b));
    this.documentPositionInfo.origin = this.origin[cornerPositionIndex];
    return this.documentPositionInfo;
  }
  setBaseTransform(render, isHorizontal) {
    mat4.identity(this.viewMatrix);
    if (!isHorizontal) {
      mat4.translate(this.viewMatrix, this.viewMatrix, vec3.set(this.tempVec3, 0, this.viewHeight, 0));
      mat4.rotateZ(this.viewMatrix, this.viewMatrix, -Math.PI / 2);
    }
    render.setTransformFromMatrix(this.viewMatrix);
  }
  getUnitScaleNumber(canvasWindow, scaleUnitWidth) {
    const letterUnitWidth = 6;
    const letterDigits = 4;
    const letterTextMargin = letterUnitWidth * 4;
    const scaleTextWidth = letterUnitWidth * letterDigits + letterTextMargin;
    let unitScaleNumber = 1;
    for (let scaleNumber of this.unitScaleNumbers) {
      if (scaleNumber * scaleUnitWidth > scaleTextWidth) {
        unitScaleNumber = scaleNumber;
        break;
      }
    }
    return unitScaleNumber;
  }
  drawScales(render, canvasWindow, origin, bottom, isHorizontal, drawFunction) {
    const scaleHeightL = this.height * 0.8;
    const scaleHeightM = this.height * 0.4;
    const scaleHeightS = this.height * 0.2;
    const scaleUnitWidth = canvasWindow.viewScale;
    const unitScaleNumber = this.getUnitScaleNumber(canvasWindow, scaleUnitWidth);
    const scaleStep = unitScaleNumber * scaleUnitWidth;
    const subscaleDivision = unitScaleNumber > 1 ? 5 : 2;
    const subScaleStep = scaleStep / subscaleDivision;
    const startScaleCount = -(Math.floor(origin / scaleStep) + 1);
    const endScaleCount = Math.floor((this.width - origin) / scaleStep) + 1;
    let scaleCount = startScaleCount;
    let subScaleCount = 0;
    while (scaleCount <= endScaleCount) {
      let scaleX = origin + scaleCount * scaleStep + subScaleCount * subScaleStep;
      let scaleNumber = scaleCount * unitScaleNumber;
      let scaleHeight;
      let isLargeScale;
      if (scaleCount == 0 && subScaleCount == 0) {
        scaleHeight = scaleHeightL;
        isLargeScale = true;
      } else if (subScaleCount == 0) {
        scaleHeight = scaleHeightM;
        isLargeScale = true;
      } else {
        scaleHeight = scaleHeightS;
        isLargeScale = false;
      }
      drawFunction.call(this, scaleNumber, scaleX, scaleHeight, bottom, isLargeScale, isHorizontal, render);
      scaleX += subScaleStep;
      subScaleCount++;
      if (subScaleCount >= subscaleDivision) {
        subScaleCount = 0;
        scaleCount++;
      }
    }
  }
  drawScaleLine(_scaleNumber, x2, scaleHeight, bottom, _isLargeScale, isHorizontal, render) {
    this.drawLine(x2, bottom - scaleHeight, x2, bottom, isHorizontal, render);
  }
  drawScaleNumber(scaleNumber, x2, _scaleHeight, bottom, isLargeScale, isHorizontal, render) {
    if (!isLargeScale) {
      return;
    }
    let destX;
    if (isHorizontal) {
      destX = x2;
    } else {
      destX = this.viewHeight - x2;
    }
    render.fillText(scaleNumber.toFixed(0), destX + this.drawStyle.rulerTextMargin.x, bottom - +this.drawStyle.rulerTextMargin.y);
  }
  drawLine(x1, y1, x2, y2, isHorizontal, render) {
    if (isHorizontal) {
      render.drawLine(x1, y1, x2, y2);
    } else {
      render.drawLine(this.viewHeight - x1, y1, this.viewHeight - x2, y2);
    }
  }
  fillRect(left, top, width, height, isHorizontal, render) {
    if (isHorizontal) {
      render.fillRect(left, top, width, height);
    } else {
      render.fillRect(this.viewHeight - left - width, top, width, height);
    }
  }
  drawCorner(render) {
    render.resetTransform();
    render.setStrokeWidth(1);
    render.setStrokeColorV(this.drawStyle.rulerLineColor);
    render.setFillColorV(this.drawStyle.windowBackgroundColor);
    render.fillRect(0, 0, this.height, this.height);
    render.drawLine(0, this.height + 0.5, this.height + 0.5, this.height + 0.5);
    render.drawLine(this.height + 0.5, 0, this.height + 0.5, this.height + 0.5);
  }
}
class MainCanvasEditorDrawer {
  constructor() {
    this.canvasRender = null;
    this.drawStyle = null;
    this.drawingStroke = null;
    this.drawingPointBrush = null;
    this.mainWindow = null;
    this.linePointColor = vec4.fromValues(0, 0, 0, 1);
    this.selectedLinePointColor = vec4.fromValues(0, 0, 0, 1);
    this.hsv = vec4.fromValues(0, 0, 0, 1);
    this.sel_hsv = vec4.fromValues(0, 0, 0, 1);
    this.editorStrokeDashScaled = [0, 0];
    this.strokeConnectionDash = [4, 4];
  }
  link(canvasRender, drawStyle, mainWindow, drawingStroke, drawingPointBrush) {
    this.canvasRender = canvasRender;
    this.drawStyle = drawStyle;
    this.mainWindow = mainWindow;
    this.drawingStroke = drawingStroke;
    this.drawingPointBrush = drawingPointBrush;
  }
  getCurrentViewScaleLineWidth(width) {
    return this.canvasRender.getViewScaledSize(width);
  }
  drawPointerCursor(radius) {
    this.drawCursorCircle(this.mainWindow.pointerEvent.location, radius, this.drawStyle.mouseCursorCircleColor);
  }
  drawaBrushCursor(lineWidth, lineWidthBiasRate) {
    this.drawCursorCircle(
      this.mainWindow.pointerEvent.location,
      VectorPointLogic.getLineRadiusFromLineWidth(lineWidth * lineWidthBiasRate),
      this.drawStyle.brushCursorCircleColor
    );
  }
  drawCursorCircle(location, radius, color) {
    this.canvasRender.beginPath();
    this.canvasRender.setStrokeColorV(color);
    this.canvasRender.setStrokeWidth(this.getCurrentViewScaleLineWidth(1));
    this.canvasRender.circle(
      location[0],
      location[1],
      radius
    );
    this.canvasRender.stroke();
  }
  drawOperatorSolidStroke(stroke, strokeWidthBiasRate = 1) {
    this.drawingStroke.drawVectorStroke(this.canvasRender, stroke, this.drawStyle.editingLineColor, strokeWidthBiasRate, 0, false, false);
  }
  drawOperatorPointBrushStroke(stroke, color, useAdjustingLocation) {
    this.drawingPointBrush.drawPointBrushStroke(this.canvasRender, stroke, color, useAdjustingLocation, null);
  }
  drawEditorStroke(stroke, color, strokeWidthBolding, useAdjustingLocation) {
    this.drawingStroke.drawVectorStroke(this.canvasRender, stroke, color, 1, strokeWidthBolding, useAdjustingLocation, false);
  }
  drawEditorStrokePoints(stroke, color, useAdjustingLocation) {
    this.drawVectorLinePoints(stroke, color, useAdjustingLocation);
  }
  drawVectorLinePoints(stroke, color, useAdjustingLocation) {
    if (!this.isStrokeInViewRectangle(stroke)) {
      return;
    }
    const render = this.canvasRender;
    render.setStrokeWidth(this.getCurrentViewScaleLineWidth(1));
    ColorLogic.rgbToHSVv(this.hsv, color);
    if (this.hsv[2] > 0.5) {
      this.hsv[2] -= this.drawStyle.linePointVisualBrightnessAdjustRate;
    } else {
      this.hsv[2] += this.drawStyle.linePointVisualBrightnessAdjustRate;
    }
    if (this.hsv[1] < 0.2) {
      this.hsv[0] = 0.2;
      this.hsv[1] = 0.2;
    }
    ColorLogic.hsvToRGBv(this.linePointColor, this.hsv);
    vec4.copy(this.selectedLinePointColor, this.drawStyle.selectedVectorLineColor);
    if ((this.hsv[0] < this.drawStyle.selectedLineColorVisibilityAdjustThreshold1 || this.hsv[0] > this.drawStyle.selectedLineColorVisibilityAdjustThreshold2) && this.hsv[1] > 0) {
      ColorLogic.rgbToHSVv(this.sel_hsv, this.selectedLinePointColor);
      this.sel_hsv[0] += this.drawStyle.selectedLineColorVisibilityAdjustHue;
      ColorLogic.hsvToRGBv(this.selectedLinePointColor, this.sel_hsv);
    }
    this.linePointColor[3] = 0.8;
    render.setLineCap(CanvasRenderLineCap.round);
    for (const point of stroke.points) {
      this.drawVectorLinePoint(render, point, this.linePointColor, useAdjustingLocation, this.selectedLinePointColor);
    }
  }
  drawVectorLinePoint(render, point, color, useAdjustingLocation, slectedColor) {
    const viewScale = render.getViewScale();
    let radius = this.drawStyle.generalLinePointRadius / viewScale;
    let location;
    if (useAdjustingLocation) {
      location = point.adjustingLocation;
    } else {
      location = point.location;
    }
    if (!render.isInViewRectangle(location, radius)) {
      return;
    }
    if (point.isSelected) {
      radius = this.drawStyle.selectedLinePointRadius / viewScale;
      render.setStrokeColorV(slectedColor);
    } else {
      render.setStrokeColorV(color);
    }
    render.setStrokeWidth(radius * 2);
    render.beginPath();
    render.moveTo(location[0], location[1]);
    render.lineTo(location[0] + 0.01, location[1]);
    render.stroke();
  }
  drawEditorStrokePoint(point, color, useAdjustingLocation) {
    this.drawVectorLinePoint(this.canvasRender, point, color, useAdjustingLocation, this.drawStyle.selectedVectorLineColor);
  }
  drawStrokeConnectionInfoLine(from, to) {
    this.drawVectorStrokeConnectionInfoLine(this.canvasRender, from, to);
  }
  drawVectorStrokeConnectionInfo(render, connectionInfo, useAdjustingLocation) {
    if (connectionInfo.from_Stroke.points.length <= 1 || connectionInfo.to_Stroke.points.length <= 1) {
      return;
    }
    const from_point = connectionInfo.from_Stroke.points.at(-1);
    const from_location = useAdjustingLocation ? from_point.adjustingLocation : from_point.location;
    const to_point = connectionInfo.to_Stroke.points.at(0);
    const to_location = useAdjustingLocation ? to_point.adjustingLocation : to_point.location;
    this.drawVectorStrokeConnectionInfoLine(render, from_location, to_location);
  }
  drawVectorStrokeConnectionInfoLine(render, from, to) {
    render.setFillColorV(this.drawStyle.strokeConnectionInfoColor);
    this.setEditorThinLineStyle(this.strokeConnectionDash);
    render.beginPath();
    render.moveToV(from);
    render.lineToV(to);
    render.stroke();
    render.clearLineDash();
  }
  getEditorThinLineWidth() {
    return this.canvasRender.getViewScaledSize(this.drawStyle.editorThinLineWidth);
  }
  setEditorThinLineStyle(dashSetting) {
    const render = this.canvasRender;
    render.setLineCap(CanvasRenderLineCap.round);
    render.setStrokeWidth(this.getEditorThinLineWidth());
    const viewScale = render.getViewScaledSize(1);
    this.editorStrokeDashScaled[0] = dashSetting[0] * viewScale;
    this.editorStrokeDashScaled[1] = dashSetting[1] * viewScale;
    render.setLineDash(this.editorStrokeDashScaled);
  }
  isStrokeInViewRectangle(stroke) {
    if (VectorStrokeLogic.isEmptyStroke(stroke)) {
      return true;
    }
    return this.canvasRender.isInViewRectangle(stroke.runtime.area.centerLocation, stroke.runtime.area.range);
  }
}
class SVGFiles {
}
SVGFiles.icons = {
  dummy: "./res/icon_dummy.svg",
  openImage: "./res/perm_media_black_24dp.svg",
  move: "./res/open_with-24px.svg",
  rotate: "./res/rotate_right-24px.svg",
  scale: "./res/icon_scale.svg",
  zoom: "./res/zoom_in-24px.svg",
  draw: "./res/icon_draw.svg",
  eracer: "./res/icon_eracer.svg",
  extrudeLine: "./res/icon_extrude_line.svg",
  scratchLine: "./res/icon_scratch_line.svg",
  drawStrokeWidth: "./res/icon_draw_stroke_width.svg",
  selectLine: "./res/icon_select_line.svg",
  selectSegment: "./res/icon_select_segment.svg",
  selectPoint: "./res/icon_select_point.svg",
  editTransform: "./res/icon_edit_transform.svg",
  divideLineSegment: "./res/icon_divide_line_segment.svg"
};
var OperationPanelButtonID = /* @__PURE__ */ ((OperationPanelButtonID2) => {
  OperationPanelButtonID2[OperationPanelButtonID2["view_zoom"] = 1] = "view_zoom";
  OperationPanelButtonID2[OperationPanelButtonID2["view_rotate"] = 2] = "view_rotate";
  OperationPanelButtonID2[OperationPanelButtonID2["view_move"] = 3] = "view_move";
  OperationPanelButtonID2[OperationPanelButtonID2["draw"] = 4] = "draw";
  OperationPanelButtonID2[OperationPanelButtonID2["eraser"] = 5] = "eraser";
  OperationPanelButtonID2[OperationPanelButtonID2["brushSize"] = 6] = "brushSize";
  OperationPanelButtonID2[OperationPanelButtonID2["scratchLine"] = 7] = "scratchLine";
  return OperationPanelButtonID2;
})(OperationPanelButtonID || {});
class OperationPanel {
  constructor() {
    this.visible = false;
    this.drawStyle = null;
    this.mainOperationUI_Icons = [
      { image: new Image(), filePath: SVGFiles.icons.zoom },
      { image: new Image(), filePath: SVGFiles.icons.rotate },
      { image: new Image(), filePath: SVGFiles.icons.move },
      { image: new Image(), filePath: SVGFiles.icons.draw },
      { image: new Image(), filePath: SVGFiles.icons.eracer },
      { image: new Image(), filePath: SVGFiles.icons.scratchLine }
    ];
    this.mainOperationUI_PanelBorderPoints = [];
    this.mainOperationUI_Area = new RectangleLayoutArea().setSize(250, 170).setPadding({ left: 10, top: 10, right: 10, bottom: 10 }).setGridLayout({ columns: 3, columnGap: 7, rows: 2, rowGap: 7 }).setChildren([
      new RectangleLayoutArea().setIndex(4).setIcon(3),
      new RectangleLayoutArea().setIndex(2).setIcon(1),
      new RectangleLayoutArea().setIndex(3).setIcon(2),
      new RectangleLayoutArea().setIndex(5).setIcon(4),
      new RectangleLayoutArea().setIndex(7).setIcon(5),
      new RectangleLayoutArea().setIndex(1).setIcon(0)
    ]);
  }
  link(drawStyle) {
    this.drawStyle = drawStyle;
  }
  startLoadingImageResources() {
    for (const icon of this.mainOperationUI_Icons) {
      icon.image.src = icon.filePath;
    }
  }
  isVisible() {
    return this.visible;
  }
  setVisibility(visible) {
    return this.visible = visible;
  }
  toggleVisibility() {
    return this.visible = !this.visible;
  }
  hittestToButtons(e) {
    if (!this.visible) {
      return null;
    }
    return LayoutLogic.hitTestLayout(this.mainOperationUI_Area.children, e.offsetX, e.offsetY);
  }
  hittestToPanel(e) {
    if (!this.visible) {
      return null;
    }
    return LayoutLogic.hitTestLayout(this.mainOperationUI_Area, e.offsetX, e.offsetY);
  }
  updateLayout(canvasWindow) {
    const area = this.mainOperationUI_Area;
    const offsetToCancelAntialius = 0.5;
    area.left = -offsetToCancelAntialius;
    area.right = area.left + area.width;
    area.top = offsetToCancelAntialius + canvasWindow.height - area.height;
    area.bottom = area.top + area.height;
    const windowBorderRadius = 20;
    const windowBorderRadiusUnit = 90 / 10;
    this.mainOperationUI_PanelBorderPoints = [];
    this.mainOperationUI_PanelBorderPoints.push([area.left, area.top]);
    this.mainOperationUI_PanelBorderPoints.push([area.right - windowBorderRadius, area.top]);
    for (let r2 = 90 - windowBorderRadiusUnit; r2 >= 0; r2 -= windowBorderRadiusUnit) {
      this.mainOperationUI_PanelBorderPoints.push([
        area.right - windowBorderRadius + Math.cos(r2 * Math.PI / 180) * windowBorderRadius,
        area.top + windowBorderRadius - Math.sin(r2 * Math.PI / 180) * windowBorderRadius
      ]);
    }
    this.mainOperationUI_PanelBorderPoints.push([area.right, area.bottom]);
    this.mainOperationUI_PanelBorderPoints.push([area.left, area.bottom]);
    LayoutLogic.calculateGridLayout(area, area.gridLayoutOptions);
  }
  draw(render) {
    if (!this.visible) {
      return null;
    }
    render.resetTransform();
    render.setStrokeWidth(1);
    render.setFillColorV(this.drawStyle.windowBackgroundColor);
    render.fillPath(this.mainOperationUI_PanelBorderPoints);
    render.setStrokeColorV(this.drawStyle.windowBorderColor);
    render.strokePath(this.mainOperationUI_PanelBorderPoints);
    render.setStrokeColorV(this.drawStyle.operationPanelButtonBorderColor);
    for (const area of this.mainOperationUI_Area.children) {
      if (area.iconID != -1) {
        if (area.hover) {
          render.setFillColorV(this.drawStyle.controlHoverColor);
          render.fillRoundRect(area.left, area.top, area.width, area.width, 10);
        }
        render.setStrokeWidth(3);
        render.strokeRoundRect(area.left, area.top, area.width, area.width, 10);
        const icon = this.mainOperationUI_Icons[area.iconID];
        render.drawImage(icon.image, 0, 0, 24, 24, area.left, area.top, area.width, area.width);
      }
    }
  }
}
class OperatorCursor {
  constructor() {
    this.location = vec3.fromValues(0, 0, 0);
    this.radius = 15;
  }
}
class OperatorCursorLogic {
  constructor() {
    this.canvasRender = null;
    this.drawStyle = null;
    this.editorDrawer = null;
    this.operatorCurosrLineDash = [2, 2];
  }
  link(canvasRender, drawStyle, editorDrawer) {
    this.canvasRender = canvasRender;
    this.drawStyle = drawStyle;
    this.editorDrawer = editorDrawer;
  }
  drawOperatorCursor(operatorCursor) {
    this.canvasRender.beginPath();
    this.canvasRender.setStrokeColorV(this.drawStyle.operatorCursorCircleColor);
    this.canvasRender.setStrokeWidth(this.editorDrawer.getEditorThinLineWidth());
    this.editorDrawer.setEditorThinLineStyle(this.operatorCurosrLineDash);
    const viewScale = this.canvasRender.getViewScaledSize(1);
    this.canvasRender.circle(
      operatorCursor.location[0],
      operatorCursor.location[1],
      operatorCursor.radius * viewScale
    );
    this.canvasRender.stroke();
    const centerX = operatorCursor.location[0];
    const centerY = operatorCursor.location[1];
    const clossBeginPosition = operatorCursor.radius * viewScale * 1.5;
    const clossEndPosition = operatorCursor.radius * viewScale * 0.5;
    this.canvasRender.drawLine(centerX - clossBeginPosition, centerY, centerX - clossEndPosition, centerY);
    this.canvasRender.drawLine(centerX + clossBeginPosition, centerY, centerX + clossEndPosition, centerY);
    this.canvasRender.drawLine(centerX, centerY - clossBeginPosition, centerX, centerY - clossEndPosition);
    this.canvasRender.drawLine(centerX, centerY + clossBeginPosition, centerX, centerY + clossEndPosition);
    this.canvasRender.clearLineDash();
  }
}
class OnionSiknDrawing {
  constructor() {
    this.onionSkinMode = OnionSkinMode.disabled;
    this.backward_DrawPathContexts = [];
    this.forward_DrawPathContexts = [];
  }
}
class App_Drawing {
  constructor() {
    this.canvasRender = new CanvasRender();
    this.fullScreen_canvasRender = new CanvasRender();
    this.local_canvasRender = new CanvasRender();
    this.drawGPURender = new WebGLRender();
    this.drawingStroke = new DrawingStrokeLogic();
    this.drawingPointBrush = new DrawingPointBrushLogic();
    this.editorDrawer = new MainCanvasEditorDrawer();
    this.operatorCursor = new OperatorCursorLogic();
    this.drawingVectorLayer = new DrawingVectorLayerLogic();
    this.drawingIFRLayer = new DrawingImageFileReferenceLayerLogic();
    this.drawingEyesSymmetry = new DrawingEyesSymmetryLogic();
    this.drawingPosing3D = new DrawingPosing3DLogic();
    this.drawPathCollecting = new DrawPathCollectingLogic();
    this.drawPathBuffering = new DrawPathBufferingLogic();
    this.logic_GPULine = new Logic_GPULine();
    this.renderingVectorLayer = new RenderingVectorLayerLogic();
    this.posing3DViewRender = new WebGLRender();
    this.posing3DView = new Posing3DView();
    this.drawStyle = new ToolDrawingStyle();
    this.appView = null;
    this.main_drawPathContext = new DrawPathContext();
    this.lazy_drawPathContext = new DrawPathContext();
    this.layerPickingLocations = [[0, 0], [0, -2], [2, 0], [0, 2], [-2, 0]];
    this.onionSiknDrawing = new OnionSiknDrawing();
    this.polyLineShader = new PolyLineShader();
    this.bezierLineShader = new BezierLineShader();
    this.bezierDistanceLineShader = new BezierDistanceLineShader();
    this.lineShader = this.bezierDistanceLineShader;
    this.tempColor4 = vec4.create();
    this.pickLayer_canvasWindow = new CanvasWindow();
    this.drawPath_logging = false;
  }
  link(appView) {
    this.appView = appView;
    this.drawingPointBrush.link(this.drawStyle);
    this.editorDrawer.link(this.canvasRender, this.drawStyle, this.appView.mainWindow, this.drawingStroke, this.drawingPointBrush);
    this.operatorCursor.link(this.canvasRender, this.drawStyle, this.editorDrawer);
    this.drawingVectorLayer.link(this.canvasRender, this.drawStyle, this.drawingStroke, this.drawingPointBrush, this.editorDrawer);
    this.drawingIFRLayer.link(this.canvasRender);
    this.drawingEyesSymmetry.link(this.canvasRender, this.drawStyle, this.editorDrawer);
    this.drawingPosing3D.link(this.posing3DViewRender, this.posing3DView);
    this.renderingVectorLayer.link(this.drawGPURender, this.lineShader, this.drawingVectorLayer, this.logic_GPULine);
  }
  initializeDrawingDevices(webglWindow, drawGPUWindow) {
    if (this.posing3DViewRender.initializeWebGL(webglWindow.canvas, true)) {
      console.log("\uFF13\uFF24\u30DD\u30FC\u30B8\u30F3\u30B0\u6A5F\u80FD\u3092\u521D\u671F\u5316\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002");
    }
    this.posing3DView.initialize(this.posing3DViewRender, webglWindow);
    if (this.drawGPURender.initializeWebGL(drawGPUWindow.canvas, false)) {
      console.log("\uFF13\uFF24\u63CF\u753B\u6A5F\u80FD\u3092\u521D\u671F\u5316\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002");
    }
    try {
      this.drawGPURender.initializeShader(this.polyLineShader);
      this.drawGPURender.initializeShader(this.bezierLineShader);
      this.drawGPURender.initializeShader(this.bezierDistanceLineShader);
    } catch (errorMessage) {
      console.log("\u30B7\u30A7\u30FC\u30C0\u306E\u521D\u671F\u5316\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002" + errorMessage);
    }
  }
  drawFullWindowImage(dstWindow, srcWindow) {
    this.fullScreen_canvasRender.setContext(dstWindow);
    this.fullScreen_canvasRender.resetTransform();
    this.fullScreen_canvasRender.drawImage(
      srcWindow.canvas,
      0,
      0,
      srcWindow.width,
      srcWindow.height,
      0,
      0,
      dstWindow.width,
      dstWindow.height
    );
  }
  clearWindow(canvasWindow) {
    this.fullScreen_canvasRender.setContext(canvasWindow);
    this.fullScreen_canvasRender.clear();
  }
  collectDrawPathsForDocument(docContext) {
    this.drawPathCollecting.collectDrawPaths(
      this.main_drawPathContext,
      docContext.documentData,
      docContext.currentViewKeyframe
    );
    this.lazy_drawPathContext.steps = this.main_drawPathContext.steps;
    if (docContext.documentData.animationSettingData.onionSkinMode != OnionSkinMode.disabled) {
      this.onionSiknDrawing.backward_DrawPathContexts = this.collectOnionSkinDrawPaths(docContext, false);
      this.onionSiknDrawing.forward_DrawPathContexts = this.collectOnionSkinDrawPaths(docContext, true);
    } else {
      this.onionSiknDrawing.backward_DrawPathContexts = [];
      this.onionSiknDrawing.forward_DrawPathContexts = [];
    }
  }
  collectOnionSkinDrawPaths(docContext, forward) {
    const currentIndex = docContext.keyframes.findIndex((keyframe) => keyframe == docContext.currentViewKeyframe);
    if (currentIndex === void 0) {
      throw new Error("ERROR 0000:Could not find current keyframe");
    }
    const indexStep = forward ? 1 : -1;
    const oniokSkinLevelRate = forward ? 1 : -1;
    const maxOnionSkinLevel = forward ? docContext.documentData.animationSettingData.onionSkinForwardLevel : docContext.documentData.animationSettingData.onionSkinBackwardLevel;
    const result = [];
    for (let index2 = currentIndex + indexStep; index2 >= 0 && index2 < docContext.keyframes.length; ) {
      const viewKeyframe = docContext.keyframes[index2];
      const drawPathContext = new DrawPathContext();
      drawPathContext.drawPathModeID = forward ? DrawPathModeID.onionSkinForward : DrawPathModeID.onionSkinBackward;
      drawPathContext.onionSkinLevel = (1 + result.length) * oniokSkinLevelRate;
      drawPathContext.maxOnionSkinLevel = maxOnionSkinLevel;
      this.drawPathCollecting.collectDrawPaths(
        drawPathContext,
        docContext.documentData,
        viewKeyframe,
        false
      );
      result.push(drawPathContext);
      if (result.length >= maxOnionSkinLevel) {
        break;
      }
      index2 += indexStep;
    }
    return result;
  }
  drawDrawPathContext(canvasWindow, drawPathContext, clearState = true, needsClearBackground = true, transformWindow = null) {
    const documentData = drawPathContext.documentData;
    const isFullRendering = drawPathContext.isFullRendering();
    const isExporting = drawPathContext.isExporting();
    const isLazyUpdate = drawPathContext.isLazyUpdate();
    const isEditMode = drawPathContext.isEditMode();
    if (isLazyUpdate) {
      drawPathContext.lazyUpdateState.startPartialProcess();
    }
    if (transformWindow == null) {
      transformWindow = this.appView.mainWindow;
    }
    let destination_canvasWindow = canvasWindow;
    if (clearState) {
      drawPathContext.clearDrawingStates();
      drawPathContext.bufferStack.push(canvasWindow);
      drawPathContext.render.setContext(canvasWindow);
    } else {
      destination_canvasWindow = drawPathContext.bufferStack.pop();
      drawPathContext.render.setContext(destination_canvasWindow);
    }
    if (this.drawPath_logging) {
      console.debug("  DrawPath start clearState", clearState);
    }
    for (let i = drawPathContext.startIndex; i <= drawPathContext.endIndex; i++) {
      const drawPathStep = drawPathContext.steps[i];
      drawPathContext.lastDrawPathIndex = i;
      const viewKeyFrameLayer = drawPathStep.viewKeyframeLayer;
      const layer = viewKeyFrameLayer ? viewKeyFrameLayer.layer : null;
      if (this.drawPath_logging) {
        console.debug("  DrawPath", i, drawPathStep._debugText, layer ? layer.name : "", "stack:", drawPathContext.bufferStack.length);
      }
      if (drawPathStep.operationType == DrawPathOperationTypeID.startDrawPaths) {
        if (needsClearBackground) {
          drawPathContext.render.clear();
        }
        drawPathContext.render.copyTransformFromWindow(transformWindow);
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.drawForeground || drawPathStep.operationType == DrawPathOperationTypeID.drawBackground) {
        if (isExporting && !layer.isRenderTarget) {
          continue;
        }
        if (!this.isLayerDrawTarget(layer, drawPathContext.currentLayerOnly)) {
          continue;
        }
        this.setCompositeOperation(drawPathContext, drawPathStep);
        let render;
        let needsDraw = false;
        if (drawPathStep.isCacheEnabled()) {
          if (drawPathStep.needsRedraw) {
            drawPathContext.local_render.setContext(drawPathStep.renderCache.canvasWindow);
            drawPathContext.local_render.clear();
            render = drawPathContext.local_render;
            needsDraw = true;
          }
        } else {
          drawPathContext.render.setContext(destination_canvasWindow);
          drawPathContext.render.copyTransformFromWindow(transformWindow);
          render = drawPathContext.render;
          needsDraw = true;
        }
        if (needsDraw) {
          if (drawPathStep.operationType == DrawPathOperationTypeID.drawForeground) {
            if (isFullRendering) {
              if (VectorLayer.isVectorLayer(layer)) {
                transformWindow.copyTransformTo(this.appView.drawGPUWindow);
                this.appView.drawGPUWindow.viewScale *= this.appView.drawGPUWindow.width / transformWindow.width;
                this.renderingVectorLayer.renderForeground_VectorLayer(
                  this.appView.drawGPUWindow,
                  viewKeyFrameLayer,
                  documentData,
                  isEditMode,
                  drawPathContext.isModalToolRunning
                );
              }
            } else {
              this.drawLayerForeground(
                render,
                drawPathStep,
                documentData,
                isExporting,
                drawPathContext.isModalToolRunning,
                isEditMode,
                drawPathContext.onionSkinLevel
              );
            }
          } else if (drawPathStep.operationType == DrawPathOperationTypeID.drawBackground) {
            this.drawLayerBackground(
              render,
              drawPathStep,
              documentData,
              isExporting,
              drawPathContext.isModalToolRunning,
              isEditMode
            );
          }
          drawPathStep.needsRedraw = false;
        }
        if (drawPathStep.isCacheEnabled()) {
          this.drawRenderCache(destination_canvasWindow, drawPathStep);
        }
        drawPathContext.render.setBlendMode(CanvasRenderBlendMode.default);
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.prepareRenderingForeground) {
        if (!isFullRendering) {
          continue;
        }
        this.renderingVectorLayer.renderClearBuffer(this.appView.drawGPUWindow);
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.flushRenderingForeground) {
        if (!isFullRendering) {
          continue;
        }
        drawPathContext.render.setContext(destination_canvasWindow);
        this.setCompositeOperation(drawPathContext, drawPathStep);
        this.drawFullWindowImage(destination_canvasWindow, this.appView.drawGPUWindow);
        drawPathContext.render.setBlendMode(CanvasRenderBlendMode.default);
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.prepareBuffer) {
        if (!this.isLayerDrawTarget(layer, drawPathContext.currentLayerOnly)) {
          continue;
        }
        drawPathContext.bufferStack.push(destination_canvasWindow);
        destination_canvasWindow = drawPathStep.buffer.canvasWindow;
        drawPathContext.render.setContext(destination_canvasWindow);
        drawPathContext.render.clear();
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.flushBuffer) {
        if (!this.isLayerDrawTarget(layer, drawPathContext.currentLayerOnly)) {
          continue;
        }
        const before_BufferCanvasWindow = drawPathContext.bufferStack.pop();
        drawPathContext.render.setContext(before_BufferCanvasWindow);
        this.setCompositeOperation(drawPathContext, drawPathStep);
        this.drawFullWindowImage(before_BufferCanvasWindow, destination_canvasWindow);
        destination_canvasWindow = before_BufferCanvasWindow;
      }
      if (isLazyUpdate && drawPathContext.lazyUpdateState.isOverPartialProcessMaxTime() || i == drawPathContext.endIndex) {
        drawPathContext.bufferStack.push(destination_canvasWindow);
        break;
      }
    }
  }
  drawDrawPathContexts(bufferCanvasWindow, drawPathContexts, needsClearBackground) {
    for (const drawPathContext of drawPathContexts) {
      drawPathContext.startIndex = 0;
      drawPathContext.endIndex = drawPathContext.steps.length - 1;
      this.drawDrawPathContext(bufferCanvasWindow, drawPathContext, true, needsClearBackground);
      needsClearBackground = false;
    }
  }
  drawRenderCache(destination_canvasWindow, drawPathStep) {
    this.fullScreen_canvasRender.setContext(destination_canvasWindow);
    this.fullScreen_canvasRender.drawImage(
      drawPathStep.renderCache.canvasWindow.canvas,
      0,
      0,
      drawPathStep.renderCache.width,
      drawPathStep.renderCache.height,
      drawPathStep.renderCache.location[0],
      drawPathStep.renderCache.location[1],
      drawPathStep.renderCache.width,
      drawPathStep.renderCache.height
    );
  }
  isLayerDrawTarget(layer, currentLayerOnly) {
    if (currentLayerOnly) {
      return this.isdrawTargetForCurrentLayerOnly(layer);
    } else {
      return Layer.isVisible(layer);
    }
  }
  isdrawTargetForCurrentLayerOnly(layer) {
    return Layer.isSelected(layer);
  }
  setCompositeOperation(drawPathContext, drawPathStep) {
    if (!drawPathContext.currentLayerOnly) {
      drawPathContext.render.setBlendMode(drawPathStep.compositeOperation);
    } else {
      drawPathContext.render.setBlendMode(CanvasRenderBlendMode.default);
    }
  }
  drawLayerForeground(render, drawPathStep, documentData, isExporting, isModalToolRunning, isEditMode, onionSkinLevel = 0, maxOnionSkinLevel = 1) {
    const layer = drawPathStep.viewKeyframeLayer.layer;
    if (VectorLayer.isVectorLayer(layer)) {
      const vectorLayer = layer;
      this.drawingVectorLayer.drawForeground(
        render,
        vectorLayer,
        drawPathStep.viewKeyframeLayer.vectorLayerKeyframe.geometry,
        drawPathStep.renderCache,
        documentData,
        isEditMode,
        isExporting,
        isModalToolRunning,
        onionSkinLevel,
        maxOnionSkinLevel
      );
      if (vectorLayer.eyesSymmetryEnabled && vectorLayer.runtime.eyesSymmetryGeometry != null) {
        this.drawingVectorLayer.drawForeground(
          render,
          vectorLayer,
          vectorLayer.runtime.eyesSymmetryGeometry,
          drawPathStep.renderCache,
          documentData,
          isEditMode,
          isExporting,
          isModalToolRunning,
          onionSkinLevel,
          maxOnionSkinLevel
        );
      }
    } else if (ImageFileReferenceLayer.isImageFileReferenceLayer(layer)) {
      const ifrLayer = layer;
      this.drawingIFRLayer.drawImageFileReferenceLayer(ifrLayer, isModalToolRunning);
    }
  }
  drawLayerBackground(render, drawPathStep, documentData, isExporting, isModalToolRunning, isEditMode) {
    const layer = drawPathStep.viewKeyframeLayer.layer;
    if (VectorLayer.isVectorLayer(layer)) {
      const vectorLayer = layer;
      const geometry = drawPathStep.viewKeyframeLayer.vectorLayerKeyframe.geometry;
      this.drawingVectorLayer.drawBackground(
        render,
        vectorLayer,
        geometry,
        documentData,
        Layer.isSelected(layer),
        isEditMode,
        isExporting,
        isModalToolRunning
      );
      if (isEditMode) {
        this.drawingVectorLayer.drawBackgroundExtra(
          render,
          vectorLayer,
          geometry,
          Layer.isSelected(layer),
          isEditMode,
          isModalToolRunning
        );
      }
    } else if (AutoFillLayer.isAutoFillLayer(layer)) {
      const autoFillLayer = layer;
      const geometry = drawPathStep.viewKeyframeLayer.autoFillLayerKeyframe.geometry;
      this.drawingVectorLayer.drawBackground(
        render,
        autoFillLayer,
        geometry,
        documentData,
        Layer.isSelected(layer),
        isEditMode,
        isExporting,
        isModalToolRunning
      );
    }
  }
  drawForegroundForEditMode(render, vectorLayer, viewKeyFrameLayer, documentData, operationUnitID, drawStrokes, drawPoints, isModalToolRunning, isEditMode) {
    const isSelectedLayer = Layer.isSelected(vectorLayer);
    this.drawingVectorLayer.drawForegroundForEditMode(
      render,
      vectorLayer,
      viewKeyFrameLayer.vectorLayerKeyframe.geometry,
      documentData,
      operationUnitID,
      isEditMode,
      isSelectedLayer,
      drawStrokes,
      drawPoints,
      isModalToolRunning
    );
    if (vectorLayer.eyesSymmetryEnabled && vectorLayer.runtime.eyesSymmetryGeometry != null) {
      this.drawingVectorLayer.drawForegroundForEditMode(
        render,
        vectorLayer,
        vectorLayer.runtime.eyesSymmetryGeometry,
        documentData,
        operationUnitID,
        isEditMode,
        false,
        drawStrokes,
        drawPoints,
        isModalToolRunning
      );
    }
  }
  drawMainWindow(result_canvasWindow, docContext, isDrawMode, isEditMode, isModalToolRunning, drawCPUOnly, redrawActiveLayerOnly, currentLayerOnly) {
    this.main_drawPathContext.render = this.canvasRender;
    this.main_drawPathContext.local_render = this.local_canvasRender;
    this.main_drawPathContext.isEditModeDraw = isEditMode;
    this.main_drawPathContext.isModalToolRunning = isModalToolRunning;
    this.main_drawPathContext.currentLayerOnly = currentLayerOnly;
    this.main_drawPathContext.redrawActiveLayerOnly = redrawActiveLayerOnly;
    this.main_drawPathContext.drawCPUOnly = drawCPUOnly;
    this.onionSiknDrawing.onionSkinMode = docContext.documentData.animationSettingData.onionSkinMode;
    this.main_drawPathContext.render.setContext(result_canvasWindow);
    this.main_drawPathContext.render.clear();
    if (isDrawMode) {
      this.drawDocumentForDrawMode(result_canvasWindow, this.main_drawPathContext, this.onionSiknDrawing);
    } else if (isEditMode) {
      this.drawDocumentForEditMode(result_canvasWindow, docContext, this.main_drawPathContext);
    }
    this.drawFrames(result_canvasWindow, docContext);
  }
  drawDocumentForDrawMode(result_canvasWindow, drawPathContext, onionSiknDrawing) {
    this.drawPathCollecting.updateActiveDrawPathIndex(drawPathContext);
    const redrawActiveLayerOnly = drawPathContext.redrawActiveLayerOnly;
    const activeRangeStartIndex = drawPathContext.activeDrawPathStartIndex;
    const activeRangeEndIndex = drawPathContext.activeDrawPathEndIndex;
    const maxStepIndex = drawPathContext.steps.length - 1;
    const needsDrawForBackLayer = redrawActiveLayerOnly && activeRangeStartIndex != -1;
    const needsDrawForForeLayer = redrawActiveLayerOnly && activeRangeEndIndex < maxStepIndex;
    const needsOnionSkinDrawForBackLayer = onionSiknDrawing.onionSkinMode == OnionSkinMode.showOnLowestLayer;
    const needsOnionSkinDrawForForeLayer = onionSiknDrawing.onionSkinMode == OnionSkinMode.showOnTopLayer;
    const needsRedrawAllLayer = !needsDrawForBackLayer && !needsDrawForForeLayer;
    drawPathContext.drawPathModeID = DrawPathModeID.editor;
    drawPathContext.render.setContext(result_canvasWindow);
    let needsClearBackground = true;
    if (needsDrawForBackLayer || needsOnionSkinDrawForBackLayer) {
      drawPathContext.startIndex = 0;
      drawPathContext.endIndex = activeRangeStartIndex - 1;
      this.drawViaBufferForDrawMode(
        result_canvasWindow,
        this.appView.backLayerRenderBuffer,
        drawPathContext,
        1,
        !drawPathContext.isNonActiveLayerBufferDrawingDone,
        needsDrawForBackLayer,
        needsOnionSkinDrawForBackLayer,
        onionSiknDrawing
      );
      needsClearBackground = false;
    }
    if (needsRedrawAllLayer) {
      drawPathContext.startIndex = 0;
      drawPathContext.endIndex = maxStepIndex;
    } else {
      drawPathContext.startIndex = activeRangeStartIndex;
      drawPathContext.endIndex = activeRangeEndIndex;
    }
    this.drawDrawPathContext(result_canvasWindow, drawPathContext, true, needsClearBackground);
    if (needsDrawForForeLayer || needsOnionSkinDrawForForeLayer) {
      drawPathContext.startIndex = activeRangeEndIndex + 1;
      drawPathContext.endIndex = maxStepIndex;
      this.drawViaBufferForDrawMode(
        result_canvasWindow,
        this.appView.foreLayerRenderBuffer,
        drawPathContext,
        0,
        !drawPathContext.isNonActiveLayerBufferDrawingDone,
        needsDrawForForeLayer,
        needsOnionSkinDrawForForeLayer,
        onionSiknDrawing
      );
    }
    drawPathContext.isNonActiveLayerBufferDrawingDone = !needsRedrawAllLayer;
  }
  drawViaBufferForDrawMode(result_canvasWindow, buffer_canvasWindow, drawPathContext, drawingLayerTarget, needsRedrawBuffer, needsDrawMainDrawPath, needsDrawOnionSkinDrawPath, onionSiknDrawing) {
    const isForeLayer = drawingLayerTarget == 0;
    if (needsRedrawBuffer || needsDrawOnionSkinDrawPath) {
      result_canvasWindow.copyTransformTo(buffer_canvasWindow);
      drawPathContext.render.setContext(buffer_canvasWindow);
      drawPathContext.render.clear();
      let needsClearBackground = true;
      if (needsDrawOnionSkinDrawPath && !isForeLayer && onionSiknDrawing.onionSkinMode == OnionSkinMode.showOnLowestLayer) {
        this.drawDrawPathContexts(buffer_canvasWindow, onionSiknDrawing.backward_DrawPathContexts, true);
        this.drawDrawPathContexts(buffer_canvasWindow, onionSiknDrawing.forward_DrawPathContexts, false);
        needsClearBackground = false;
      }
      if (needsDrawMainDrawPath) {
        this.drawDrawPathContext(buffer_canvasWindow, drawPathContext, true, needsClearBackground);
      }
      if (needsDrawOnionSkinDrawPath && isForeLayer && onionSiknDrawing.onionSkinMode == OnionSkinMode.showOnTopLayer) {
        this.drawDrawPathContexts(buffer_canvasWindow, onionSiknDrawing.backward_DrawPathContexts, false);
        this.drawDrawPathContexts(buffer_canvasWindow, onionSiknDrawing.forward_DrawPathContexts, false);
      }
    }
    this.drawFullWindowImage(result_canvasWindow, buffer_canvasWindow);
  }
  drawDocumentForEditMode(result_canvasWindow, docContext, drawPathContext) {
    this.drawPathCollecting.updateActiveDrawPathIndex(drawPathContext);
    const isModalToolRunning = drawPathContext.isModalToolRunning;
    const currentLayerOnly = drawPathContext.currentLayerOnly;
    const redrawActiveLayerOnly = drawPathContext.redrawActiveLayerOnly;
    const isEditMode = drawPathContext.isEditMode();
    const maxStepIndex = drawPathContext.steps.length - 1;
    drawPathContext.render.setContext(result_canvasWindow);
    if (redrawActiveLayerOnly && drawPathContext.activeDrawPathStartIndex != -1) {
      if (drawPathContext.activeDrawPathStartIndex > 0) {
        drawPathContext.startIndex = 0;
        drawPathContext.endIndex = drawPathContext.activeDrawPathStartIndex - 1;
        this.drawViaBufferForEditMode(
          result_canvasWindow,
          this.appView.backLayerRenderBuffer,
          docContext,
          drawPathContext,
          !drawPathContext.isNonActiveLayerBufferDrawingDone,
          currentLayerOnly,
          isModalToolRunning,
          isEditMode
        );
      }
      drawPathContext.startIndex = drawPathContext.activeDrawPathStartIndex;
      drawPathContext.endIndex = drawPathContext.activeDrawPathEndIndex;
      this.drawViaBufferForEditMode(
        result_canvasWindow,
        null,
        docContext,
        drawPathContext,
        true,
        currentLayerOnly,
        isModalToolRunning,
        isEditMode
      );
      if (drawPathContext.activeDrawPathEndIndex < maxStepIndex) {
        drawPathContext.startIndex = drawPathContext.activeDrawPathEndIndex + 1;
        drawPathContext.endIndex = maxStepIndex;
        this.drawViaBufferForEditMode(
          result_canvasWindow,
          this.appView.foreLayerRenderBuffer,
          docContext,
          drawPathContext,
          !drawPathContext.isNonActiveLayerBufferDrawingDone,
          currentLayerOnly,
          isModalToolRunning,
          isEditMode
        );
      }
      drawPathContext.isNonActiveLayerBufferDrawingDone = true;
    } else {
      drawPathContext.startIndex = 0;
      drawPathContext.endIndex = maxStepIndex;
      this.drawViaBufferForEditMode(
        result_canvasWindow,
        null,
        docContext,
        drawPathContext,
        true,
        currentLayerOnly,
        isModalToolRunning,
        isEditMode
      );
      drawPathContext.isNonActiveLayerBufferDrawingDone = false;
    }
  }
  drawViaBufferForEditMode(result_canvasWindow, buffer_canvasWindow, docContext, drawPathContext, needsRedrawBuffer, currentLayerOnly, isModalToolRunning, isEditMode) {
    const documentData = docContext.documentData;
    const drawStrokes = true;
    //!isFullRendering
    const drawPoints = true;
    if (needsRedrawBuffer) {
      if (buffer_canvasWindow != null) {
        result_canvasWindow.copyTransformTo(buffer_canvasWindow);
        drawPathContext.render.setContext(buffer_canvasWindow);
        drawPathContext.render.clear();
      } else {
        drawPathContext.render.setContext(result_canvasWindow);
      }
      for (let i = drawPathContext.startIndex; i <= drawPathContext.endIndex; i++) {
        const drawPathStep = drawPathContext.steps[i];
        if (drawPathStep.operationType != DrawPathOperationTypeID.drawForeground && drawPathStep.operationType != DrawPathOperationTypeID.drawBackground) {
          continue;
        }
        const viewKeyFrameLayer = drawPathStep.viewKeyframeLayer;
        const layer = viewKeyFrameLayer ? viewKeyFrameLayer.layer : null;
        if (currentLayerOnly) {
          if (!this.isdrawTargetForCurrentLayerOnly(layer)) {
            continue;
          }
        } else {
          if (!Layer.isVisible(layer)) {
            continue;
          }
        }
        if (VectorLayer.isVectorLayer(layer)) {
          const vectorLayer = layer;
          if (drawPathStep.operationType == DrawPathOperationTypeID.drawBackground) {
            this.drawLayerBackground(
              drawPathContext.render,
              drawPathStep,
              documentData,
              false,
              isModalToolRunning,
              isEditMode
            );
          }
          this.drawForegroundForEditMode(
            drawPathContext.render,
            vectorLayer,
            viewKeyFrameLayer,
            documentData,
            docContext.operationUnitID,
            drawStrokes,
            drawPoints,
            isModalToolRunning,
            isEditMode
          );
        } else if (AutoFillLayer.isAutoFillLayer(layer)) {
          this.drawLayerBackground(
            drawPathContext.render,
            drawPathStep,
            documentData,
            false,
            isModalToolRunning,
            isEditMode
          );
        } else {
          this.drawLayerForeground(
            drawPathContext.render,
            drawPathStep,
            documentData,
            false,
            drawPathContext.isModalToolRunning,
            isEditMode
          );
        }
      }
    }
    if (buffer_canvasWindow != null) {
      this.drawFullWindowImage(result_canvasWindow, buffer_canvasWindow);
    }
  }
  drawFrames(canvasWindow, docContext) {
    this.canvasRender.setContext(canvasWindow);
    this.drawDocumentFrame(this.canvasRender, docContext);
    this.drawRulers(this.canvasRender, docContext);
  }
  drawDocumentFrame(render, docContext) {
    if (!docContext.documentData.documentFrame_HideOuterArea) {
      return;
    }
    render.resetTransform();
    const mirrorX = this.appView.mainWindow.mirrorX;
    const mirrorY = this.appView.mainWindow.mirrorY;
    const mirrored = !mirrorX && !mirrorY || mirrorX && mirrorY;
    this.appView.canvasFrame.draw(this.canvasRender, docContext.documentData, mirrored);
  }
  drawRulers(render, docContext) {
    render.resetTransform();
    this.appView.canvasRulerH.draw(render, this.appView.mainWindow, docContext.documentData);
    this.appView.canvasRulerV.draw(render, this.appView.mainWindow, docContext.documentData);
    this.appView.canvasRulerH.drawCorner(render);
  }
  drawExportImage(canvasWindow, documentData, viewKeyframe, imageLeft, imageTop, imageWidth, imageHeight, scale, backGroundType) {
    const drawPathContext = new DrawPathContext();
    drawPathContext.drawPathModeID = DrawPathModeID.export;
    drawPathContext.render = this.canvasRender;
    drawPathContext.local_render = this.local_canvasRender;
    this.drawPathCollecting.collectDrawPaths(
      drawPathContext,
      documentData,
      viewKeyframe
    );
    drawPathContext.render.setContext(canvasWindow);
    drawPathContext.render.clear();
    if (backGroundType == DocumentBackGroundTypeID.lastPaletteColor) {
      drawPathContext.render.resetTransform();
      drawPathContext.render.setFillColorV(documentData.paletteColors[documentData.paletteColors.length - 1].color);
      drawPathContext.render.fillRect(0, 0, imageWidth, imageHeight);
    }
    canvasWindow.viewLocation[0] = imageLeft;
    canvasWindow.viewLocation[1] = imageTop;
    canvasWindow.viewScale = scale;
    canvasWindow.viewRotation = 0;
    canvasWindow.centerLocationRate[0] = 0;
    canvasWindow.centerLocationRate[1] = 0;
    drawPathContext.startIndex = 0;
    drawPathContext.endIndex = drawPathContext.steps.length - 1;
    this.drawPathBuffering.prepareDrawPathBuffers(
      drawPathContext,
      canvasWindow,
      true
    );
    this.drawPathBuffering.updateAllRenderCaches(
      drawPathContext,
      viewKeyframe
    );
    this.drawDrawPathContext(canvasWindow, drawPathContext, true, false, canvasWindow);
  }
  pickLayer(main_canvasWindow, documentData, pickLocationX, pickLocationY) {
    if (!this.pickLayer_canvasWindow.isSameMetrics(main_canvasWindow)) {
      this.pickLayer_canvasWindow.createCanvas(main_canvasWindow.width, main_canvasWindow.height, true);
    }
    main_canvasWindow.copyTransformTo(this.pickLayer_canvasWindow);
    this.canvasRender.setContext(this.pickLayer_canvasWindow);
    this.canvasRender.clear();
    let pickedLayer = null;
    for (let index2 = this.main_drawPathContext.steps.length - 1; index2 > 0; index2--) {
      const drawPathStep = this.main_drawPathContext.steps[index2];
      if (drawPathStep.operationType != DrawPathOperationTypeID.drawForeground && drawPathStep.operationType != DrawPathOperationTypeID.drawBackground) {
        continue;
      }
      if (!Layer.isVisible(drawPathStep.viewKeyframeLayer.layer)) {
        continue;
      }
      if (drawPathStep.isCacheEnabled()) {
        this.drawRenderCache(this.pickLayer_canvasWindow, drawPathStep);
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.drawBackground) {
        this.drawLayerBackground(
          this.canvasRender,
          drawPathStep,
          documentData,
          false,
          false,
          false
        );
      } else {
        this.drawLayerForeground(
          this.canvasRender,
          drawPathStep,
          documentData,
          false,
          false,
          false
        );
      }
      for (const location of this.layerPickingLocations) {
        this.canvasRender.pickColor(this.tempColor4, pickLocationX + location[0], pickLocationY + location[1]);
        if (this.tempColor4[3] > 0) {
          pickedLayer = drawPathStep.viewKeyframeLayer.layer;
          break;
        }
      }
      if (pickedLayer != null) {
        break;
      }
    }
    return pickedLayer;
  }
}
function UI_DialogScreenContainer({ children, className = "", isVisibleOnInit = true, overlayContainerRef = null, onEscape }) {
  const containerRef = react.exports.useRef(null);
  const [visible, set_visible] = react.exports.useState(isVisibleOnInit);
  react.exports.useEffect(() => {
    overlayContainerRef.show = (dialogRef) => {
      containerRef.current.parentElement.classList.remove("hidden");
      set_visible(true);
      dialogRef.onDialogScreenOpened();
      window.setTimeout(() => {
        containerRef.current.focus();
      }, 100);
    };
    overlayContainerRef.hide = (dialogRef) => {
      containerRef.current.parentElement.classList.add("hidden");
      set_visible(false);
      dialogRef.onDialogScreenClosed();
    };
    return function cleanup() {
    };
  }, []);
  function container_keyDown(e) {
    if (e.key == "Escape") {
      if (onEscape) {
        onEscape(e);
        e.stopPropagation();
      }
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: containerRef,
    className: `dialog-screen-container ${className} ${!visible ? "hidden" : ""}`,
    tabIndex: 0,
    onKeyDown: container_keyDown
  }, visible ? children : null);
}
var UI_Dialog_DocumentFiler_DialogType = /* @__PURE__ */ ((UI_Dialog_DocumentFiler_DialogType2) => {
  UI_Dialog_DocumentFiler_DialogType2[UI_Dialog_DocumentFiler_DialogType2["none"] = 0] = "none";
  UI_Dialog_DocumentFiler_DialogType2[UI_Dialog_DocumentFiler_DialogType2["open"] = 1] = "open";
  UI_Dialog_DocumentFiler_DialogType2[UI_Dialog_DocumentFiler_DialogType2["saveAS"] = 2] = "saveAS";
  return UI_Dialog_DocumentFiler_DialogType2;
})(UI_Dialog_DocumentFiler_DialogType || {});
function UI_Dialog_DocumentFiler({ uiRef }) {
  const [dialogType, set_dialogType] = react.exports.useState(0);
  const [currentFileSectionItem, set_currentFileSectionItem] = react.exports.useState(null);
  const [fileSectionItems, set_fileSectionItems] = react.exports.useState(() => {
    return [];
  });
  const [currentFileItem, set_currentFileItem] = react.exports.useState(null);
  const [fileItems, set_fileItems] = react.exports.useState(() => {
    return [];
  });
  const [fileName, set_fileName] = react.exports.useState("");
  const [directoryPath, set_directoryPath] = react.exports.useState("");
  const [directoryIcon, set_directoryIcon] = react.exports.useState("");
  const userSettingRef = react.exports.useRef(null);
  const overlayContainerRef = react.exports.useMemo(() => ({}), []);
  react.exports.useEffect(() => {
    uiRef.show = (type, lastFilePath, userSetting) => {
      userSettingRef.current = userSetting;
      let reselectSectionPath = "";
      if (type == 2 && !Strings.isNullOrEmpty(lastFilePath)) {
        const lastFileName = Platform.path.getFileName(lastFilePath);
        if (!Strings.isNullOrEmpty(lastFileName)) {
          set_fileName(lastFileName);
          reselectSectionPath = Platform.path.getDirectoryPath(lastFilePath);
        }
      }
      prepareItems(type, reselectSectionPath);
      set_dialogType(type);
      set_currentFileItem(null);
      overlayContainerRef.show(uiRef);
    };
    uiRef.close = () => {
      overlayContainerRef.hide(uiRef);
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.close = null;
    };
  }, []);
  function prepareItems(dlgType, reselectSectionPath) {
    const environments = userSettingRef.current.getOpenFileEnvironments();
    const fileSectionItems2 = [];
    let keyCount = 0;
    if (dlgType == 1) {
      fileSectionItems2.push({
        key: keyCount++,
        type: 2,
        name: "\u6700\u8FD1\u4F7F\u7528\u3057\u305F\u30D5\u30A1\u30A4\u30EB",
        path: "\u6700\u8FD1\u4F7F\u7528\u3057\u305F\u30D5\u30A1\u30A4\u30EB",
        icon: "history"
      });
    }
    if (dlgType == 2 && !Strings.isNullOrEmpty(reselectSectionPath)) {
      fileSectionItems2.push({
        key: keyCount++,
        type: 1,
        name: "\u73FE\u5728\u306E\u5834\u6240",
        path: Platform.path.getPlatformOrientedPath(reselectSectionPath),
        icon: "folder"
      });
    }
    environments.fileSections.forEach((section) => {
      fileSectionItems2.push({
        key: keyCount++,
        type: 0,
        name: section.name,
        path: section.path,
        icon: "folder",
        section
      });
    });
    if (Platform.supportsNative()) {
      fileSectionItems2.push({
        key: keyCount++,
        type: 3,
        name: "\u5834\u6240\u306E\u8FFD\u52A0",
        path: "\u5834\u6240\u306E\u8FFD\u52A0",
        icon: "add"
      });
    }
    set_fileSectionItems(fileSectionItems2);
    let select_FileSectionItem = fileSectionItems2[0];
    if (!Strings.isNullOrEmpty(reselectSectionPath)) {
      const sectionItem = fileSectionItems2.find((item) => (item.type == 0 || item.type == 1) && item.path == reselectSectionPath);
      if (sectionItem) {
        select_FileSectionItem = sectionItem;
      }
    }
    changeCurrentFileSection(select_FileSectionItem).then();
  }
  function setCurrentFileItem(fileItem) {
    set_currentFileItem(fileItem);
    set_fileName(fileItem ? fileItem.name : "");
  }
  async function changeCurrentFileSection(sectionItem) {
    switch (sectionItem.type) {
      case 0:
      case 1: {
        const files = await Platform.fileSystem.getFileInfos(sectionItem.path);
        const fileItems2 = [];
        let keyCount = 0;
        files.filter((file) => Strings.endsWith(file.path, ".ora") || Strings.endsWith(file.path, ".json")).forEach((file) => {
          fileItems2.push({
            key: keyCount++,
            name: file.name,
            icon: Strings.endsWith(file.name, ".ora") ? "media" : "image",
            path: file.path
          });
        });
        set_fileItems(fileItems2);
        break;
      }
      case 2: {
        const environments = userSettingRef.current.getOpenFileEnvironments();
        const fileItems2 = [];
        let keyCount = 0;
        environments.lastUsedFilePaths.forEach((lufPath) => {
          fileItems2.push({
            key: keyCount++,
            name: Platform.path.getFileName(lufPath),
            icon: Strings.endsWith(lufPath, ".ora") ? "media" : "image",
            path: lufPath
          });
        });
        set_fileItems(fileItems2);
        break;
      }
    }
    set_currentFileSectionItem(sectionItem);
    set_directoryPath(sectionItem.path);
    set_directoryIcon(sectionItem.icon);
  }
  async function selectDirectoryToAdd() {
    let defaultDirectoryPath = directoryPath;
    if (Strings.isNullOrEmpty(defaultDirectoryPath)) {
      defaultDirectoryPath = "c:\\";
    }
    const path = await Platform.fileSystem.openFileDialog(defaultDirectoryPath);
    if (!Strings.isNullOrEmpty(path)) {
      console.log(path);
      const newItem = {
        index: fileItems.length,
        name: Platform.path.getFileName(path),
        path
      };
      userSettingRef.current.addFileSection(newItem);
      prepareItems(dialogType, path);
    }
  }
  function sectionItem_Clicked(sectionItem) {
    switch (sectionItem.type) {
      case 0:
      case 1:
      case 2:
        changeCurrentFileSection(sectionItem).then();
        break;
      case 3:
        selectDirectoryToAdd().then();
        break;
    }
  }
  function sectionItem_Delete_Clicked(e, sectionItem) {
    e.stopPropagation();
    userSettingRef.current.removeFileSection(sectionItem.section);
    prepareItems(dialogType, null);
  }
  function fileName_Changed(e) {
    set_fileName(e.target.value);
  }
  function fileItem_Clicked(fileItem) {
    setCurrentFileItem(fileItem);
  }
  function ok_Clicked() {
    switch (dialogType) {
      case 1:
        if (uiRef.fileItem_Selected && currentFileItem != null) {
          uiRef.fileItem_Selected(currentFileItem.path);
        }
        break;
      case 2:
        if (uiRef.filePath_Fixed && !Strings.isNullOrEmpty(directoryPath) && !Strings.isNullOrEmpty(fileName)) {
          uiRef.filePath_Fixed(directoryPath, fileName);
        }
        break;
    }
    uiRef.close();
  }
  function dialog_Escaped() {
    uiRef.close();
  }
  const isFileNameReadOnly = dialogType != 2;
  return /* @__PURE__ */ react.exports.createElement(UI_DialogScreenContainer, {
    overlayContainerRef,
    className: "dialog-document-filer-container",
    isVisibleOnInit: false,
    onEscape: dialog_Escaped
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "sections-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "menu-commands"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: "app-button-back",
    onClick: dialog_Escaped
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandleft"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u30AD\u30E3\u30F3\u30BB\u30EB"))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-label"
  }, "\u30D5\u30A1\u30A4\u30EB\u306E\u5834\u6240"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-list"
  }, fileSectionItems.map((sectionItem) => /* @__PURE__ */ react.exports.createElement("div", {
    key: sectionItem.key,
    className: `section-item selectable-item ${sectionItem == currentFileSectionItem ? "selected" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item-inner selectable-item-inner",
    onMouseUp: () => {
      sectionItem_Clicked(sectionItem);
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "name"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: sectionItem.icon
  }), /* @__PURE__ */ react.exports.createElement("span", null, sectionItem.name)), sectionItem.type == 0 && /* @__PURE__ */ react.exports.createElement("div", {
    className: "button",
    onClick: (e) => {
      sectionItem_Delete_Clicked(e, sectionItem);
    }
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "close"
  }))))))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "files-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "file-commands"
  }, /* @__PURE__ */ react.exports.createElement("input", {
    type: "text",
    className: `file-info ${isFileNameReadOnly ? "readonly" : ""}`,
    readOnly: isFileNameReadOnly,
    value: fileName,
    onChange: fileName_Changed
  }), /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-primary${fileName == "" ? " disabled" : ""}`,
    onClick: () => ok_Clicked()
  }, dialogType == 1 ? "\u958B\u304F" : "\u4FDD\u5B58")), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-info"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: directoryIcon
  }), /* @__PURE__ */ react.exports.createElement("span", null, directoryPath)), /* @__PURE__ */ react.exports.createElement("div", {
    className: "file-list"
  }, /* @__PURE__ */ react.exports.createElement("ul", null, fileItems.map((fileItem) => /* @__PURE__ */ react.exports.createElement("li", {
    key: fileItem.key,
    className: `selectable-item ${fileItem == currentFileItem ? "selected" : ""}`,
    onPointerDown: () => fileItem_Clicked(fileItem)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "selectable-item-inner"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: fileItem.icon
  }), /* @__PURE__ */ react.exports.createElement("span", {
    className: "name"
  }, fileItem.name), /* @__PURE__ */ react.exports.createElement("span", {
    className: "path"
  }, fileItem.path))))))));
}
function UI_Dialog_ShortcutKeys({ uiRef }) {
  const [keyOptions, set_keyOptions] = react.exports.useState([]);
  const [selected_keyOptions, set_selected_keyOptions] = react.exports.useState([]);
  const [modifierOptions, set_modifierOptions] = react.exports.useState([]);
  const [selected_modifierOptions, set_selected_modifierOptions] = react.exports.useState([]);
  const [commandOptions, set_commandOptions] = react.exports.useState([]);
  const [selected_commandOptions, set_selected_commandOptions] = react.exports.useState([]);
  const [shortcutKeysItems, set_shortcutKeysItems] = react.exports.useState([]);
  const [selectedItem, set_selectedItem] = react.exports.useState(null);
  const overlayContainerRef = react.exports.useMemo(() => ({}), []);
  const userSettingRef = react.exports.useRef(null);
  const shortcutKeyRef = react.exports.useRef(null);
  react.exports.useEffect(() => {
    uiRef.show = (userSetting, shortcutKey) => {
      userSettingRef.current = userSetting;
      shortcutKeyRef.current = shortcutKey;
      const new_keyOptions = shortcutKey.shortcutKeys.map((key) => ({ index: key.shortcutKeyID, label: key.keyName, data: key.shortcutKeyID }));
      const new_modifierOptions = shortcutKey.modifierKeys.map((key) => ({ index: key.modifierKeyID, label: key.keyName, data: key.modifierKeyID }));
      const new_commandOptions = shortcutKey.shortcutCommands.map((com) => ({ index: com.commandID, label: `${com.category.categoryName} - ${com.commandName}`, data: com.commandID }));
      set_keyOptions(new_keyOptions);
      set_modifierOptions(new_modifierOptions);
      set_commandOptions(new_commandOptions);
      set_shortcutKeysItems(getShortcutKeyItems(shortcutKey.shortcutKeySettings, new_keyOptions, new_modifierOptions, new_commandOptions));
      set_selected_keyOptions([]);
      set_selected_modifierOptions([new_modifierOptions[0]]);
      set_selected_commandOptions([]);
      set_selectedItem(null);
      overlayContainerRef.show(uiRef);
    };
    uiRef.close = () => {
      set_keyOptions([]);
      set_modifierOptions([]);
      set_commandOptions([]);
      set_shortcutKeysItems([]);
      overlayContainerRef.hide(uiRef);
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.close = null;
    };
  }, []);
  function dialog_Escaped() {
    userSettingRef.current.saveSettings();
    uiRef.close();
  }
  function key_Changed(option) {
    set_selected_keyOptions([option]);
  }
  function modifier_Changed(option) {
    set_selected_modifierOptions([option]);
  }
  function command_Changed(option) {
    set_selected_commandOptions([option]);
  }
  function item_Clicked(item) {
    {
      const option = keyOptions.find((option2) => option2.data == item.setting.shortcutKeyID);
      if (option) {
        set_selected_keyOptions([option]);
      }
    }
    {
      const option = modifierOptions.find((option2) => option2.data == item.setting.modifierKeyID);
      if (option) {
        set_selected_modifierOptions([option]);
      }
    }
    {
      const option = commandOptions.find((option2) => option2.data == item.setting.commandID);
      if (option) {
        set_selected_commandOptions([option]);
      }
    }
    set_selectedItem(item);
  }
  function fixItem_Clicked() {
    if (selected_keyOptions.length == 0 || selected_modifierOptions.length == 0 || selected_commandOptions.length == 0) {
      return;
    }
    const key_option = selected_keyOptions[0];
    const modifier_option = selected_modifierOptions[0];
    const command_option = selected_commandOptions[0];
    const isNew = selectedItem == null;
    let new_item;
    const same_item = shortcutKeysItems.find(
      (item) => (isNew || item != selectedItem) && (item.keyOption == key_option && item.modifierOption == modifier_option && item.commandOption == command_option)
    );
    if (same_item) {
      return;
    }
    if (!isNew) {
      new_item = selectedItem;
    } else {
      const new_setting = {
        id: 0,
        shortcutKeyID: 0,
        modifierKeyID: 0,
        commandID: 0
      };
      shortcutKeyRef.current.addShortcutKeySetting(new_setting);
      new_item = {
        index: 0,
        keyOption: null,
        modifierOption: null,
        commandOption: null,
        setting: new_setting
      };
      shortcutKeysItems.push(new_item);
    }
    new_item.keyOption = key_option, new_item.modifierOption = modifier_option;
    new_item.commandOption = command_option;
    new_item.setting.shortcutKeyID = new_item.keyOption.data;
    new_item.setting.modifierKeyID = new_item.modifierOption.data;
    new_item.setting.commandID = new_item.commandOption.data;
    set_shortcutKeysItems(getShortcutKeyItems(
      shortcutKeyRef.current.shortcutKeySettings,
      keyOptions,
      modifierOptions,
      commandOptions
    ));
    if (isNew) {
      cancelItem_Clicked();
    }
  }
  function addItem_Clicked() {
    if (selectedItem != null) {
      return;
    }
    fixItem_Clicked();
  }
  function deleteItem_Clicked() {
    if (selectedItem == null) {
      return;
    }
    set_shortcutKeysItems(shortcutKeysItems.filter((item) => item != selectedItem));
    shortcutKeyRef.current.removeShortcutKeySetting(selectedItem.setting);
    cancelItem_Clicked();
  }
  function cancelItem_Clicked() {
    set_selected_keyOptions([]);
    set_selected_modifierOptions([modifierOptions[0]]);
    set_selected_commandOptions([]);
    set_selectedItem(null);
  }
  function getShortcutKeyItems(shortcutKeySettings, keyOptions2, modifierOptions2, commandOptions2) {
    const items = shortcutKeySettings.map((setting) => {
      const keyOption = keyOptions2.find((opt) => opt.data == setting.shortcutKeyID);
      const modifierOption = modifierOptions2.find((opt) => opt.data == setting.modifierKeyID);
      const commandOption = commandOptions2.find((opt) => opt.data == setting.commandID);
      return {
        index: setting.id,
        keyOption,
        modifierOption,
        commandOption,
        setting
      };
    });
    let index2 = 0;
    items.forEach((item) => item.index = index2++);
    items.sort((a, b) => {
      if (a.commandOption.index != b.commandOption.index) {
        return a.commandOption.index - b.commandOption.index;
      } else if (a.keyOption.index != b.keyOption.index) {
        return a.keyOption.index - b.keyOption.index;
      } else {
        return a.modifierOption.index - b.modifierOption.index;
      }
    });
    return items;
  }
  return /* @__PURE__ */ react.exports.createElement(UI_DialogScreenContainer, {
    overlayContainerRef,
    className: "dialog-shortcut-keys-container",
    isVisibleOnInit: false,
    onEscape: dialog_Escaped
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "header"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: "app-button-back",
    onPointerDown: dialog_Escaped
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "expandleft"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u5B8C\u4E86"))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "form"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "select"
  }, /* @__PURE__ */ react.exports.createElement(UI_SelectBox, {
    title: "\u30B3\u30DE\u30F3\u30C9",
    placeholder: "\u30B3\u30DE\u30F3\u30C9",
    selectBoxPopoverRef: uiRef.selectBoxPopoverRef,
    options: commandOptions,
    values: selected_commandOptions,
    large: true,
    onChange: (item) => command_Changed(item)
  }), /* @__PURE__ */ react.exports.createElement(UI_SelectBox, {
    title: "\u30AD\u30FC",
    placeholder: "\u30AD\u30FC",
    selectBoxPopoverRef: uiRef.selectBoxPopoverRef,
    options: keyOptions,
    values: selected_keyOptions,
    large: true,
    onChange: (item) => key_Changed(item)
  }), /* @__PURE__ */ react.exports.createElement(UI_SelectBox, {
    title: "\u4FEE\u98FE\u30AD\u30FC",
    placeholder: "\u4FEE\u98FE\u30AD\u30FC",
    selectBoxPopoverRef: uiRef.selectBoxPopoverRef,
    options: modifierOptions,
    values: selected_modifierOptions,
    large: true,
    onChange: (item) => modifier_Changed(item)
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "commands"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-cancel${selectedItem == null ? " disabled" : ""}`,
    onPointerDown: fixItem_Clicked
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "check"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u66F4\u65B0")), /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-cancel${selectedItem != null ? " disabled" : ""}`,
    onPointerDown: addItem_Clicked
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "add"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u8FFD\u52A0")), /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-cancel${selectedItem == null ? " disabled" : ""}`,
    onPointerDown: deleteItem_Clicked
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "remove"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u524A\u9664")), /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-cancel`,
    onPointerDown: cancelItem_Clicked
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: "reset_form"
  }), /* @__PURE__ */ react.exports.createElement("span", null, "\u30AF\u30EA\u30A2")))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "list"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "header-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-inner"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column command-text"
  }, "\u30B3\u30DE\u30F3\u30C9"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column key-text"
  }, "\u30AD\u30FC"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column modifier-text"
  }, "\u4FEE\u98FE\u30AD\u30FC"))), shortcutKeysItems.map((item) => /* @__PURE__ */ react.exports.createElement("div", {
    key: item.index,
    className: `shortcutkey-item selectable-item${item == selectedItem ? " selected" : ""}`,
    onPointerDown: () => item_Clicked(item)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "selectable-item-inner"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column command-text"
  }, item.commandOption.label), /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column key-text"
  }, item.keyOption.label), /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-column modifier-text"
  }, item.modifierOption.label))))));
}
class AppKeyboardEvent {
  constructor() {
    this.e = null;
    this.key = "";
    this.shiftKey = false;
    this.ctrlKey = false;
    this.altKey = false;
  }
  attach(e) {
    this.e = e;
    this.key = e.key;
    this.shiftKey = e.shiftKey;
    this.ctrlKey = e.ctrlKey;
    this.altKey = e.altKey;
    return this;
  }
  set(e) {
    this.key = e.key;
    this.shiftKey = e.shiftKey === true;
    this.ctrlKey = e.ctrlKey === true;
    this.altKey = e.altKey === true;
    return this;
  }
  preventDefault() {
    if (this.e != null) {
      this.e.preventDefault();
    }
  }
}
class App_Event {
  constructor() {
    this.isEventSetDone = false;
    this.appView = null;
    this.appDrawing = null;
    this.appDocument = null;
    this.appUserSetting = null;
    this.appTool = null;
    this.appMain = null;
    this.documentContext = null;
    this.subtoolContext = null;
    this.lastHoverLayoutArea = null;
    this.tempVec3 = vec3.create();
    this.tempColor4 = vec4.create();
  }
  link(view, drawing, appDocument, apptool, appPreferences, main) {
    this.appView = view;
    this.appDrawing = drawing;
    this.appDocument = appDocument;
    this.appTool = apptool;
    this.appMain = main;
    this.appUserSetting = appPreferences;
  }
  linkContexts(docContext, toolContext) {
    this.documentContext = docContext;
    this.subtoolContext = toolContext;
  }
  setEvents() {
    this.isEventSetDone = true;
    this.setCanvasWindowMouseEvent(
      this.appView.editorWindow,
      this.appView.mainWindow,
      this.mainWindow_mousedown,
      this.mainWindow_mousemove,
      this.mainWindow_mouseup,
      this.mainWindow_mousewheel,
      false
    );
    this.setCanvasWindowMouseEvent(
      this.appView.timeLineWindow.canvasWindow,
      this.appView.timeLineWindow.canvasWindow,
      this.timeLineWindow_mousedown,
      this.timeLineWindow_mousemove,
      null,
      this.timeLineWindow_mousewheel,
      false
    );
    document.addEventListener("keydown", (e) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      if (document.activeElement.nodeName == "INPUT") {
        return;
      }
      this.document_keydown(new AppKeyboardEvent().attach(e));
    });
    document.addEventListener("keyup", (e) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      if (document.activeElement.nodeName == "INPUT") {
        return;
      }
      this.document_keyup(new AppKeyboardEvent().attach(e));
    });
    window.addEventListener("resize", () => {
      this.htmlWindow_resize();
    });
    window.addEventListener("contextmenu", (e) => {
      return this.htmlWindow_contextmenu(e);
    });
    window.addEventListener("blur", () => {
      PointerInputLogic.cancelAllPointers(this.appView.editorWindow.pointerEvent);
      this.appMain.onWindowBlur();
    });
    window.addEventListener("focus", () => {
      this.appMain.onWindowFocus();
    });
    document.addEventListener("dragover", (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (this.appMain.isEventDisabled()) {
        return;
      }
      let available = false;
      if (e.dataTransfer.types.length > 0) {
        for (const type of e.dataTransfer.types) {
          if (type == "Files") {
            available = true;
            break;
          }
        }
      }
      if (available) {
        e.dataTransfer.dropEffect = "move";
      } else {
        e.dataTransfer.dropEffect = "none";
      }
    });
    document.addEventListener("drop", (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.document_drop(e);
    });
    this.appView.headerWindow.uiHeaderWindowRef.commandButton_Click = (id2) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.menuButton_Click(id2);
    };
    this.appView.footerWindow.uiFooterOperationpanelRef.button_Click = (id2) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.menuButton_Click(id2);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.ribbonUITabsRef.item_Clicked = (tabID) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_TabClick(tabID);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.button_Clicked = (id2) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_button_Click(id2);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.subtoolButton_Clicked = (subtoolID) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.subtoolButton_Click(subtoolID);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.mainMenuButtonRef.commandButton_Clicked = (id2) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.menuButton_Click(id2);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.toggleButton_Clicked = (id2, value) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_toggleButton_Click(id2, value);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.textInput_Changed = (id2, value) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_textInput_Change(id2, value);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.numberInput_Changed = (id2, value, isModal = false) => {
      if (this.appMain.isEventDisabled() && !isModal) {
        return;
      }
      this.ribbonUI_NumberInput_Changed(id2, value);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.checkBox_Changed = (id2, checked, value) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_checkBox_Change(id2, checked, value);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.selectBox_Changed = (id2, selected_Option) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.ribbonUI_selectBox_Change(id2, selected_Option);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.documentFrame_Changed = (left, top, width, height) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.documentFrame_Change(left, top, width, height);
    };
    this.appView.ribbonUIWindow.uiRibbonUIRef.documentViewSettings_Changed = (new_defaultViewScale) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.documentViewSettings_change(new_defaultViewScale);
    };
    this.appView.subToolWindow.uiSubToolWindowRef.item_Click = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.subtoolWindow_Item_Click(item);
    };
    this.appView.subToolWindow.uiSubToolWindowRef.itemButton_Click = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.subtoolWindow_Button_Click(item);
    };
    const updateSideBarUIStateVisible = (cotentInfo) => {
      const setting = this.appView.sideBarContentStateSettings.find((st) => st.contentID == cotentInfo.id);
      this.appMain.setUIStateVisible(setting.uiStateName, cotentInfo.isOpened);
    };
    this.appView.right_SideBarContainerRef.onContentOpened = (cotentInfo) => {
      if (cotentInfo.id == SideBarContentID.colorMixerWindow) {
        this.documentContext.redrawColorMixerSample = true;
      }
      updateSideBarUIStateVisible(cotentInfo);
    };
    this.appView.right_SideBarContainerRef.onContentClosed = (cotentInfo) => {
      updateSideBarUIStateVisible(cotentInfo);
    };
    this.layerWindow_SetEvents();
    this.appView.paletteSelectorWindow.uiRef.commandButton_Click = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.paletteSelectorWindow_CommandButton_Click(item);
    };
    this.appView.paletteSelectorWindow.uiRef.item_Click = (paletteColorIndex, item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.paletteSelectorWindow_Item_Click(paletteColorIndex, item);
    };
    this.setCanvasWindowMouseEvent(
      this.appView.colorMixerWindow.colorCanvas,
      this.appView.colorMixerWindow.colorCanvas,
      this.colorMixerWindow_colorCanvas_mousedown,
      this.colorMixerWindow_colorCanvas_mousedown,
      null,
      null,
      false
    );
    this.appView.colorMixerWindow.uiRef.color_Change = (newColor) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.colorMixerWindow_changeColor(newColor);
    };
    this.appView.timeLineWindow.uiTimeLineWindowRef.numberInput_Changed = (id2, value) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.numberInput_Changed(id2, value);
    };
    this.appView.timeLineWindow.uiTimeLineWindowRef.commandButton_Clicked = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.menuButton_Click(item.index);
    };
    this.appView.modalWindow.uiImageFileReferenceRef.onClose = (filePath, image) => {
      this.modal_ImageFileReference_Closed(filePath, image);
    };
    this.appView.modalWindow.uiExportImageRef.onClose = (param) => {
      this.modal_ExportImage_Closed(param);
    };
    this.appView.dialogScreen.uiDocumentFilerRef.fileItem_Selected = (filePath) => {
      this.dialog_DocumentFiler_fileItemSelected(filePath);
    };
    this.appView.dialogScreen.uiDocumentFilerRef.filePath_Fixed = (directoryPath, fileName) => {
      this.dialog_DocumentFiler_filePathFixed(directoryPath, fileName);
    };
    document.addEventListener("custombox:content:open", () => {
      this.appView.dialogScreen.onDialogWindowShown();
    });
    document.addEventListener("custombox:content:close", () => {
      this.onModalWindowClosed();
    });
    this.setEvents_ModalCloseButton(this.appView.dom.ID.messageDialogModal_ok);
    this.setEvents_ModalCloseButton(this.appView.dom.ID.openFileDialogModal_ok);
    this.setEvents_ModalCloseButton(this.appView.dom.ID.openFileDialogModal_cancel);
  }
  setCanvasWindowMouseEvent(eventCanvasWindow, drawCanvasWindew, pointerDown, pointerMove, pointerUp, wheel, isModal) {
    const eventElement = eventCanvasWindow.canvas;
    if (pointerDown != null) {
      eventElement.addEventListener("pointerdown", (e) => {
        if (this.appMain.isEventDisabled() && !isModal) {
          return;
        }
        if (!PointerInputLogic.hasActivePointer(e.pointerId, drawCanvasWindew.pointerEvent)) {
          eventElement.setPointerCapture(e.pointerId);
        }
        if (this.appView.activeCanvasWindow != drawCanvasWindew) {
          this.appView.activeCanvasWindow = drawCanvasWindew;
        }
        PointerInputLogic.processSinglePointerEvent(
          drawCanvasWindew,
          e,
          this.documentContext,
          true,
          false
        );
        PointerInputLogic.processMultiPointerEvent(
          drawCanvasWindew,
          e,
          true,
          false
        );
        pointerDown.call(this);
        e.preventDefault();
      });
    }
    if (pointerMove != null) {
      eventElement.addEventListener("pointermove", (e) => {
        if (this.appMain.isEventDisabled() && !isModal) {
          return;
        }
        const isMoved = PointerInputLogic.isPointerMovedOnDevice(drawCanvasWindew.pointerEvent, e);
        if (isMoved) {
          PointerInputLogic.processSinglePointerEvent(
            drawCanvasWindew,
            e,
            this.documentContext,
            false,
            false
          );
          PointerInputLogic.processMultiPointerEvent(
            drawCanvasWindew,
            e,
            false,
            false
          );
          pointerMove.call(this);
        }
        e.preventDefault();
      });
    }
    if (pointerUp != null) {
      const callback = (e) => {
        if (this.appMain.isEventDisabled() && !isModal) {
          return;
        }
        if (PointerInputLogic.hasActivePointer(e.pointerId, drawCanvasWindew.pointerEvent)) {
          PointerInputLogic.processSinglePointerEvent(
            drawCanvasWindew,
            e,
            this.documentContext,
            false,
            true
          );
          PointerInputLogic.processMultiPointerEvent(
            drawCanvasWindew,
            e,
            false,
            true
          );
          pointerUp.call(this);
        }
        e.preventDefault();
      };
      eventElement.addEventListener("pointerup", (e) => {
        callback(e);
      });
      eventElement.addEventListener("pointerleave", (e) => {
        callback(e);
        PointerInputLogic.processMultiPointerLeaveEvent(
          drawCanvasWindew,
          e
        );
      });
    }
    eventElement.addEventListener("pointerenter", (e) => {
      if (this.appView.activeCanvasWindow != drawCanvasWindew) {
        this.appView.activeCanvasWindow = drawCanvasWindew;
      }
    });
    if (wheel != null) {
      eventCanvasWindow.canvas.addEventListener("wheel", (e) => {
        if (this.appMain.isEventDisabled() && !isModal) {
          return;
        }
        PointerInputLogic.getWheelInfo(drawCanvasWindew.pointerEvent, e);
        wheel.call(this);
        e.preventDefault();
      });
    }
    eventElement.addEventListener("touchstart", (e) => {
      e.preventDefault();
    });
    eventElement.addEventListener("touchmove", (e) => {
      e.preventDefault();
    });
    eventElement.addEventListener("touchend", (e) => {
      e.preventDefault();
    });
  }
  setEvents_ModalCloseButton(id2) {
    this.appView.dom.getElement(id2).addEventListener("click", (e) => {
      this.appView.dialogScreen.currentModalDialogResult = id2;
      this.appView.dialogScreen.closeDialogWindow();
      e.preventDefault();
    });
  }
  updateHierarchicalStatesRecursive() {
    LayerLogic.updateHierarchicalStatesRecursive(this.documentContext.documentData.rootLayer);
  }
  document_keydown(e) {
    const docContext = this.documentContext;
    const subtoolContext = this.subtoolContext;
    const wnd = this.appView.mainWindow;
    const isModalToolRunning = this.appTool.isModalToolRunning();
    e.preventDefault();
    docContext.shiftKey = e.shiftKey;
    docContext.ctrlKey = e.ctrlKey;
    docContext.altKey = e.altKey;
    subtoolContext.updateContext();
    const commandID = this.appUserSetting.shortcutKey.getCommandIDFromKeyInput(e.key, e.shiftKey, e.ctrlKey, e.altKey);
    if (!isModalToolRunning) {
      if (this.appTool.executeMainToolKeyDown(e.key, commandID)) {
        return;
      }
    }
    if (isModalToolRunning && e.key == "Escape") {
      this.appTool.cancelModalTool();
      return;
    }
    if (this.appMain.executeSubToolKeyDown(e.key, ShortcutCommandID.none)) {
      return;
    }
    if (isModalToolRunning) {
      return;
    }
    if (this.appView.viewOperation.isViewOperationRunning()) {
      e.preventDefault();
      return;
    }
    if (commandID == ShortcutCommandID.view_pan && !this.appView.viewOperation.isViewOperationRunning() && this.appView.activeCanvasWindow == this.appView.mainWindow) {
      this.appView.viewOperation.startViewOperation(ViewOperationMode.pan, wnd, null, subtoolContext);
      return;
    }
    if (commandID == ShortcutCommandID.edit_setPibot && subtoolContext.needsDrawOperatorCursor()) {
      this.appMain.setOperatorCursorLocationToMouse();
    }
    if (subtoolContext.isEditMode()) {
      if (this.appMain.executeSubToolKeyDown(e.key, commandID)) {
        return;
      }
    }
    if (commandID == ShortcutCommandID.tool_toggleMainEdit) {
      if (subtoolContext.isDrawMode()) {
        this.appTool.changeCurrentMainToolForEditMode(EditModeID.editMode);
      } else {
        this.appTool.changeCurrentMainToolForEditMode(EditModeID.drawMode);
      }
      subtoolContext.setRedrawWindowsForCurrentToolChanging();
      return;
    }
    if (commandID == ShortcutCommandID.edit_undo) {
      this.inputKey_undo_down();
      return;
    }
    if (commandID == ShortcutCommandID.document_new) {
      this.menuButton_Click(MainCommandButtonID.newFile);
      return;
    }
    if (commandID == ShortcutCommandID.edit_redo) {
      this.inputKey_redo_down();
      return;
    }
    if (commandID == ShortcutCommandID.edit_copy) {
      this.inputKey_copy_down();
      return;
    }
    if (commandID == ShortcutCommandID.edit_paste) {
      this.inputKey_paste_down();
      return;
    }
    if (commandID == ShortcutCommandID.timeline_previousKeyframe || commandID == ShortcutCommandID.timeline_nextKeyframe) {
      let addFrame = 1;
      if (commandID == ShortcutCommandID.timeline_previousKeyframe) {
        addFrame = -addFrame;
      }
      const frame = this.appView.viewKeyframe.findNextViewKeyframeFrame(this.documentContext, docContext.documentData.animationSettingData.currentTimeFrame, addFrame);
      this.appMain.setCurrentFrame(frame);
    }
    if (commandID == ShortcutCommandID.edit_cut || commandID == ShortcutCommandID.edit_delete) {
      const withCut = commandID == ShortcutCommandID.edit_cut;
      this.inputKey_delete_down(withCut);
      return;
    }
    if (commandID == ShortcutCommandID.view_reset || commandID == ShortcutCommandID.view_toggleHome) {
      const reset = commandID == ShortcutCommandID.view_reset;
      this.appView.viewOperation.toggletHome(this.appView.mainWindow, reset, subtoolContext);
      return;
    }
    if (commandID == ShortcutCommandID.view_rotateCW || commandID == ShortcutCommandID.view_rotateCCW) {
      const clockwise = commandID == ShortcutCommandID.view_rotateCW;
      this.appView.viewOperation.addViewRotation(10, clockwise, wnd, subtoolContext);
      return;
    }
    if (commandID == ShortcutCommandID.view_mirrorX) {
      this.appView.mainWindow.mirrorX = !this.appView.mainWindow.mirrorX;
      subtoolContext.setRedrawMainWindowEditorWindow();
      return;
    }
    if (commandID == ShortcutCommandID.view_zoomIn || commandID == ShortcutCommandID.view_zoomOut) {
      let addScale = 1 + this.appDrawing.drawStyle.viewZoomAdjustingSpeedRate;
      if (commandID == ShortcutCommandID.view_zoomOut) {
        addScale = 1 / addScale;
      }
      this.appView.viewOperation.addViewScale(addScale, wnd, subtoolContext);
      return;
    }
    if (subtoolContext.isCtrlKeyPressing() && (e.key == "ArrowLeft" || e.key == "ArrowRight" || e.key == "ArrowUp" || e.key == "ArrowDown")) {
      let x2 = 0;
      let y2 = 0;
      if (e.key == "ArrowLeft") {
        x2 = -10;
      } else if (e.key == "ArrowRight") {
        x2 = 10;
      } else if (e.key == "ArrowUp") {
        y2 = -10;
      } else if (e.key == "ArrowDown") {
        y2 = 10;
      }
      this.appView.mainWindow.calculateViewUnitMatrix(wnd.view2DMatrix);
      mat4.invert(wnd.invView2DMatrix, wnd.view2DMatrix);
      vec3.set(this.tempVec3, x2, y2, 0);
      vec3.transformMat4(this.tempVec3, this.tempVec3, wnd.invView2DMatrix);
      vec3.add(this.appView.mainWindow.viewLocation, this.appView.mainWindow.viewLocation, this.tempVec3);
      const leftLimit = this.appView.mainWindow.width * -0.5;
      const rightLimit = this.appView.mainWindow.width * 1.5;
      const topLimit = this.appView.mainWindow.height * -0.5;
      const bottomLimit = this.appView.mainWindow.height * 1.5;
      if (this.appView.mainWindow.viewLocation[0] < leftLimit) {
        this.appView.mainWindow.viewLocation[0] = leftLimit;
      }
      if (this.appView.mainWindow.viewLocation[0] > rightLimit) {
        this.appView.mainWindow.viewLocation[0] = rightLimit;
      }
      if (this.appView.mainWindow.viewLocation[1] < topLimit) {
        this.appView.mainWindow.viewLocation[1] = topLimit;
      }
      if (this.appView.mainWindow.viewLocation[1] > bottomLimit) {
        this.appView.mainWindow.viewLocation[1] = bottomLimit;
      }
      subtoolContext.setRedrawMainWindowEditorWindow();
      return;
    }
    if (!subtoolContext.isCtrlKeyPressing() && (e.key == "ArrowLeft" || e.key == "ArrowRight")) {
      let addFrame = 1;
      if (e.key == "ArrowLeft") {
        addFrame = -addFrame;
      }
      this.appMain.setCurrentFrame(docContext.documentData.animationSettingData.currentTimeFrame + addFrame);
    }
    if (commandID == ShortcutCommandID.layer_previousLayer || commandID == ShortcutCommandID.layer_nextLayer) {
      const moveDown = commandID == ShortcutCommandID.layer_nextLayer;
      this.appTool.selectNextOrPreviousLayer(moveDown);
      this.appView.layerHighlight.startShowingCurrentLayer(this.documentContext, this.subtoolContext);
      this.appView.layerWindow.scrollToLayer(this.documentContext.currentLayer, this.documentContext);
      subtoolContext.setRedrawWindowsForCurrentLayerChanging();
      return;
    }
    if (commandID == ShortcutCommandID.document_save) {
      this.appMain.saveDocument();
      return;
    }
    if (commandID == ShortcutCommandID.layer_pickLayer) {
      const pickX = this.appView.mainWindow.pointerEvent.offsetX;
      const pickY = this.appView.mainWindow.pointerEvent.offsetY;
      const pickedLayer = this.appDrawing.pickLayer(this.appView.mainWindow, docContext.documentData, pickX, pickY);
      if (pickedLayer != null) {
        this.appTool.selectLayer(pickedLayer);
        this.appView.layerHighlight.startShowingCurrentLayer(this.documentContext, this.subtoolContext);
        this.appView.layerWindow.scrollToLayer(pickedLayer, this.documentContext);
      } else {
        subtoolContext.setRedrawMainWindowEditorWindow();
      }
      return;
    }
    if (commandID == ShortcutCommandID.edit_fix) {
      this.appMain.executeSubToolKeyDown(e.key, commandID);
    }
    if (e.key == "-") {
      docContext.drawCPUOnly = !this.documentContext.drawCPUOnly;
      subtoolContext.setRedrawMainWindow();
    }
  }
  document_keyup(e) {
    this.documentContext.shiftKey = e.shiftKey;
    this.documentContext.altKey = e.altKey;
    this.documentContext.ctrlKey = e.ctrlKey;
    const commandID = this.appUserSetting.shortcutKey.getCommandIDFromKeyInput(e.key, e.shiftKey, e.ctrlKey, e.altKey);
    if (commandID == ShortcutCommandID.view_pan) {
      if (this.appView.viewOperation.isViewOperationRunning()) {
        this.appView.viewOperation.endViewOperation(this.appView.mainWindow, true, this.subtoolContext);
      }
    }
  }
  inputKey_undo_down() {
    this.appMain.executeUndo();
  }
  inputKey_redo_down() {
    this.appMain.executeRedo();
  }
  inputKey_copy_down() {
    if (!this.subtoolContext.isEditMode()) {
      return;
    }
    if (this.documentContext.activeVectorGroup != null) {
      const command = new Command_CopyGeometry();
      if (command.prepareEditData(this.subtoolContext)) {
        command.execute(this.subtoolContext);
      }
    }
  }
  inputKey_paste_down() {
    const command = new Command_PasteGeometry();
    command.prepareEditData(this.subtoolContext).then((isAvailable) => {
      if (!isAvailable) {
        return;
      }
      this.appTool.tool_SelectAllPoints.executeClearSelectAll(this.subtoolContext);
      this.documentContext.commandHistory.executeCommand(command, this.subtoolContext);
      this.appMain.executePostUpdate();
      this.subtoolContext.setRedrawCurrentLayer();
      if (this.subtoolContext.isEditMode()) {
        this.appTool.executeMainToolKeyDown("", ShortcutCommandID.tool_subTool3);
      }
    });
  }
  inputKey_delete_down(withCut) {
    if (!this.subtoolContext.isEditMode()) {
      return;
    }
    if (this.subtoolContext.isCurrentLayerStrokeDrawableLayer() || this.subtoolContext.isCurrentLayerGroupLayer()) {
      const command = new Command_VectorLayer_DeleteSelected();
      if (command.prepare(this.subtoolContext)) {
        if (withCut) {
          const copyCommand = new Command_CopyGeometry();
          if (copyCommand.prepareEditData(this.subtoolContext)) {
            copyCommand.execute(this.subtoolContext);
          }
        }
        this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
        this.appMain.executePostUpdate();
        this.subtoolContext.setRedrawMainWindow();
      }
    }
  }
  inputKey_draw_down() {
    if (!this.subtoolContext.isDrawMode()) {
      return;
    }
    this.appTool.changeCurrentSubToolForSubtoolID(SubToolID.drawLine);
    this.appTool.updateFooterMessage();
  }
  inputKey_eraser_down() {
    if (!this.subtoolContext.isDrawMode()) {
      return;
    }
    if (this.documentContext.subtoolID != SubToolID.deletePointBrush) {
      this.appTool.changeCurrentSubToolForSubtoolID(SubToolID.deletePointBrush);
    } else {
      this.appTool.changeCurrentSubToolForSubtoolID(SubToolID.drawLine);
    }
    this.appTool.updateFooterMessage();
  }
  inputKey_scratchLine_down() {
    this.document_keydown(new AppKeyboardEvent().set({ key: "3" }));
  }
  document_drop(e) {
    if (e.dataTransfer.files.length == 0) {
      console.error(new Error("ERROR-0000:no dropped files"));
      return;
    }
    const file = e.dataTransfer.files[0];
    let filePath = "";
    if ("path" in file) {
      filePath = file["path"];
    } else {
      filePath = file.name;
    }
    if (Strings.isNullOrEmpty(filePath)) {
      console.error(new Error("ERROR-0000:cannot get file path"));
      return;
    }
    this.appMain.startReloadDocumentFromFile(
      file,
      Platform.path.getPlatformIndependentPath(filePath)
    );
  }
  htmlWindow_resize() {
    this.appMain.setDefferedWindowResize();
  }
  htmlWindow_contextmenu(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else if (e.returnValue) {
      e.returnValue = false;
    }
    return false;
  }
  mainWindow_mousedown() {
    const wnd = this.appView.mainWindow;
    const toolPointerEvent = this.appView.tooPointerEvent.attach(wnd);
    this.subtoolContext.updateContext();
    if (!this.appTool.isModalToolRunning() && !this.appView.viewOperation.isViewOperationRunning()) {
      this.mainWindow_mousedown_OperationUI(toolPointerEvent);
    }
    if (this.appView.viewOperation.isViewOperationRunning()) {
      this.appView.viewOperation.pointerDownAdditional(wnd);
      return;
    }
    if (this.operationUI_IsHoverWhenNoModalTool(toolPointerEvent)) {
      return;
    }
    if (this.appTool.isModalToolRunning()) {
      if (this.appTool.isCurrentSubToolAvailable()) {
        this.appMain.executeSubToolMouseDown(toolPointerEvent);
      }
    } else {
      if (this.appTool.isCurrentSubToolAvailable()) {
        this.appMain.executeSubToolMouseDown(toolPointerEvent);
      }
    }
    if (toolPointerEvent.isRightButtonPressing && this.subtoolContext.isShiftKeyPressing()) {
      this.appMain.setOperatorCursorLocationToMouse();
    } else if (toolPointerEvent.isRightButtonPressing || toolPointerEvent.isCenterButtonPressing) {
      this.appView.viewOperation.startViewOperation(ViewOperationMode.pan, wnd, null, this.subtoolContext);
    } else if (this.appView.viewOperation.isViewOperationRunning()) {
      this.appView.viewOperation.endViewOperation(wnd, false, this.subtoolContext);
    }
  }
  mainWindow_mousemove() {
    const wnd = this.appView.mainWindow;
    const toolPointerEvent = this.appView.tooPointerEvent.attach(wnd);
    this.subtoolContext.updateContext();
    if (this.appView.viewOperation.isViewOperationRunning()) {
      this.appView.viewOperation.processViewOperation(wnd, toolPointerEvent, this.subtoolContext);
      return;
    }
    if (!this.appTool.isModalToolRunning()) {
      if (this.mainWindow_mousemove_OperationUI(toolPointerEvent)) {
        this.subtoolContext.setRedrawEditorWindow();
      }
    }
    if (this.operationUI_IsHoverWhenNoModalTool(toolPointerEvent)) {
      return;
    }
    if (this.appTool.isModalToolRunning()) {
      if (this.appTool.isCurrentSubToolAvailable()) {
        this.appMain.executeSubToolMouseMove(toolPointerEvent);
      }
    } else if (this.subtoolContext.isDrawMode()) {
      this.appMain.executeSubToolMouseMove(toolPointerEvent);
    } else if (this.subtoolContext.isEditMode()) {
      this.appMain.executeSubToolMouseMove(toolPointerEvent);
    }
  }
  mainWindow_mouseup() {
    const wnd = this.appView.mainWindow;
    const toolPointerEvent = this.appView.tooPointerEvent.attach(wnd);
    this.subtoolContext.updateContext();
    if (this.appView.viewOperation.isViewOperationRunning()) {
      this.appView.viewOperation.endViewOperation(wnd, false, this.subtoolContext);
      return;
    }
    if (this.operationUI_IsHoverWhenNoModalTool(toolPointerEvent)) {
      return;
    }
    this.appMain.executeSubToolMouseUp(toolPointerEvent);
  }
  mainWindow_mousewheel() {
    const wnd = this.appView.mainWindow;
    const toolPointerEvent = wnd.pointerEvent;
    if (toolPointerEvent.wheelDelta != 0) {
      let addScale = 1 + this.appDrawing.drawStyle.viewZoomAdjustingSpeedRate * 0.5;
      if (toolPointerEvent.wheelDelta < 0) {
        addScale = 1 / addScale;
      }
      this.appView.viewOperation.addViewScale(addScale, wnd, this.subtoolContext);
    }
    ViewCoordinateLogic.calculateTransfomredMouseParams(this.subtoolContext.mouseCursorLocation, toolPointerEvent, wnd);
  }
  mainWindow_mousedown_OperationUI(e) {
    const area = this.appView.operationPanel.hittestToButtons(e);
    if (area != null) {
      this.operationUI_Click(area, this.appView.mainWindow);
      return true;
    }
    if (this.operationUI_IsHover(e)) {
      return true;
    }
    return false;
  }
  operationUI_IsHover(e) {
    return this.appView.operationPanel.hittestToPanel(e) != null;
  }
  operationUI_IsHoverWhenNoModalTool(e) {
    return !this.appTool.isModalToolRunning() && this.appView.operationPanel.hittestToPanel(e) != null;
  }
  mainWindow_mousemove_OperationUI(e) {
    if (this.operationUI_IsHover(e)) {
      this.appView.editorWindow.canvas.style.cursor = "default";
    } else {
      this.appView.editorWindow.canvas.style.cursor = "crosshair";
    }
    const area = this.appView.operationPanel.hittestToButtons(e);
    if (this.lastHoverLayoutArea != null) {
      this.lastHoverLayoutArea.saveState();
    }
    if (area != null) {
      area.saveState();
    }
    if (this.lastHoverLayoutArea != null) {
      this.lastHoverLayoutArea.hover = false;
    }
    if (area != null) {
      area.hover = true;
      this.lastHoverLayoutArea = area;
    }
    const isChanged = LayoutLogic.isChanged(area) || LayoutLogic.isChanged(this.lastHoverLayoutArea);
    return isChanged;
  }
  menuButton_Click(id2) {
    switch (id2) {
      case MainCommandButtonID.openFile:
        this.appView.dialogScreen.openDocumentFilerDialog(
          UI_Dialog_DocumentFiler_DialogType.open,
          "",
          this.appUserSetting.settingFile
        );
        break;
      case MainCommandButtonID.newFile:
        this.appMain.resetDocument();
        break;
      case MainCommandButtonID.saveFile:
        this.appMain.saveDocument();
        break;
      case MainCommandButtonID.saveAs:
        this.appView.dialogScreen.openDocumentFilerDialog(
          UI_Dialog_DocumentFiler_DialogType.saveAS,
          this.documentContext.documentFilePath,
          this.appUserSetting.settingFile
        );
        break;
      case MainCommandButtonID.export:
        this.appView.modalWindow.openExportImageModal(
          this.documentContext,
          this.appMain.getLocalSetting()
        );
        break;
      case MainCommandButtonID.shortcutKeys:
        this.appView.dialogScreen.openShortcutKeysDialog(
          this.appUserSetting.settingFile,
          this.appUserSetting.shortcutKey
        );
        break;
      case MainCommandButtonID.copy:
        this.inputKey_copy_down();
        break;
      case MainCommandButtonID.paste:
        this.inputKey_paste_down();
        break;
      case MainCommandButtonID.cut:
        this.inputKey_delete_down(true);
        break;
      case MainCommandButtonID.undo:
        this.inputKey_undo_down();
        break;
      case MainCommandButtonID.redo:
        this.inputKey_redo_down();
        break;
      case MainCommandButtonID.touchOperationPanel:
        this.appView.operationPanel.toggleVisibility();
        this.appMain.setUIStateVisible(UIStateNames.touchOperationPanel, this.appView.operationPanel.isVisible());
        this.subtoolContext.setRedrawEditorWindow();
        break;
      case MainCommandButtonID.layerWindow:
        this.appView.right_SideBarContainerRef.toggleVisibility(SideBarContentID.layerWindow);
        break;
      case MainCommandButtonID.paletteWindow:
        this.appView.right_SideBarContainerRef.toggleVisibility(SideBarContentID.paletteWindow);
        break;
      case MainCommandButtonID.colorMixerWindow:
        this.appView.right_SideBarContainerRef.toggleVisibility(SideBarContentID.colorMixerWindow);
        break;
      case MainCommandButtonID.timeLineWindow:
        this.appView.timeLineWindow.toggleVisibility();
        this.appMain.setUIStateVisible(UIStateNames.timeLineWindow, this.appView.timeLineWindow.isVisible());
        this.subtoolContext.setRedrawTimeLineWindow();
        break;
      case MainCommandButtonID.timeLine_inertKeyframe:
        this.appView.modalWindow.showRadioSelectionModal(
          "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u306E\u633F\u5165",
          [
            { index: NewKeyframeTypeID.insertToCurrentFrameAllLayer, label: "\u30B3\u30D4\u30FC\u3092\u633F\u5165\uFF08\u5168\u30EC\u30A4\u30E4\u30FC\uFF09" },
            { index: NewKeyframeTypeID.insertToCurrentFrameActiveLayer, label: "\u30B3\u30D4\u30FC\u3092\u633F\u5165\uFF08\u30A2\u30AF\u30C6\u30A3\u30D6\u306A\u30EC\u30A4\u30E4\u30FC\uFF09" },
            { index: NewKeyframeTypeID.insertEmptyToAllLayer, label: "\u7A7A\u306E\u30AD\u30FC\u3092\u633F\u5165\uFF08\u5168\u30EC\u30A4\u30E4\u30FC\uFF09" },
            { index: NewKeyframeTypeID.insertEmptyToActiveLayer, label: "\u7A7A\u306E\u30AD\u30FC\u3092\u633F\u5165\uFF08\u30A2\u30AF\u30C6\u30A3\u30D6\u306A\u30EC\u30A4\u30E4\u30FC\uFF09" }
          ],
          NewKeyframeTypeID.insertToCurrentFrameAllLayer,
          (option) => {
            this.appDocument.executeNewKeyframe(option.index);
          }
        );
        break;
      case MainCommandButtonID.timeLine_deleteKeyframe:
        this.appView.modalWindow.showRadioSelectionModal(
          "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u306E\u524A\u9664",
          [
            { index: DeleteKeyframeTypeID.deleteCurrentFrameAllLayer, label: "\u30AD\u30FC\u3092\u524A\u9664\uFF08\u5168\u30EC\u30A4\u30E4\u30FC\uFF09" },
            { index: DeleteKeyframeTypeID.deleteCurrentFrameActiveLayer, label: "\u30AD\u30FC\u3092\u524A\u9664\uFF08\u30A2\u30AF\u30C6\u30A3\u30D6\u306A\u30EC\u30A4\u30E4\u30FC\uFF09" }
          ],
          NewKeyframeTypeID.insertToCurrentFrameAllLayer,
          (option) => {
            this.appDocument.executeDeleteKeyframe(option.index);
          }
        );
        break;
      case MainCommandButtonID.timeLine_moveKeyframe_minus:
      case MainCommandButtonID.timeLine_moveKeyframe_plus:
        this.appDocument.moveKeyframe(id2 == MainCommandButtonID.timeLine_moveKeyframe_plus);
        break;
      case MainCommandButtonID.timeLine_changeMaxFrame_minus:
      case MainCommandButtonID.timeLine_changeMaxFrame_plus:
        this.appDocument.changeAnimationMaxFrame(id2 == MainCommandButtonID.timeLine_changeMaxFrame_plus);
        break;
      case MainCommandButtonID.timeLine_changeLoopStartFrame_minus:
      case MainCommandButtonID.timeLine_changeLoopStartFrame_plus:
        this.appDocument.changeLoopStartFrame(id2 == MainCommandButtonID.timeLine_changeLoopStartFrame_plus);
        break;
      case MainCommandButtonID.timeLine_changeLoopEndFrame_minus:
      case MainCommandButtonID.timeLine_changeLoopEndFrame_plus:
        this.appDocument.changeLoopEndFrame(id2 == MainCommandButtonID.timeLine_changeLoopEndFrame_plus);
        break;
      case MainCommandButtonID.timeLine_changeOnionSkinBackwardLevel_minus:
      case MainCommandButtonID.timeLine_changeOnionSkinBackwardLevel_plus:
        this.appDocument.changeOnionSkinBackwardLevel(id2 == MainCommandButtonID.timeLine_changeOnionSkinBackwardLevel_plus);
        break;
      case MainCommandButtonID.timeLine_changeOnionSkinForwardLevel_minus:
      case MainCommandButtonID.timeLine_changeOnionSkinForwardLevel_plus:
        this.appDocument.changeOnionSkinForwardLevel(id2 == MainCommandButtonID.timeLine_changeOnionSkinForwardLevel_plus);
        break;
    }
  }
  numberInput_Changed(id2, value) {
    switch (id2) {
      case NumberInputControlID.onionSkinMode:
        this.appDocument.changeOnionSkinMode(value);
        break;
    }
  }
  operationUI_Click(area, wnd) {
    switch (area.index) {
      case OperationPanelButtonID.view_move:
        this.appView.viewOperation.startViewOperation(ViewOperationMode.pan, wnd, area, this.subtoolContext);
        break;
      case OperationPanelButtonID.view_rotate:
        this.appView.viewOperation.startViewOperation(ViewOperationMode.rotate, wnd, area, this.subtoolContext);
        break;
      case OperationPanelButtonID.view_zoom:
        this.appView.viewOperation.startViewOperation(ViewOperationMode.zoom, wnd, area, this.subtoolContext);
        break;
      case OperationPanelButtonID.draw:
        this.inputKey_draw_down();
        break;
      case OperationPanelButtonID.eraser:
        this.inputKey_eraser_down();
        break;
      case OperationPanelButtonID.scratchLine:
        this.inputKey_scratchLine_down();
        break;
    }
  }
  onNewLayerDiaglogClosed(newLayerType) {
    let layerCommand = null;
    switch (newLayerType) {
      case NewLayerTypeID.vectorLayer: {
        const command = new Command_Layer_AddVectorLayerToCurrentPosition();
        command.newLayer_layerType = LayerTypeID.vectorLayer;
        layerCommand = command;
        break;
      }
      case NewLayerTypeID.surroundingFill: {
        const command = new Command_Layer_AddVectorLayerToCurrentPosition();
        command.newLayer_layerType = LayerTypeID.surroundingFillLayer;
        layerCommand = command;
        break;
      }
      case NewLayerTypeID.pointBrushFill: {
        const command = new Command_Layer_AddVectorLayerToCurrentPosition();
        command.newLayer_layerType = LayerTypeID.pointBrushFillLayer;
        layerCommand = command;
        break;
      }
      case NewLayerTypeID.autoFill:
        layerCommand = new Command_Layer_AddAutoFillLayerToCurrentPosition();
        break;
      case NewLayerTypeID.vectorLayerReferenceLayer:
        layerCommand = new Command_Layer_AddVectorLayerReferenceLayerToCurrentPosition();
        break;
      case NewLayerTypeID.groupLayer:
        layerCommand = new Command_Layer_AddGroupLayerToCurrentPosition();
        break;
      case NewLayerTypeID.posingLayer:
        layerCommand = new Command_Layer_AddPosingLayerToCurrentPosition();
        break;
      case NewLayerTypeID.imageFileReferenceLayer:
        layerCommand = new Command_Layer_AddImageFileReferenceLayerToCurrentPosition();
        break;
    }
    if (layerCommand == null) {
      return;
    }
    this.appMain.executeLayerCommand(layerCommand);
  }
  layerWindow_SetEvents() {
    this.appView.layerWindow.uiRef.commandButton_Clicked = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.layerWindow_CommandButton_Clicked(item);
    };
    this.appView.layerWindow.uiRef.item_Clicked = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      const selectedLayer = item.layer;
      if (this.subtoolContext.isShiftKeyPressing()) {
        this.appTool.selectLayer(selectedLayer, true, false);
        this.appTool.activateCurrentTool();
        this.appView.layerHighlight.startShowingLayerItem(item, this.subtoolContext);
      } else {
        this.appTool.selectLayer(selectedLayer);
        this.appView.layerHighlight.startShowingCurrentLayer(this.documentContext, this.subtoolContext);
      }
    };
    this.appView.layerWindow.uiRef.visibility_Clicked = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      this.appTool.setLayerVisiblity(item.layer, !item.layer.isVisible);
      this.updateHierarchicalStatesRecursive();
      this.appTool.activateCurrentTool();
      this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
      this.subtoolContext.setRedrawLayerWindow();
    };
    this.appView.layerWindow.uiRef.expander_Clicked = (item) => {
      if (this.appMain.isEventDisabled()) {
        return;
      }
      item.layer.isListExpanded = !item.layer.isListExpanded;
      this.updateHierarchicalStatesRecursive();
      this.subtoolContext.updateLayerStructure();
    };
  }
  layerWindow_CommandButton_Clicked(hitedButton) {
    if (hitedButton == null) {
      return;
    }
    let layerCommand = null;
    switch (hitedButton.index) {
      case MainCommandButtonID.layer_addLayer:
        this.appView.modalWindow.showRadioSelectionModal(
          "\u65B0\u898F\u30EC\u30A4\u30E4\u30FC\u4F5C\u6210",
          [
            { index: NewLayerTypeID.vectorLayer, label: "\u7DDA\u753B" },
            { index: NewLayerTypeID.pointBrushFill, label: "\u30D6\u30E9\u30B7\u5857\u308A" },
            { index: NewLayerTypeID.surroundingFill, label: "\u56F2\u307F\u5857\u308A" },
            { index: NewLayerTypeID.autoFill, label: "\u81EA\u52D5\u56F2\u307F\u5857\u308A" },
            { index: NewLayerTypeID.groupLayer, label: "\u30B0\u30EB\u30FC\u30D7" },
            { index: NewLayerTypeID.imageFileReferenceLayer, label: "\u753B\u50CF\u30D5\u30A1\u30A4\u30EB" },
            { index: NewLayerTypeID.posingLayer, label: "\uFF13\uFF24\u30DD\u30FC\u30BA" }
          ],
          NewLayerTypeID.vectorLayer,
          (option) => {
            this.onNewLayerDiaglogClosed(option.index);
          }
        );
        break;
      case MainCommandButtonID.layer_deleteLayer:
        layerCommand = new Command_Layer_Delete();
        break;
      case MainCommandButtonID.layer_moveUp:
        layerCommand = new Command_Layer_MoveUp();
        break;
      case MainCommandButtonID.layer_moveDown:
        layerCommand = new Command_Layer_MoveDown();
        break;
    }
    if (layerCommand == null) {
      return;
    }
    this.appMain.executeLayerCommand(layerCommand);
  }
  ribbonUI_TabClick(tabID) {
    this.appTool.changeCurrentMainToolTab(tabID);
  }
  subtoolWindow_Item_Click(item) {
    this.subtoolButton_Click(item.subToolID);
  }
  subtoolWindow_Button_Click(item) {
    const tool = item.tool;
    if (!tool.isAvailable(this.subtoolContext)) {
      return;
    }
    const buttonIndex = 0;
    if (tool.optionButton_Click(buttonIndex, this.subtoolContext)) {
      item.buttonStateID = tool.getOptionButtonState(buttonIndex, this.subtoolContext);
      this.subtoolContext.setRedrawMainWindowEditorWindow();
      this.subtoolContext.setRedrawRibbonUI();
    }
  }
  subtoolButton_Click(subToolID) {
    this.appTool.changeCurrentSubToolForSubtoolID(subToolID);
  }
  ribbonUI_button_Click(id2) {
    this.appTool.executeMainToolButtonClick(id2);
  }
  ribbonUI_toggleButton_Click(id2, value) {
    switch (id2) {
      case RibbonUIControlID.edit_operationUnit:
        this.appTool.setOperationUnit(value);
        this.appTool.activateCurrentTool();
        this.subtoolContext.setRedrawCurrentLayer();
        this.subtoolContext.setRedrawEditorWindow();
        break;
      case RibbonUIControlID.edit_operationOrigin:
        this.appTool.setOperationOriginType(value);
        this.appTool.activateCurrentTool();
        this.subtoolContext.setRedrawCurrentLayer();
        this.subtoolContext.setRedrawEditorWindow();
        break;
      case RibbonUIControlID.vectorLayer_drawLineType:
        if (this.documentContext.currentVectorLayer) {
          this.documentContext.currentVectorLayer.drawLineType = value;
          const color = this.documentContext.getCurrentLayerLineColor();
          vec4.copy(this.documentContext.currentVectorLayer.layerColor, color);
          this.appMain.updateForLayerProperty();
          this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
        }
        break;
      case RibbonUIControlID.vectorLayer_fillAreaType:
        if (this.documentContext.currentVectorLayer) {
          this.documentContext.currentVectorLayer.fillAreaType = value;
          const color = this.documentContext.getCurrentLayerFillColor();
          vec4.copy(this.documentContext.currentVectorLayer.fillColor, color);
          this.appMain.updateForLayerProperty();
          this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
        }
        break;
      case RibbonUIControlID.vectorLayer_eyesSymmetryInputSide:
        if (this.subtoolContext.currentVectorLayer) {
          this.subtoolContext.currentVectorLayer.eyesSymmetryInputSide = value;
          const command = new Command_VectorLayer_SetProperty();
          command.layer = this.subtoolContext.currentVectorLayer;
          command.new_eyesSymmetryInputSide = value;
          if (command.isAvailable(this.subtoolContext)) {
            this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
          }
        }
        break;
    }
  }
  ribbonUI_textInput_Change(id2, value) {
    if (typeof value != "string") {
      return;
    }
    switch (id2) {
      case RibbonUIControlID.layer_name:
        this.documentContext.currentLayer.name = value;
        this.subtoolContext.setRedrawLayerWindow();
        break;
    }
  }
  ribbonUI_NumberInput_Changed(id2, value) {
    if (!Number.isFinite(value)) {
      return;
    }
    switch (id2) {
      case RibbonUIControlID.brushBaseSize:
        if (this.documentContext.currentBrushParameter) {
          this.documentContext.currentBrushParameter.baseSize = value;
        }
        this.appView.ribbonUIWindow.updateMainToolRibbonUI(this.documentContext);
        break;
      case RibbonUIControlID.brushMinSize:
        if (this.documentContext.currentBrushParameter) {
          this.documentContext.currentBrushParameter.minSize = value;
        }
        this.appView.ribbonUIWindow.updateMainToolRibbonUI(this.documentContext);
        break;
      case RibbonUIControlID.pointerBaseSize:
        if (this.documentContext.currentPointerParameter) {
          this.documentContext.currentPointerParameter.baseSize = value;
        }
        this.appView.ribbonUIWindow.updateMainToolRibbonUI(this.documentContext);
        break;
      case RibbonUIControlID.document_lineWidthBiasRate:
        this.documentContext.documentData.lineWidthBiasRate = value;
        this.subtoolContext.setRedrawMainWindowEditorWindow();
        break;
      case RibbonUIControlID.vectorLayer_lineWidthBiasRate:
        if (this.documentContext.currentVectorLayer) {
          this.documentContext.currentVectorLayer.lineWidthBiasRate = value;
          this.subtoolContext.setRedrawMainWindow();
        }
        break;
    }
  }
  ribbonUI_checkBox_Change(id2, checked, _value) {
    switch (id2) {
      case RibbonUIControlID.document_hideOuterArea:
        this.subtoolContext.documentData.documentFrame_HideOuterArea = checked;
        this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
        break;
      case RibbonUIControlID.layer_isRenderTarget:
        if (this.subtoolContext.currentLayer) {
          this.subtoolContext.currentLayer.isRenderTarget = checked;
          this.appMain.updateForLayerProperty();
          this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
        }
        break;
      case RibbonUIControlID.layer_isMaskedByBelowLayer:
        if (this.subtoolContext.currentLayer) {
          this.subtoolContext.currentLayer.isMaskedByBelowLayer = checked;
          this.appMain.updateForLayerProperty();
          this.subtoolContext.setRedrawWindowsForLayerPropertyChanging();
        }
        break;
      case RibbonUIControlID.vectorLayer_enableEyesSymmetry:
        if (this.subtoolContext.currentVectorLayer) {
          const command = new Command_VectorLayer_SetProperty();
          command.layer = this.subtoolContext.currentVectorLayer;
          command.new_enableEyesSymmetry = checked;
          if (command.isAvailable(this.subtoolContext)) {
            this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
          }
        }
        break;
    }
  }
  ribbonUI_selectBox_Change(id2, selected_Option) {
    switch (id2) {
      case RibbonUIControlID.vectorLayer_posingLayer:
        if (this.subtoolContext.currentVectorLayer && selected_Option) {
          const command = new Command_VectorLayer_SetProperty();
          command.layer = this.subtoolContext.currentVectorLayer;
          command.new_posingLayer = selected_Option.data;
          if (command.isAvailable(this.subtoolContext)) {
            this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
          }
        }
        break;
    }
  }
  documentFrame_Change(left, top, width, height) {
    this.documentContext.documentData.documentFrame[0] = left;
    this.documentContext.documentData.documentFrame[1] = top;
    this.documentContext.documentData.documentFrame[2] = left + width - 1;
    this.documentContext.documentData.documentFrame[3] = top + height - 1;
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.appTool.activateCurrentTool();
  }
  documentViewSettings_change(defaultViewScale) {
    this.documentContext.documentData.defaultViewScale = defaultViewScale;
    this.subtoolContext.setRedrawMainWindowEditorWindow();
  }
  paletteSelectorWindow_CommandButton_Click(item) {
    this.appView.paletteSelectorWindow.setCurrentTarget(item.index);
    this.subtoolContext.setRedrawPalleteSelectorWindow();
    this.subtoolContext.setRedrawColorMixerWindow();
  }
  paletteSelectorWindow_Item_Click(paletteColorIndex, color) {
    const wnd = this.appView.paletteSelectorWindow;
    const ctx = this.documentContext;
    let needsUpdateForLayer = false;
    let needsUpdateForPallete = false;
    switch (wnd.currentTargetID) {
      case PaletteSelectorWindowButtonID.lineColor:
        if (ctx.currentStrokeDrawable != null) {
          ctx.currentStrokeDrawable.line_PaletteColorIndex = paletteColorIndex;
          vec4.copy(ctx.currentStrokeDrawable.layerColor, color.color);
          needsUpdateForLayer = true;
        }
        break;
      case PaletteSelectorWindowButtonID.fillColor:
        if (ctx.currentFillDrawable) {
          ctx.currentFillDrawable.fill_PaletteColorIndex = paletteColorIndex;
          vec4.copy(ctx.currentFillDrawable.fillColor, color.color);
          needsUpdateForLayer = true;
        }
        break;
      case PaletteSelectorWindowButtonID.adjustmentMode:
        wnd.setCurrentPaletteIndex(paletteColorIndex);
        needsUpdateForPallete = true;
        break;
    }
    if (needsUpdateForLayer) {
      this.appMain.executePostUpdateForCurrentLayer();
    }
    if (needsUpdateForPallete) {
      this.subtoolContext.setRedrawPaletteWindow();
    }
  }
  colorMixerWindow_colorCanvas_mousedown() {
    const wnd = this.appView.colorMixerWindow.colorCanvas;
    const e = wnd.pointerEvent;
    if (!e.isLeftButtonPressing()) {
      return;
    }
    this.appDrawing.canvasRender.setContext(wnd);
    this.appDrawing.canvasRender.pickColor(this.tempColor4, e.offsetX, e.offsetY);
    this.updateCurrentLayerColor(this.tempColor4, true);
  }
  colorMixerWindow_changeColor(newColor) {
    this.updateCurrentLayerColor(newColor, false);
  }
  updateCurrentLayerColor(newColor, keepAlpha) {
    this.appView.paletteSelectorWindow.updateCurrentLayerColor(newColor, keepAlpha, this.documentContext);
    this.appMain.executePostUpdateForCurrentLayer();
  }
  timeLineWindow_mousedown() {
    const e = this.appView.timeLineWindow.canvasWindow.pointerEvent;
    const left = this.appView.timeLineWindow.getTimeLineLeft();
    if (e.offsetX < left) {
      this.timeLineWindow_OnPlayPauseButton();
    } else {
      this.timeLineWindow_ProcessFrameInput();
    }
  }
  timeLineWindow_OnPlayPauseButton() {
    const aniSetting = this.documentContext.documentData.animationSettingData;
    if (this.documentContext.animationPlaying) {
      this.documentContext.animationPlaying = false;
      this.subtoolContext.setRedrawTimeLineWindow();
    } else {
      this.documentContext.animationPlaying = true;
      this.documentContext.animationPlayingFPS = aniSetting.animationFrameParSecond;
    }
  }
  timeLineWindow_ProcessFrameInput() {
    const wnd = this.appView.timeLineWindow.canvasWindow;
    const e = wnd.pointerEvent;
    const aniSetting = this.documentContext.documentData.animationSettingData;
    const clickedFrame = this.appView.timeLineWindow.getFrameByLocation(e.offsetX, aniSetting);
    if (clickedFrame != -1 && clickedFrame != aniSetting.currentTimeFrame) {
      this.appMain.setCurrentFrame(clickedFrame);
    }
  }
  timeLineWindow_mousemove() {
    const e = this.appView.timeLineWindow.canvasWindow.pointerEvent;
    if (e.isLeftButtonPressing()) {
      this.timeLineWindow_ProcessFrameInput();
    }
  }
  timeLineWindow_mousewheel() {
    const e = this.appView.timeLineWindow.canvasWindow.pointerEvent;
    const aniSetting = this.documentContext.documentData.animationSettingData;
    if (this.subtoolContext.isCtrlKeyPressing()) {
      const addScale = 0.2;
      if (e.wheelDelta > 0) {
        aniSetting.timeLineWindowScale += addScale;
      } else {
        aniSetting.timeLineWindowScale -= addScale;
      }
      if (aniSetting.timeLineWindowScale < 1) {
        aniSetting.timeLineWindowScale = 1;
      }
      if (aniSetting.timeLineWindowScale > aniSetting.timeLineWindowScaleMax) {
        aniSetting.timeLineWindowScale = aniSetting.timeLineWindowScaleMax;
      }
      this.subtoolContext.setRedrawTimeLineWindow();
    }
  }
  dialog_Closed() {
  }
  dialog_DocumentFiler_fileItemSelected(filePath) {
    this.appMain.startReloadDocument(filePath);
  }
  dialog_DocumentFiler_filePathFixed(directoryPath, fileName) {
    this.appMain.saveAsDocument(directoryPath, fileName);
  }
  modal_ImageFileReference_Closed(filePath, image) {
    const command = new Command_SetReferenceImageToLayer();
    command.targetLayer = this.subtoolContext.currentImageFileReferenceLayer;
    command.image = image;
    command.filePath = filePath;
    this.subtoolContext.commandHistory.executeCommand(command, this.subtoolContext);
  }
  modal_ExportImage_Closed(param) {
    this.appMain.exportImageFile(param);
  }
  onModalWindowClosed() {
    this.appView.dialogScreen.onDialogWindowClosed();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawWindowsForCurrentLayerChanging();
  }
}
class App_DefferedProcess {
  constructor() {
    this.calculation_LazyUpdateState = new LazyUpdateState();
    this.drawing_LazyUpdateState = new LazyUpdateState();
    this.appDrawing = null;
    this.drawPathBuffering = null;
    this.posing3DLogic = null;
    this.posing3DView = null;
    this.isPostUpdateNeeded = false;
    this.lookDirection = vec3.fromValues(0, 0, 0);
    this.start_Location = vec3.fromValues(0, 0, 0);
    this.mouseCursorRangeRate = 1;
    this.docContext = null;
    this.subToolContext = null;
  }
  link(appDrawing, drawPathBuffering, posing3DLogic, posing3DView) {
    this.appDrawing = appDrawing;
    this.drawPathBuffering = drawPathBuffering;
    this.posing3DLogic = posing3DLogic;
    this.posing3DView = posing3DView;
  }
  linkContexts(docContext, toolContext) {
    this.docContext = docContext;
    this.subToolContext = toolContext;
  }
  setPostUpdateNeeded() {
    this.isPostUpdateNeeded = true;
  }
  executePostUpdate(drawPathContext, viewKeyframe, isUndo, subToolContext) {
    if (!this.isPostUpdateNeeded) {
      return false;
    }
    this.isPostUpdateNeeded = false;
    if (this.docContext.activeVectorLine != null && this.docContext.activeVectorLine.runtime.modifyFlag == VectorStrokeModifyFlagID.delete) {
      this.subToolContext.unsetAcrtiveVectorStrokeAndGroup();
      this.subToolContext.setRedrawEditorWindow();
    }
    for (const viewKeyframeLayer of viewKeyframe.layers) {
      if (VectorLayer.isVectorLayerWithOwnData(viewKeyframeLayer.layer)) {
        this.updateVectorLayer(viewKeyframeLayer, drawPathContext, isUndo, subToolContext);
      }
    }
    return true;
  }
  updateVectorLayer(viewKeyframeLayer, drawPathContext, isUndo, subToolContext) {
    const isLayerUpdated = viewKeyframeLayer.layer.runtime.needsPostUpdate;
    viewKeyframeLayer.layer.runtime.needsPostUpdate = false;
    const geometry = viewKeyframeLayer.vectorLayerKeyframe.geometry;
    if (geometry.runtime.needsPostUpdate) {
      if (!isUndo) {
        const deleteEmpties_command = new Command_VectorLayer_DeleteEmpties();
        if (deleteEmpties_command.prepareForGeometry(geometry, viewKeyframeLayer.layer)) {
          deleteEmpties_command.isContinued = true;
          subToolContext.commandHistory.executeCommand(deleteEmpties_command, subToolContext);
        }
      }
      geometry.runtime.needsPostUpdate = false;
    }
    const isGeometryUpdated = this.updateGeometry(geometry);
    this.drawPathBuffering.setUpdateCacheToDrawPathSteps(
      viewKeyframeLayer.layer,
      drawPathContext,
      isLayerUpdated || isGeometryUpdated
    );
  }
  updateGeometry(geometry) {
    let isUpdated = false;
    const surroundingArea = RectangleArea.createMinumumValueRectangle();
    for (const unite of geometry.units) {
      for (const group of unite.groups) {
        if (group.runtime.needsPostUpdate) {
          group.runtime.needsPostUpdate = false;
          isUpdated = true;
          VectorStrokeLogic.calculateSurroundingArea(group.runtime.area, group.lines);
        }
        surroundingArea.expandByRectangle(group.runtime.area);
        if (VectorLayerGeometry.isSurroundingFill(geometry)) {
          group.runtime.connectionInfos = VectorStrokeLogic.createConnectionInfos(group);
        }
      }
    }
    if (isUpdated) {
      surroundingArea.calculateParams();
      surroundingArea.copyTo(geometry.runtime.area);
    }
    return isUpdated;
  }
  startLazyUpdates() {
    this.calculation_LazyUpdateState.startLazyCalculation();
    this.drawing_LazyUpdateState.startLazyCalculation();
  }
  executeLazyUpdate(drawPathContext, viewKeyframe) {
    const state = this.calculation_LazyUpdateState;
    drawPathContext.drawPathModeID = DrawPathModeID.lazyUpdate;
    drawPathContext.startIndex = state.processedIndex + 1;
    drawPathContext.endIndex = drawPathContext.steps.length - 1;
    drawPathContext.documentData = this.docContext.documentData;
    state.startPartialProcess();
    for (let i = drawPathContext.startIndex; i <= drawPathContext.endIndex; i++) {
      const drawPathStep = drawPathContext.steps[i];
      drawPathContext.lastDrawPathIndex = i;
      const viewKeyFrameLayer = drawPathStep.viewKeyframeLayer;
      const layer = viewKeyFrameLayer ? viewKeyFrameLayer.layer : null;
      if (drawPathStep.operationType == DrawPathOperationTypeID.drawForeground) {
        if (VectorLayer.isVectorLayer(layer)) {
          const vectorLayer = layer;
          if (vectorLayer.eyesSymmetryEnabled && vectorLayer.runtime.posingLayer != null) {
            console.debug(`Lazy calculation updateEyesSymetries "${vectorLayer.name}"`);
            this.updateEyesSymetry(vectorLayer, viewKeyFrameLayer);
            for (const vkfLayer of viewKeyframe.layers) {
              if (vkfLayer.layer.runtime.parentLayer == layer.runtime.parentLayer) {
                if (PointBrushFillLayer.isPointBrushFillLayer(vkfLayer.layer)) {
                  Layer.setPostUpdateNeeded(vkfLayer.layer);
                  this.setPostUpdateNeeded();
                }
              }
            }
          }
        }
      } else if (drawPathStep.operationType == DrawPathOperationTypeID.drawBackground) {
        if (AutoFillLayer.isAutoFillLayer(layer)) {
          const autoFillLayer = layer;
          if (autoFillLayer.runtime.needsLazyUpdate) {
            console.debug(`Lazy calculation updateAutoFill "${autoFillLayer.name}"`);
            this.updateAutoFill(autoFillLayer, this.subToolContext);
            autoFillLayer.runtime.needsLazyUpdate = false;
          }
        }
      }
      if (state.isOverPartialProcessMaxTime()) {
        break;
      }
    }
    console.debug(`Lazy calculation from ${drawPathContext.startIndex} to ${drawPathContext.lastDrawPathIndex}`);
    state.processedIndex = drawPathContext.lastDrawPathIndex;
    if (state.processedIndex >= drawPathContext.steps.length - 1) {
      console.debug("Lazy calculation finished at", state.processedIndex);
      state.finishLazyUpdate();
      this.subToolContext.setRedrawMainWindowEditorWindow();
    }
  }
  updateEyesSymetry(layer, viewKeyFrameLayer) {
    EyesSymmetryLogic.updateEyesSymetries(
      layer,
      viewKeyFrameLayer.vectorLayerKeyframe.geometry,
      this.posing3DLogic,
      this.posing3DView
    );
  }
  updateAutoFill(layer, subtoolContext) {
    const newGroup = new VectorStrokeGroup();
    const viewKeyframeLayers = subtoolContext.main.collectVectorViewKeyframeLayers();
    const target_ViewKeyframeLayer = viewKeyframeLayers.find((vkfl) => vkfl.layer == layer);
    if (target_ViewKeyframeLayer === void 0) {
      throw new Error("ERROR 0000:invalid ViewKeyframeLayers");
    }
    const sibling_ViewKeyframeLayers = viewKeyframeLayers.filter((vkfl) => vkfl.layer != layer && VectorLayer.isVectorLayer(vkfl.layer) && vkfl.layer.runtime.parentLayer == layer.runtime.parentLayer);
    AutoFillLayer.forEachFillPoint(target_ViewKeyframeLayer.autoFillLayerKeyframe, (group, autoFillPoint) => {
      vec3.add(this.start_Location, autoFillPoint.location, autoFillPoint.lookDirection);
      const start_Stroke = AutoFillLogic.findStartStroke(
        this.start_Location,
        this.mouseCursorRangeRate,
        sibling_ViewKeyframeLayers
      );
      if (start_Stroke == null) {
        return;
      }
      const fill_Stroke = new VectorStroke();
      const isAvailable = AutoFillLogic.generate(
        fill_Stroke,
        this.lookDirection,
        start_Stroke,
        autoFillPoint.location,
        autoFillPoint.minDistanceRange,
        sibling_ViewKeyframeLayers
      );
      if (!isAvailable) {
        return;
      }
      vec3.copy(autoFillPoint.lookDirection, this.lookDirection);
      newGroup.lines.push(fill_Stroke);
    });
    newGroup.runtime.needsPostUpdate = true;
    target_ViewKeyframeLayer.autoFillLayerKeyframe.geometry.units[0].groups[0] = newGroup;
    this.updateGeometry(target_ViewKeyframeLayer.autoFillLayerKeyframe.geometry);
  }
  isLazyCalculationFinished() {
    return this.calculation_LazyUpdateState.isFinished;
  }
  drawDrawPathForLazyDraw(mainWindow, docContext, subtoolContext, drawPathContext) {
    drawPathContext.drawPathModeID = DrawPathModeID.lazyUpdate;
    drawPathContext.startIndex = this.drawing_LazyUpdateState.processedIndex + 1;
    drawPathContext.endIndex = drawPathContext.steps.length - 1;
    drawPathContext.documentData = docContext.documentData;
    drawPathContext.isModalToolRunning = subtoolContext.tool.isModalToolRunning();
    drawPathContext.currentLayerOnly = false;
    drawPathContext.lazyUpdateState = this.drawing_LazyUpdateState;
    const clearState = this.drawing_LazyUpdateState.isLazyDrawBigining();
    const buffer_CanvasWindow = drawPathContext.lazyDraw_compositionBuffer.canvasWindow;
    mainWindow.copyTransformTo(buffer_CanvasWindow);
    this.appDrawing.drawDrawPathContext(buffer_CanvasWindow, drawPathContext, clearState);
    console.debug(`Lazy drawing ${clearState ? "begin" : "draw"} from ${drawPathContext.startIndex} to ${drawPathContext.lastDrawPathIndex} -> buffer[${drawPathContext.bufferStack.length}]`);
    if (!drawPathContext.existsDrawnStepsAtLastTime()) {
      return;
    }
    this.drawing_LazyUpdateState.processedIndex = drawPathContext.lastDrawPathIndex;
    if (drawPathContext.isFinished()) {
      this.drawing_LazyUpdateState.finishLazyUpdate();
      console.debug("Lazy drawing finished at", this.drawing_LazyUpdateState.processedIndex);
      this.appDrawing.clearWindow(mainWindow);
      this.appDrawing.canvasRender.resetTransform();
      this.appDrawing.canvasRender.drawImage(
        buffer_CanvasWindow.canvas,
        0,
        0,
        mainWindow.width,
        mainWindow.height,
        0,
        0,
        mainWindow.width,
        mainWindow.height
      );
      if (subtoolContext.isEditMode()) {
        this.appDrawing.main_drawPathContext.isEditModeDraw = true;
        this.appDrawing.main_drawPathContext.redrawActiveLayerOnly = true;
        this.appDrawing.main_drawPathContext.currentLayerOnly = false;
        this.appDrawing.main_drawPathContext.isModalToolRunning = false;
        this.appDrawing.drawDocumentForEditMode(mainWindow, docContext, this.appDrawing.main_drawPathContext);
      }
      this.appDrawing.drawFrames(mainWindow, docContext);
    }
  }
}
class MainToolTab_AutoFill extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.autoFill;
    this.default_SubToolID = SubToolID.addAutoFillPoint;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.addAutoFillPoint },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.deleteAutoFillPoint }
    ];
  }
  isAvailable(ctx) {
    return ctx.isDrawMode() && ctx.isCurrentLayerAutoFillLayer();
  }
  keydown(_key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    if (this.processToggleSubTool(
      ShortcutCommandID.tool_togglePenEraser,
      SubToolID.deleteAutoFillPoint,
      SubToolID.addAutoFillPoint,
      commandID,
      ctx
    )) {
      return true;
    }
    return false;
  }
}
class MainToolTab_Document extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.document;
    this.default_SubToolID = SubToolID.editDocumentFrame;
  }
  isAvailable(ctx) {
    return ctx.isEditMode() && ctx.isCurrentLayerEditbaleLayer();
  }
}
class MainToolTab_Drawing extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.drawing;
    this.default_SubToolID = SubToolID.drawLine;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.drawLine },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.deletePointBrush },
      { commandID: ShortcutCommandID.tool_subTool3, subToolID: SubToolID.scratchLine },
      { commandID: ShortcutCommandID.tool_subTool4, subToolID: SubToolID.extrudeLine },
      { commandID: ShortcutCommandID.tool_subTool5, subToolID: SubToolID.scratchLineWidth },
      { commandID: ShortcutCommandID.tool_subTool6, subToolID: SubToolID.overWriteLineWidth }
    ];
  }
  isAvailable(ctx) {
    return ctx.isDrawMode() && ctx.isCurrentLayerStrokeDrawableLayer();
  }
  keydown(key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    if (this.processToggleSubTool(
      ShortcutCommandID.tool_togglePenEraser,
      SubToolID.deletePointBrush,
      SubToolID.drawLine,
      commandID,
      ctx
    )) {
      return true;
    }
    return false;
  }
}
class MainToolTab_EditDisabled extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.edit_disabled;
    this.type = MainToolTabTypeID.editingTool;
    this.default_SubToolID = SubToolID.brushSelect;
    this.disabled = true;
  }
}
class MainToolTab_Edit extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.edit;
    this.type = MainToolTabTypeID.editingTool;
    this.default_SubToolID = SubToolID.brushSelect;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.brushSelect },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.locateOperatorCursor },
      { commandID: ShortcutCommandID.tool_subTool3, subToolID: SubToolID.editModeMain },
      { commandID: ShortcutCommandID.tool_subTool4, subToolID: SubToolID.resampleSegment }
    ];
  }
  isAvailable(ctx) {
    return ctx.isEditMode() && ctx.isCurrentLayerEditbaleLayer();
  }
  keydown(_key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    let modalToolID = SubToolID.none;
    if (commandID == ShortcutCommandID.edit_grabMove) {
      modalToolID = SubToolID.edit_GrabMove;
    }
    if (commandID == ShortcutCommandID.edit_rotate) {
      modalToolID = SubToolID.edit_Rotate;
    }
    if (commandID == ShortcutCommandID.edit_scale) {
      modalToolID = SubToolID.edit_Scale;
    }
    if (modalToolID != SubToolID.none) {
      ctx.tool.startModalTool(modalToolID);
      return true;
    }
    if (commandID == ShortcutCommandID.edit_selectAll) {
      ctx.tool.executeToggleSelection();
      return true;
    }
    return false;
  }
}
class MainToolTab_Group extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.group;
    this.default_SubToolID = SubToolID.deletePointBrush;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.scratchLine },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.deletePointBrush },
      { commandID: ShortcutCommandID.tool_subTool3, subToolID: SubToolID.overWriteLineWidth },
      { commandID: ShortcutCommandID.tool_subTool4, subToolID: SubToolID.resampleSegment }
    ];
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerGroupLayer();
  }
  keydown(key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    if (this.processToggleSubTool(
      ShortcutCommandID.tool_togglePenEraser,
      SubToolID.scratchLine,
      SubToolID.deletePointBrush,
      commandID,
      ctx
    )) {
      return true;
    }
    return false;
  }
}
class MainToolTab_ImageFileReference extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.imageFileReference;
    this.default_SubToolID = SubToolID.image_GrabMove;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.image_GrabMove },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.image_Rotate },
      { commandID: ShortcutCommandID.tool_subTool3, subToolID: SubToolID.image_Scale },
      { commandID: ShortcutCommandID.tool_subTool4, subToolID: SubToolID.resampleSegment }
    ];
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerImageFileReferenceLayer();
  }
  keydown(key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    if (commandID == ShortcutCommandID.edit_grabMove) {
      ctx.tool.changeCurrentSubToolForSubtoolID(SubToolID.image_GrabMove);
      ctx.tool.startModalTool(SubToolID.image_GrabMove);
      return true;
    }
    if (commandID == ShortcutCommandID.edit_rotate) {
      ctx.tool.changeCurrentSubToolForSubtoolID(SubToolID.image_Rotate);
      ctx.tool.startModalTool(SubToolID.image_Rotate);
      return true;
    }
    if (commandID == ShortcutCommandID.edit_scale) {
      ctx.tool.changeCurrentSubToolForSubtoolID(SubToolID.image_Scale);
      ctx.tool.startModalTool(SubToolID.image_Scale);
      return true;
    }
    return false;
  }
  buttonClick(id2, ctx) {
    switch (id2) {
      case RibbonUIControlID.imageFileRef_openImageFile:
        ctx.main.openFileDialog(OpenFileDialogTargetID.imageFileReferenceLayerFilePath);
        return true;
    }
    return false;
  }
}
class MainToolTab_Layer extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.layer;
    this.default_SubToolID = SubToolID.noOperation;
  }
  isAvailable(ctx) {
    return true;
  }
}
class MainToolTab_PointBrushFill extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.pointBrushFill;
    this.default_SubToolID = SubToolID.drawPointBrush;
    this.subToolCommands = [
      { commandID: ShortcutCommandID.tool_subTool1, subToolID: SubToolID.drawPointBrush },
      { commandID: ShortcutCommandID.tool_subTool2, subToolID: SubToolID.deletePointBrush },
      { commandID: ShortcutCommandID.tool_subTool3, subToolID: SubToolID.scratchLine },
      { commandID: ShortcutCommandID.tool_subTool4, subToolID: SubToolID.extrudeLine }
    ];
  }
  isAvailable(ctx) {
    return ctx.isDrawMode() && ctx.isCurrentLayerStrokeDrawableLayer();
  }
  keydown(key, commandID, ctx) {
    if (this.processSubToolKeyDown(this.subToolCommands, commandID, ctx)) {
      return true;
    }
    if (this.processToggleSubTool(
      ShortcutCommandID.tool_togglePenEraser,
      SubToolID.deletePointBrush,
      SubToolID.drawPointBrush,
      commandID,
      ctx
    )) {
      return true;
    }
    return false;
  }
}
class MainToolTab_Poing3D extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.posing;
    this.default_SubToolID = SubToolID.p3d_locateHead;
  }
}
class MainToolTab_View extends MainToolTab {
  constructor() {
    super(...arguments);
    this.tabID = MainToolTabID.view;
    this.default_SubToolID = SubToolID.noOperation;
  }
  isAvailable(ctx) {
    return true;
  }
}
class MainTool_AutoFillLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.autoFill;
    this.mainToolTabs = [
      new MainToolTab_AutoFill(),
      tabs.edit_disabled,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class MainTool_GroupLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.group;
    this.mainToolTabs = [
      new MainToolTab_Group(),
      tabs.edit,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class MainTool_ImageFileReferenceLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.imageFileReference;
    this.mainToolTabs = [
      new MainToolTab_ImageFileReference(),
      tabs.edit_disabled,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class MainTool_PointBrushFillLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.pointBrushFill;
    this.mainToolTabs = [
      new MainToolTab_PointBrushFill(),
      tabs.edit,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class MainTool_Poing3DLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.posing3D;
    this.mainToolTabs = [
      new MainToolTab_Poing3D(),
      tabs.edit_disabled,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class MainTool_VectorLayer extends MainTool {
  constructor(tabs) {
    super();
    this.mainToolID = MainToolID.vector;
    this.mainToolTabs = [
      new MainToolTab_Drawing(),
      tabs.edit,
      tabs.layer,
      tabs.document,
      tabs.view
    ];
  }
}
class Tool_BrushSelectLinePointBase extends ModalToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u5DE6\u30AF\u30EA\u30C3\u30AF\u3067\u9078\u629E\u3092\u8FFD\u52A0\u3001Alt\u30AD\u30FC\u3092\u62BC\u3057\u306A\u304C\u3089\u3067\u9078\u629E\u3092\u89E3\u9664\u3057\u307E\u3059\u3002<br />A\u30AD\u30FC\u3067\u5168\u9078\u629E\uFF0F\u89E3\u9664\u3057\u307E\u3059\u3002G\u3001R\u3001S\u30AD\u30FC\u3067\u79FB\u52D5\u3001\u56DE\u8EE2\u3001\u62E1\u7E2E\u3057\u307E\u3059\u3002";
    this.isEditTool = true;
    this.usesHitTestToSelect = true;
    this.brushSelector = null;
    this.viewKeyframeLayers = null;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerEditbaleLayer();
  }
  onDrawEditor(ctx, drawing) {
    if (!this.isAvailable(ctx)) {
      return;
    }
    drawing.editorDrawer.drawPointerCursor(this.getSelectionRadius(ctx));
  }
  mouseDown(e, ctx) {
    if (!this.isAvailable(ctx)) {
      return;
    }
    if (e.isLeftButtonPressing) {
      this.startSelection(e, ctx);
      this.processSelection(e, ctx);
      ctx.tool.startModalTool(this.subtoolID);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    }
  }
  mouseMove(e, ctx) {
    if (!this.isAvailable(ctx)) {
      return;
    }
    if (ctx.tool.isModalToolRunning()) {
      this.processSelection(e, ctx);
      ctx.setRedrawCurrentLayer();
    } else {
      const isHitChanged = ctx.tool.visualHittestToStrokes(e.location, ctx.toolBaseViewRadius);
      if (isHitChanged) {
        ctx.setRedrawCurrentLayer();
      }
    }
    ctx.setRedrawEditorWindow();
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
    if (!this.isAvailable(ctx)) {
      return;
    }
    this.endSelection(ctx);
    ctx.setRedrawCurrentLayer();
    ctx.setRedrawEditorWindow();
  }
  startSelection(e, ctx) {
    this.viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    this.onStartSelection(e, ctx);
    this.brushSelector.startProcess();
  }
  getSelectionRadius(ctx) {
    return ctx.toolBaseViewRadius;
  }
  onStartSelection(_e, _ctx) {
  }
  processSelection(e, ctx) {
    if (this.viewKeyframeLayers == null) {
      return null;
    }
    ViewKeyframeLayer.forEachVectorGeometry(this.viewKeyframeLayers, (geometry, layer) => {
      this.brushSelector.processGeometry(
        layer,
        geometry,
        e.location,
        this.getSelectionRadius(ctx)
      );
    });
    this.afterProcessSelection(ctx);
  }
  afterProcessSelection(ctx) {
  }
  endSelection(ctx) {
    this.brushSelector.endProcess();
    this.viewKeyframeLayers = null;
    if (!this.existsResults()) {
      return;
    }
    this.executeCommand(ctx);
  }
  existsResults() {
    return this.brushSelector.selectionInfo.selectedStrokess.length != 0 || this.brushSelector.selectionInfo.selectedPoints.length != 0;
  }
  executeCommand(_ctx) {
  }
}
class Tool_Select_BrushSelect extends Tool_BrushSelectLinePointBase {
  constructor() {
    super(...arguments);
    this.strokeSelector = new Selector_VectorStroke_BrushSelect();
    this.segmentSelector = new Selector_StrokeSegment_BrushSelect();
    this.pointSelector = new Selector_VectorPoint_BrushSelect();
    this.brushSelector = this.strokeSelector;
    this.hasClearedBeforeSelection = false;
  }
  onStartSelection(_e, ctx) {
    switch (ctx.operationUnitID) {
      case OperationUnitID.stroke:
        this.brushSelector = this.strokeSelector;
        break;
      case OperationUnitID.strokeSegment:
        this.brushSelector = this.segmentSelector;
        break;
      case OperationUnitID.strokePoint:
        this.brushSelector = this.pointSelector;
        break;
    }
    if (ctx.isCtrlKeyPressing()) {
      this.brushSelector.editMode = SelectionEditMode.toggle;
    } else if (ctx.isAltKeyPressing()) {
      this.brushSelector.editMode = SelectionEditMode.setUnselected;
    } else {
      this.brushSelector.editMode = SelectionEditMode.setSelected;
    }
    this.hasClearedBeforeSelection = false;
    if (!ctx.isAnyModifierKeyPressing()) {
      this.hasClearedBeforeSelection = ctx.tool.executeClearSelection();
    }
  }
  cancelModal(ctx) {
    for (const selPoint of this.brushSelector.selectionInfo.selectedPoints) {
      selPoint.point.isSelected = selPoint.selectStateBefore;
    }
    this.brushSelector.endProcess();
    ctx.setRedrawMainWindowEditorWindow();
  }
  executeCommand(ctx) {
    const command = new Command_Select();
    command.selectionInfo = this.brushSelector.selectionInfo;
    if (this.hasClearedBeforeSelection) {
      command.isContinued = true;
    }
    ctx.commandHistory.executeCommand(command, ctx);
  }
}
class Command_Select extends CommandBase {
  constructor() {
    super(...arguments);
    this.selectionInfo = null;
    this.selectedLines = null;
    this.selectedPoints = null;
  }
  execute(_ctx) {
    this.selectedLines = Lists.clone(this.selectionInfo.selectedStrokess);
    this.selectedPoints = Lists.clone(this.selectionInfo.selectedPoints);
  }
  undo(_ctx) {
    for (const selPoint of this.selectedPoints) {
      selPoint.point.isSelected = selPoint.selectStateBefore;
    }
    for (const selLine of this.selectedLines) {
      selLine.stroke.isSelected = selLine.selectStateBefore;
    }
  }
  redo(_ctx) {
    for (const selPoint of this.selectedPoints) {
      selPoint.point.isSelected = selPoint.selectStateAfter;
    }
    for (const selLine of this.selectedLines) {
      selLine.stroke.isSelected = selLine.selectStateAfter;
    }
  }
}
class DivideLine_EditGroup {
  constructor() {
    this.target_group = null;
    this.new_strokes = [];
    this.replaced_strokes = [];
    this.old_strokes = null;
  }
}
class Selector_DeleteLinePoint_DivideLine extends Selector_StrokeSegment_BrushSelect {
  constructor() {
    super(...arguments);
    this.segmentMat4 = mat4.create();
    this.invMat4 = mat4.create();
    this.normalVec = vec3.create();
    this.localLocation = vec3.create();
  }
  onLineSegmentHited(point1, point2, location, minDistanceSQ, _distanceSQ) {
    this.createEditPoint(point1, point2, location, minDistanceSQ);
  }
  createEditPoint(point1, point2, location, minDistanceSQ) {
    let edited = false;
    const segmentLength = vec3.distance(point1.location, point2.location);
    if (segmentLength <= 0) {
      edited = true;
      point1.adjustingLengthFrom = 0;
      point1.adjustingLengthTo = 1;
    } else {
      Maths.mat4SegmentMat(this.segmentMat4, this.normalVec, point1.location, point2.location);
      mat4.invert(this.invMat4, this.segmentMat4);
      vec3.set(this.localLocation, location[0], location[1], 0);
      vec3.transformMat4(this.localLocation, this.localLocation, this.invMat4);
      let dy = 0 - this.localLocation[1];
      if (minDistanceSQ - dy * dy < 0) {
        dy = 0.01;
      }
      const dx = Math.sqrt(minDistanceSQ - dy * dy);
      const x1 = this.localLocation[0] - dx;
      const x2 = this.localLocation[0] + dx;
      if (x1 > 0 && x1 < segmentLength && x2 >= segmentLength) {
        const fromX = x1 / segmentLength;
        if (fromX < point1.adjustingLengthFrom) {
          point1.adjustingLengthFrom = fromX;
        }
        edited = true;
        point1.adjustingLengthTo = 1;
      } else if (x2 > 0 && x2 < segmentLength && x1 <= 0) {
        edited = true;
        point1.adjustingLengthFrom = 0;
        const toX = x2 / segmentLength;
        if (toX > point1.adjustingLengthTo) {
          point1.adjustingLengthTo = toX;
        }
      } else if (x1 < 0 && x2 > segmentLength) {
        edited = true;
        point1.adjustingLengthFrom = 0;
        point1.adjustingLengthTo = 1;
      } else if (x1 > 0 && x2 < segmentLength) {
        const fromX = x1 / segmentLength;
        if (fromX < point1.adjustingLengthFrom) {
          edited = true;
          point1.adjustingLengthFrom = fromX;
        }
        const toX = x2 / segmentLength;
        if (toX > point1.adjustingLengthTo) {
          edited = true;
          point1.adjustingLengthTo = toX;
        }
      }
    }
    if (edited) {
      this.selectionInfo.editStroke(this.currentStroke);
      this.selectionInfo.editGroup(this.currentStrokeGroup, this.currentGeometry, this.currentLayer);
    }
  }
  afterHitTest() {
  }
}
class Tool_DeletePoints_DivideLine extends Tool_BrushSelectLinePointBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D6\u30E9\u30B7\u9078\u629E\u3067\u70B9\u3092\u524A\u9664\u3057\u307E\u3059\u3002";
    this.isEditTool = false;
    this.selector = new Selector_DeleteLinePoint_DivideLine();
    this.brushSelector = this.selector;
  }
  afterProcessSelection(ctx) {
    for (const groupSelection of this.selector.selectionInfo.selectedGroups) {
      if (VectorLayer.isPointBrushFillLayer(groupSelection.layer)) {
        ctx.main.setRedrawDrawPathForLayer(groupSelection.layer);
      }
    }
  }
  existsResults() {
    return this.selector.selectionInfo.selectedGroups.length > 0;
  }
  executeCommand(ctx) {
    const command = new Command_DeletePoints_DivideLine();
    if (command.prepareEditTargets(this.selector.selectionInfo)) {
      ctx.commandHistory.executeCommand(command, ctx);
    }
    this.selector.resetModifyStates();
    ctx.setRedrawCurrentLayer();
  }
}
class Command_DeletePoints_DivideLine extends CommandBase {
  constructor() {
    super(...arguments);
    this.editGroups = null;
    this.toLocation = vec3.create();
    this.fromLocation = vec3.create();
  }
  prepareEditTargets(selectionInfo) {
    const editGroups = [];
    for (const selGroup of selectionInfo.selectedGroups) {
      const edit_group = new DivideLine_EditGroup();
      edit_group.target_group = selGroup.group;
      edit_group.old_strokes = selGroup.group.lines;
      for (const stroke of selGroup.group.lines) {
        if (stroke.runtime.modifyFlag == VectorStrokeModifyFlagID.none) {
          edit_group.new_strokes.push(stroke);
          continue;
        }
        edit_group.replaced_strokes.push(stroke);
        let new_stroke = null;
        let strokeStarted = false;
        let drawingRemaining = false;
        for (let pointIndex = 0; pointIndex < stroke.points.length - 1; pointIndex++) {
          const fromPoint = stroke.points[pointIndex];
          const fromLocation = fromPoint.location;
          const toPoint = stroke.points[pointIndex + 1];
          const toLocation = toPoint.location;
          const lengthFrom = fromPoint.adjustingLengthFrom;
          const lengthTo = fromPoint.adjustingLengthTo;
          fromPoint.adjustingLengthFrom = 1;
          fromPoint.adjustingLengthTo = 0;
          if (lengthFrom == 1) {
            if (!strokeStarted) {
              new_stroke = new VectorStroke();
              new_stroke.points.push(fromPoint);
            }
            new_stroke.points.push(toPoint);
            strokeStarted = true;
            drawingRemaining = true;
          } else {
            if (lengthFrom > 0) {
              if (!strokeStarted) {
                new_stroke = new VectorStroke();
                new_stroke.points.push(fromPoint);
              }
              vec3.lerp(this.toLocation, fromLocation, toLocation, lengthFrom);
              const newPoint = new VectorPoint();
              vec3.copy(newPoint.location, this.toLocation);
              vec3.copy(newPoint.adjustingLocation, newPoint.location);
              newPoint.lineWidth = Maths.lerp(lengthFrom, fromPoint.lineWidth, toPoint.lineWidth);
              newPoint.adjustingLineWidth = newPoint.lineWidth;
              new_stroke.points.push(newPoint);
              edit_group.new_strokes.push(new_stroke);
              strokeStarted = false;
              drawingRemaining = false;
            }
            if (lengthTo > 0 && lengthTo < 1) {
              if (drawingRemaining) {
                edit_group.new_strokes.push(new_stroke);
              }
              vec3.lerp(this.fromLocation, fromLocation, toLocation, lengthTo);
              new_stroke = new VectorStroke();
              const newPoint = new VectorPoint();
              vec3.copy(newPoint.location, this.fromLocation);
              vec3.copy(newPoint.adjustingLocation, newPoint.location);
              newPoint.lineWidth = Maths.lerp(lengthFrom, fromPoint.lineWidth, toPoint.lineWidth);
              newPoint.adjustingLineWidth = newPoint.lineWidth;
              new_stroke.points.push(newPoint);
              new_stroke.points.push(toPoint);
              strokeStarted = true;
              drawingRemaining = true;
            }
          }
        }
        if (drawingRemaining) {
          edit_group.new_strokes.push(new_stroke);
        }
      }
      for (const stroke of edit_group.new_strokes) {
        VectorStrokeLogic.calculateParameters(stroke, selGroup.layer.lineWidthBiasRate);
      }
      editGroups.push(edit_group);
      this.defferedProcess.addGeometryForDeletingEmpties(selGroup.geometry);
      this.defferedProcess.addGroup(selGroup.layer, selGroup.group, PostUpdateSituationTypeID.deleteObjects);
    }
    if (editGroups.length > 0) {
      this.editGroups = editGroups;
      return true;
    } else {
      return false;
    }
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editGroup of this.editGroups) {
      editGroup.target_group.lines = editGroup.old_strokes;
      for (const stroke of editGroup.replaced_strokes) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.none;
      }
    }
  }
  redo(_ctx) {
    for (const editGroup of this.editGroups) {
      editGroup.target_group.lines = editGroup.new_strokes;
      for (const stroke of editGroup.replaced_strokes) {
        stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
      }
    }
  }
}
class Tool_DrawLine extends ModalToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u7DDA\u3092\u8FFD\u52A0\u3057\u307E\u3059\u3002Shift\u30AD\u30FC\u3067\u76F4\u524D\u306E\u7DDA\u304B\u3089\u7D9A\u3051\u3066\u5857\u308A\u3064\u3076\u3057\u307E\u3059\u3002";
    this.strokeSingleHitTester = new HitTest_VectorStroke_PointToStroke_Nearest();
    this.editStroke = null;
    this.resampledLine = null;
    this.continuousFill = false;
    this.continuousFillFromStrokeTail = true;
    this.lastMouseLocation = vec3.create();
    this.strokeSmoothLevel = 3;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerStrokeDrawableLayer();
  }
  onActivated(ctx) {
    if (ctx.activeVectorLine == null) {
      this.continuousFill = false;
      this.continuousFillFromStrokeTail = true;
    }
    ctx.setRedrawEditorWindow();
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawaBrushCursor(ctx.brushBaseSize, ctx.currentVectorLayer.lineWidthBiasRate);
    if (this.resampledLine != null) {
      drawing.editorDrawer.drawOperatorSolidStroke(this.resampledLine, ctx.currentVectorLayer.lineWidthBiasRate);
    }
    if (VectorLayer.isSurroundingFillLayer(ctx.currentLayer)) {
      if (this.continuousFill && ctx.activeVectorGroup != null && ctx.activeVectorLine != null) {
        const targetPoint = this.continuousFillFromStrokeTail ? ctx.activeVectorLine.points.at(-1) : ctx.activeVectorLine.points.at(0);
        drawing.render.setStrokeColorV(ctx.drawStyle.sampledPointColor);
        drawing.editorDrawer.drawStrokeConnectionInfoLine(targetPoint.location, this.lastMouseLocation);
      }
    }
  }
  mouseDown(e, ctx) {
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.resetState(true);
    this.addPointToEditLine(e, ctx);
    vec3.copy(this.lastMouseLocation, ctx.mouseCursorLocation);
    ctx.tool.startModalTool(this.subtoolID);
  }
  mouseMove(e, ctx) {
    ctx.setRedrawEditorWindow();
    if (VectorLayer.isSurroundingFillLayer(ctx.currentLayer)) {
      if (ctx.activeVectorLine != null) {
        ctx.setRedrawEditorWindow();
      }
    }
    if (this.isEditing()) {
      this.addPointToEditLine(e, ctx);
    } else {
      this.updateLastMouseLocation(ctx);
    }
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
    if (VectorLayer.isSurroundingFillLayer(ctx.currentLayer)) {
      if (!e.isPointerMoved) {
        this.selectGroup(e.location, ctx);
        this.resetState();
        ctx.setRedrawEditorWindow();
        return;
      }
      if (ctx.activeVectorLine != null) {
        ctx.setRedrawEditorWindow();
      }
      this.updateLastMouseLocation(ctx);
    }
    if (this.resampledLine == null || VectorStrokeLogic.isEmptyStroke(this.resampledLine)) {
      this.resetState();
      return;
    }
    this.executeCommand(ctx);
    this.resetState();
    ctx.setRedrawCurrentLayer();
    ctx.setRedrawEditorWindow();
  }
  isEditing() {
    return this.editStroke != null;
  }
  resetState(isForOperationStart = false) {
    this.editStroke = null;
    this.resampledLine = null;
    if (isForOperationStart) {
      this.editStroke = new VectorStroke();
    }
  }
  addPointToEditLine(e, ctx) {
    const point = new VectorPoint();
    vec3.copy(point.location, e.location);
    point.lineWidth = ctx.drawLineBaseWidth;
    this.editStroke.points.push(point);
    VectorStrokeLogic.calculateParameters(this.editStroke);
    if (!VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      this.resampledLine = this.generateResampledLine(this.editStroke, ctx);
    }
  }
  updateLastMouseLocation(ctx) {
    vec3.copy(this.lastMouseLocation, ctx.mouseCursorLocation);
  }
  selectGroup(location, ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    let hitedGeometry = null;
    let hitedGroup = null;
    let hitedStroke = null;
    let isTailHited = true;
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry, layer) => {
      if (hitedStroke != null) {
        return;
      }
      this.strokeSingleHitTester.startProcess();
      this.strokeSingleHitTester.processGeometry(layer, geometry, location, ctx.touchViewRadius);
      if (this.strokeSingleHitTester.hitedStoke != null) {
        const headStroke = this.strokeSingleHitTester.hitedGroup.lines.at(0);
        const headPoint = headStroke.points.at(0);
        const distanceToHead = Logic_Points.pointToPoint_DistanceSQ(headPoint.location, location);
        const tailStroke = this.strokeSingleHitTester.hitedGroup.lines.at(-1);
        const tailPoint = tailStroke.points.at(-1);
        const distanceTotail = Logic_Points.pointToPoint_DistanceSQ(tailPoint.location, location);
        isTailHited = distanceToHead > distanceTotail;
        hitedGeometry = this.strokeSingleHitTester.hitedGeometry;
        hitedGroup = this.strokeSingleHitTester.hitedGroup;
        hitedStroke = isTailHited ? tailStroke : headStroke;
      }
    });
    if (hitedStroke == null || VectorStrokeLogic.isEmptyStroke(hitedStroke)) {
      ctx.unsetAcrtiveVectorStrokeAndGroup();
      return;
    }
    ctx.setActiveVectorStroke(hitedStroke, hitedGroup, hitedGeometry);
    this.continuousFill = true;
    this.continuousFillFromStrokeTail = isTailHited;
  }
  generateResampledLine(editorLine, ctx) {
    const resamplingUnitLength = ctx.getViewScaledResamplingUnitLengthForBrush();
    const resampledLine = VectorStrokeLogic.createResampledLine(editorLine, resamplingUnitLength);
    VectorStrokeLogic.smooth(resampledLine, this.strokeSmoothLevel);
    return resampledLine;
  }
  executeCommand(ctx) {
    const newStroke = this.resampledLine;
    if (VectorLayer.isVectorStrokeLayer(ctx.currentLayer)) {
      const command = new Command_AddStroke();
      command.setTarget(ctx.currentVectorLayer, ctx.currentVectorLayerGeometry, null, ctx.activeVectorGroup, newStroke);
      ctx.commandHistory.executeCommand(command, ctx);
    } else if (VectorLayer.isSurroundingFillLayer(ctx.currentLayer)) {
      if (this.continuousFill && ctx.activeVectorLine != null && ctx.activeVectorGroup != null) {
        const targetPoint = this.continuousFillFromStrokeTail ? ctx.activeVectorLine.points.at(-1) : ctx.activeVectorLine.points.at(0);
        const headPoint = newStroke.points.at(0);
        const tailPoint = newStroke.points.at(-1);
        const distanceFromHead = Logic_Points.pointToPoint_DistanceSQ(targetPoint.location, headPoint.location);
        const distanceFromTail = Logic_Points.pointToPoint_DistanceSQ(targetPoint.location, tailPoint.location);
        if (this.continuousFillFromStrokeTail && distanceFromTail < distanceFromHead || !this.continuousFillFromStrokeTail && distanceFromTail > distanceFromHead) {
          Lists.reverse(newStroke.points);
        }
        if (this.continuousFillFromStrokeTail) {
          ctx.activeVectorLine;
        }
      } else {
        this.continuousFillFromStrokeTail = true;
      }
      const command = new Command_AddStroke();
      command.setTarget(ctx.currentVectorLayer, ctx.currentVectorLayerGeometry, null, ctx.activeVectorGroup, newStroke);
      command.addToTop = !this.continuousFillFromStrokeTail;
      ctx.commandHistory.executeCommand(command, ctx);
      ctx.setActiveVectorStroke(newStroke, command.group, command.geometry);
      this.continuousFill = true;
    }
  }
}
class Tool_DrawPointBrush extends ModalToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u7DDA\u3092\u8FFD\u52A0\u3057\u307E\u3059\u3002Shift\u30AD\u30FC\u3067\u76F4\u524D\u306E\u7DDA\u304B\u3089\u7D9A\u3051\u3066\u5857\u308A\u3064\u3076\u3057\u307E\u3059\u3002";
    this.strokeSingleHitTester = new HitTest_VectorStroke_PointToStroke_Nearest();
    this.editStroke = null;
    this.resampledLine = null;
    this.continuousFill = false;
    this.continuousFillFromStrokeTail = true;
    this.strokeSmoothLevel = 3;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerStrokeDrawableLayer();
  }
  onActivated(ctx) {
    if (ctx.activeVectorLine == null) {
      this.continuousFill = false;
      this.continuousFillFromStrokeTail = true;
    }
    ctx.setRedrawEditorWindow();
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawaBrushCursor(ctx.brushBaseSize, ctx.currentVectorLayer.lineWidthBiasRate);
    if (this.resampledLine != null) {
      drawing.editorDrawer.drawOperatorPointBrushStroke(this.resampledLine, ctx.currentVectorLayer.layerColor, false);
    } else if (this.editStroke != null) {
      drawing.editorDrawer.drawOperatorPointBrushStroke(this.editStroke, ctx.currentVectorLayer.layerColor, false);
    }
  }
  mouseDown(e, ctx) {
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.resetState(true);
    this.addPointToEditLine(e, ctx);
    ctx.tool.startModalTool(this.subtoolID);
  }
  mouseMove(e, ctx) {
    ctx.setRedrawEditorWindow();
    if (this.editStroke == null) {
      return;
    }
    this.addPointToEditLine(e, ctx);
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
    if (this.resampledLine == null || VectorStrokeLogic.isEmpty(this.resampledLine)) {
      this.resetState();
      return;
    }
    this.executeCommand(ctx);
    this.resetState();
    ctx.setRedrawCurrentLayer();
    ctx.setRedrawEditorWindow();
  }
  resetState(isForOperationStart = false) {
    this.editStroke = null;
    this.resampledLine = null;
    if (isForOperationStart) {
      this.editStroke = new VectorStroke();
    }
  }
  addPointToEditLine(e, ctx) {
    const point = new VectorPoint();
    vec3.copy(point.location, e.location);
    point.lineWidth = ctx.drawLineBaseWidth;
    this.editStroke.points.push(point);
    VectorStrokeLogic.calculateParameters(this.editStroke);
    if (!VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      this.resampledLine = this.generateResampledLine(this.editStroke, ctx);
    }
  }
  generateResampledLine(editorLine, ctx) {
    const resamplingUnitLength = ctx.getViewScaledResamplingUnitLengthForBrush();
    const resampledLine = VectorStrokeLogic.createResampledLine(editorLine, resamplingUnitLength);
    VectorStrokeLogic.smooth(resampledLine, this.strokeSmoothLevel);
    return resampledLine;
  }
  executeCommand(ctx) {
    const newStroke = this.resampledLine;
    if (VectorLayer.isPointBrushFillLayer(ctx.currentLayer)) {
      const command = new Command_AddStroke();
      command.setTarget(ctx.currentVectorLayer, ctx.currentVectorLayerGeometry, null, ctx.activeVectorGroup, newStroke);
      ctx.commandHistory.executeCommand(command, ctx);
    }
  }
}
class Tool_AutoFillPointBase extends SubTool {
  constructor() {
    super(...arguments);
    this.sibling_ViewKeyframeLayers = [];
    this.fromLocation = vec3.fromValues(0, 0, 0);
    this.toLocation = vec3.fromValues(0, 0, 0);
    this.offset = vec3.fromValues(0, 0, 0);
  }
  isAvailable(ctx) {
    return AutoFillLayer.isAutoFillLayer(ctx.currentLayer);
  }
  onActivated(ctx) {
    this.sibling_ViewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayers().filter((vkfl) => vkfl.layer.runtime.parentLayer == ctx.currentLayer.runtime.parentLayer);
  }
  onDrawEditor(ctx, drawing) {
    this.drawAutoFillPoints(ctx, drawing);
  }
  drawAutoFillPoints(ctx, drawing) {
    if (ctx.currentAutoFillLayer == null) {
      return;
    }
    let pointScale = ctx.getViewScaledLength(10);
    pointScale = Math.min(pointScale, 10);
    const strokeWidth = ctx.getViewScaledLength(2);
    const keyframe = EditAnimationFrameLogic.findLastKeyframeData(ctx.currentAutoFillLayer.keyframes, ctx.currentTimeFrame);
    if (keyframe == null) {
      throw new Error("ERROR 0000:Could not get keyframe for AutoFillLayer");
    }
    AutoFillLayer.forEachFillPoint(keyframe, (_group, fillPoint) => {
      vec3.add(this.fromLocation, fillPoint.location, vec3.scale(this.offset, vec3.normalize(this.offset, fillPoint.lookDirection), pointScale * 1));
      vec3.add(this.toLocation, fillPoint.location, vec3.scale(this.offset, fillPoint.lookDirection, 1));
      drawing.drawCircle(fillPoint.location, pointScale, strokeWidth * 3, ctx.drawStyle.autoFillPointEdgeColor);
      drawing.drawLine(this.fromLocation, this.toLocation, strokeWidth * 3, ctx.drawStyle.autoFillPointEdgeColor);
      drawing.drawCircle(fillPoint.location, pointScale, strokeWidth, ctx.drawStyle.autoFillPointLineColor);
      drawing.drawLine(this.fromLocation, this.toLocation, strokeWidth, ctx.drawStyle.autoFillPointLineColor);
    });
  }
  mouseMove(e, ctx) {
    ctx.setRedrawEditorWindow();
  }
}
class Tool_AddAutoFillPoint extends Tool_AutoFillPointBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30AF\u30EA\u30C3\u30AF\u3057\u305F\u5834\u6240\u306B\u81EA\u52D5\u5857\u308A\u3064\u3076\u3057\u306E\u958B\u59CB\u70B9\u3092\u8FFD\u52A0\u3057\u307E\u3059\u3002";
    this.minDistanceRange = 15;
    this.lookDirection = vec3.fromValues(0, 0, 0);
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawPointerCursor(ctx.toolBaseViewRadius);
    drawing.setLineDash(2);
    drawing.editorDrawer.drawPointerCursor(this.minDistanceRange / 2);
    drawing.cancelLineDash();
    this.drawAutoFillPoints(ctx, drawing);
  }
  mouseDown(e, ctx) {
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.executeCommand(e.location, ctx);
    ctx.setRedrawMainWindow();
  }
  executeCommand(start_Location, ctx) {
    const start_Stroke = AutoFillLogic.findStartStroke(
      start_Location,
      ctx.toolBaseViewRadius,
      this.sibling_ViewKeyframeLayers
    );
    if (start_Stroke == null) {
      return;
    }
    const fill_Stroke = new VectorStroke();
    const isAvailable = AutoFillLogic.generate(
      fill_Stroke,
      this.lookDirection,
      start_Stroke,
      start_Location,
      this.minDistanceRange,
      this.sibling_ViewKeyframeLayers
    );
    if (!isAvailable) {
      return;
    }
    const keyframe = EditAnimationFrameLogic.findLastKeyframeData(ctx.currentAutoFillLayer.keyframes, ctx.currentTimeFrame);
    const autoFillPoint = new AutoFillPoint();
    autoFillPoint.minDistanceRange = this.minDistanceRange;
    vec3.copy(autoFillPoint.location, start_Location);
    vec3.copy(autoFillPoint.lookDirection, this.lookDirection);
    const command = new Command_AddAutoFillPoint();
    command.autoFillPointGroup = keyframe.groups[0];
    command.vectorStrokeGroup = keyframe.geometry.units[0].groups[0];
    command.autoFillPoint = autoFillPoint;
    command.newStroke = fill_Stroke;
    ctx.commandHistory.executeCommand(command, ctx);
    ctx.setRedrawMainWindowEditorWindow();
  }
}
class Command_AddAutoFillPoint extends CommandBase {
  constructor() {
    super(...arguments);
    this.autoFillPoint = null;
    this.autoFillPointGroup = null;
    this.vectorStrokeGroup = null;
    this.newStroke = null;
    this.newAutoFillPoints = null;
    this.oldAutoFillPoints = null;
    this.newStrokes = null;
    this.oldStrokes = null;
  }
  execute(ctx) {
    this.oldAutoFillPoints = this.autoFillPointGroup.fillPoints;
    this.oldStrokes = this.vectorStrokeGroup.lines;
    this.newAutoFillPoints = Lists.clone(this.oldAutoFillPoints);
    this.newAutoFillPoints.push(this.autoFillPoint);
    this.newStrokes = Lists.clone(this.vectorStrokeGroup.lines);
    this.newStrokes.push(this.newStroke);
    this.redo(ctx);
  }
  undo(_ctx) {
    this.autoFillPointGroup.fillPoints = this.oldAutoFillPoints;
    this.vectorStrokeGroup.lines = this.oldStrokes;
  }
  redo(_ctx) {
    this.autoFillPointGroup.fillPoints = this.newAutoFillPoints;
    this.vectorStrokeGroup.lines = this.newStrokes;
  }
}
class Tool_DeleteAutoFillPoint extends Tool_AutoFillPointBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30AF\u30EA\u30C3\u30AF\u3057\u305F\u5834\u6240\u306E\u81EA\u52D5\u5857\u308A\u3064\u3076\u3057\u306E\u958B\u59CB\u70B9\u3092\u524A\u9664\u3057\u307E\u3059\u3002";
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawPointerCursor(ctx.toolBaseViewRadius);
    this.drawAutoFillPoints(ctx, drawing);
  }
  mouseDown(e, ctx) {
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.executeCommand(e.location, ctx);
    ctx.setRedrawMainWindow();
  }
  executeCommand(location, ctx) {
    const keyframe = EditAnimationFrameLogic.findLastKeyframeData(ctx.currentAutoFillLayer.keyframes, ctx.currentTimeFrame);
    const minDistance = ctx.toolBaseViewRadius;
    let delete_FillPoint = null;
    AutoFillLayer.forEachFillPoint(keyframe, (_group, fillPoint, looping) => {
      if (vec3.distance(fillPoint.location, location) < minDistance) {
        delete_FillPoint = fillPoint;
        looping.break = true;
      }
    });
    const command = new Command_DeleteAutoFillPoint();
    command.autoFillPointGroup = keyframe.groups[0];
    command.delete_AutoFillPoint = delete_FillPoint;
    command.defferedProcess.addLayer(ctx.currentAutoFillLayer);
    ctx.commandHistory.executeCommand(command, ctx);
    ctx.setRedrawMainWindowEditorWindow();
  }
}
class Command_DeleteAutoFillPoint extends CommandBase {
  constructor() {
    super(...arguments);
    this.autoFillPointGroup = null;
    this.delete_AutoFillPoint = null;
    this.newAutoFillPoints = null;
    this.oldAutoFillPoints = null;
  }
  execute(ctx) {
    this.oldAutoFillPoints = this.autoFillPointGroup.fillPoints;
    this.newAutoFillPoints = this.oldAutoFillPoints.filter((point) => point != this.delete_AutoFillPoint);
    this.redo(ctx);
  }
  undo(_ctx) {
    this.autoFillPointGroup.fillPoints = this.oldAutoFillPoints;
  }
  redo(_ctx) {
    this.autoFillPointGroup.fillPoints = this.newAutoFillPoints;
  }
}
var LatticePointEditTypeID = /* @__PURE__ */ ((LatticePointEditTypeID2) => {
  LatticePointEditTypeID2[LatticePointEditTypeID2["none"] = 0] = "none";
  LatticePointEditTypeID2[LatticePointEditTypeID2["horizontalOnly"] = 1] = "horizontalOnly";
  LatticePointEditTypeID2[LatticePointEditTypeID2["verticalOnly"] = 2] = "verticalOnly";
  LatticePointEditTypeID2[LatticePointEditTypeID2["allDirection"] = 3] = "allDirection";
  return LatticePointEditTypeID2;
})(LatticePointEditTypeID || {});
class LatticePoint {
  constructor() {
    this.latticePointEditType = 0;
    this.baseLocation = vec3.fromValues(0, 0, 0);
    this.location = vec3.fromValues(0, 0, 0);
    this.displayBaseLocationOffset = vec3.fromValues(0, 0, 0);
    this.displayOffset = vec3.fromValues(0, 0, 0);
    this.displayLocation = vec3.fromValues(0, 0, 0);
  }
}
class LatticeEdge {
  constructor() {
    this.partIndex = -1;
    this.latticePointFrom = null;
    this.latticePointTo = null;
    this.pointIndexFrom = 0;
    this.pointIndexTo = 0;
    this.mouseOver = false;
  }
}
var TransformType = /* @__PURE__ */ ((TransformType2) => {
  TransformType2[TransformType2["none"] = 0] = "none";
  TransformType2[TransformType2["grabMove"] = 1] = "grabMove";
  TransformType2[TransformType2["rotate"] = 2] = "rotate";
  TransformType2[TransformType2["scale"] = 3] = "scale";
  return TransformType2;
})(TransformType || {});
var TransformModifyType = /* @__PURE__ */ ((TransformModifyType2) => {
  TransformModifyType2[TransformModifyType2["none"] = 0] = "none";
  TransformModifyType2[TransformModifyType2["zero"] = 1] = "zero";
  TransformModifyType2[TransformModifyType2["slow"] = 2] = "slow";
  TransformModifyType2[TransformModifyType2["one"] = 3] = "one";
  return TransformModifyType2;
})(TransformModifyType || {});
class Tool_Transform_Lattice extends ModalToolBase {
  constructor() {
    super();
    this.isEditTool = true;
    this.allEdgeSelection = false;
    this.latticeState = 0;
    this.bound_contentArea = new RectangleArea();
    this.inner_contentArea = new RectangleArea();
    this.latticePoints = null;
    this.latticeEdges = null;
    this.latticePointCount = 4;
    this.transformType = 0;
    this.transformLockType = 0;
    this.transformModifyType = 0;
    this.transformCalculator = null;
    this.grabMove_Calculator = new GrabMove_Calculator();
    this.rotate_Calculator = new Rotate_Calculator();
    this.scale_Calculator = new Scale_Calculator();
    this.mouseOver_SelectedLatticePart = 0;
    this.mouseOver_PartIndex = -1;
    this.mouseOver_PartIndexTo = -1;
    this.dLocation = vec3.create();
    this.offset = vec3.create();
    this.offsetScale = vec3.create();
    this.offsetMatrix = mat4.create();
    this.mouseAnchorLocation = vec3.create();
    this.operatorCurosrLineDash = [2, 2];
    this.operatorCurosrLineDashScaled = [0, 0];
    this.operatorCurosrLineDashNone = [];
    this.createLatticePoints();
  }
  isAvailable(ctx) {
    return ctx.currentLayer != null && Layer.isEditTarget(ctx.currentLayer);
  }
  onActivated(ctx) {
    this.latticeState = 0;
    this.mouseOver_SelectedLatticePart = 0;
    const available = this.prepareLatticePoints(ctx);
    if (available) {
      this.latticeState = 1;
    } else {
      this.latticeState = 0;
    }
  }
  prepareModal(e, ctx) {
    this.clearEditData();
    this.latticeState = 0;
    this.transformLockType = 0;
    this.transformModifyType = 0;
    if (!this.checkTarget(ctx)) {
      return false;
    }
    if (this.latticePoints == null) {
      this.createLatticePoints();
    }
    vec3.copy(this.mouseAnchorLocation, e.location);
    const available = this.prepareLatticePoints(ctx);
    if (!available) {
      this.latticeState = 0;
      return false;
    }
    ctx.tool.updateOperationOriginByPoints(this.latticePoints);
    this.latticeState = 1;
    this.setLatticeLocation(ctx);
    this.selectTransformCalculator(ctx);
    this.prepareEditData(ctx);
    this.prepareModalExt(ctx);
    return this.existsEditData();
  }
  createLatticePoints() {
    this.latticePoints = [];
    for (let i = 0; i < this.latticePointCount; i++) {
      this.latticePoints.push(new LatticePoint());
    }
    this.latticeEdges = [];
    for (let i = 0; i < this.latticePoints.length; i++) {
      const edge = new LatticeEdge();
      edge.partIndex = i;
      edge.pointIndexFrom = i;
      edge.pointIndexTo = (i + 1) % this.latticePoints.length;
      edge.latticePointFrom = this.latticePoints[edge.pointIndexFrom];
      edge.latticePointTo = this.latticePoints[edge.pointIndexTo];
      this.latticeEdges.push(edge);
    }
  }
  setLatticePointsByRectangle(bound_area, inner_area) {
    vec3.set(this.latticePoints[0].baseLocation, inner_area.left, inner_area.top, 0);
    vec3.set(this.latticePoints[1].baseLocation, inner_area.right, inner_area.top, 0);
    vec3.set(this.latticePoints[2].baseLocation, inner_area.right, inner_area.bottom, 0);
    vec3.set(this.latticePoints[3].baseLocation, inner_area.left, inner_area.bottom, 0);
    const leftBound_offset = bound_area.left - inner_area.left;
    const topBound_offset = bound_area.top - inner_area.top;
    const rightBound_offset = bound_area.right - inner_area.right;
    const bottomBound_offset = bound_area.bottom - inner_area.bottom;
    vec3.set(this.latticePoints[0].displayBaseLocationOffset, leftBound_offset, topBound_offset, 0);
    vec3.set(this.latticePoints[1].displayBaseLocationOffset, rightBound_offset, topBound_offset, 0);
    vec3.set(this.latticePoints[2].displayBaseLocationOffset, rightBound_offset, bottomBound_offset, 0);
    vec3.set(this.latticePoints[3].displayBaseLocationOffset, leftBound_offset, bottomBound_offset, 0);
    this.resetLatticePointLocationToBaseLocation();
  }
  setLatticePointOffsetsByRectangle() {
    vec3.set(this.latticePoints[0].displayOffset, -1, -1, 0);
    vec3.set(this.latticePoints[1].displayOffset, 1, -1, 0);
    vec3.set(this.latticePoints[2].displayOffset, 1, 1, 0);
    vec3.set(this.latticePoints[3].displayOffset, -1, 1, 0);
  }
  resetLatticePointLocationToBaseLocation() {
    for (const latticePoint of this.latticePoints) {
      vec3.copy(latticePoint.location, latticePoint.baseLocation);
    }
  }
  applytLatticePointBaseLocation() {
    for (const latticePoint of this.latticePoints) {
      vec3.copy(latticePoint.baseLocation, latticePoint.location);
    }
  }
  checkTarget(_ctx) {
    return this.transformType != 0;
  }
  prepareLatticePoints(_ctx) {
    this.setLatticePointsByRectangle(this.bound_contentArea, this.inner_contentArea);
    return this.existsEditData();
  }
  setLatticeLocation(ctx) {
    this.setLatticePointOffsetsByRectangle();
    this.resetLatticePointLocationToBaseLocation();
  }
  clearEditData() {
  }
  selectTransformCalculator(_ctx) {
  }
  prepareEditData(_ctx) {
  }
  prepareModalExt(_ctx) {
  }
  existsEditData() {
    return false;
  }
  setLatticeAffineTransform(transformType, ctx) {
    for (const latticePoint of this.latticePoints) {
      latticePoint.latticePointEditType = 3;
    }
    if (transformType == 1) {
      this.transformType = 1;
      this.transformCalculator = this.grabMove_Calculator;
    } else if (transformType == 2) {
      this.transformType = 2;
      this.transformCalculator = this.rotate_Calculator;
    } else if (transformType == 3) {
      this.transformType = 3;
      this.transformCalculator = this.scale_Calculator;
    }
    this.transformCalculator.prepare(ctx);
  }
  startLatticeAffineTransform(transformType, isContinueEdit, ctx) {
    this.setLatticeAffineTransform(transformType, ctx);
    vec3.copy(this.mouseAnchorLocation, ctx.mouseCursorLocation);
    if (isContinueEdit) {
      this.applytLatticePointBaseLocation();
    } else {
      ctx.tool.startModalTool(this.subtoolID);
    }
  }
  startLatticeTransform(ctx) {
    for (const latticePoint of this.latticePoints) {
      latticePoint.latticePointEditType = 0;
    }
    if (this.mouseOver_SelectedLatticePart == 1) {
      let sidePointIndexH = -1;
      let sidePointIndexV = -1;
      if (this.mouseOver_PartIndex == 0) {
        sidePointIndexH = 3;
        sidePointIndexV = 1;
      } else if (this.mouseOver_PartIndex == 1) {
        sidePointIndexH = 2;
        sidePointIndexV = 0;
      } else if (this.mouseOver_PartIndex == 2) {
        sidePointIndexH = 1;
        sidePointIndexV = 3;
      } else if (this.mouseOver_PartIndex == 3) {
        sidePointIndexH = 0;
        sidePointIndexV = 2;
      }
      this.latticePoints[this.mouseOver_PartIndex].latticePointEditType = 3;
      this.latticePoints[sidePointIndexH].latticePointEditType = 1;
      this.latticePoints[sidePointIndexV].latticePointEditType = 2;
      this.transformType = 1;
      this.transformCalculator = this.grabMove_Calculator;
      this.latticeState = 1;
      this.transformCalculator.prepare(ctx);
      ctx.tool.startModalTool(this.subtoolID);
    } else if (this.mouseOver_SelectedLatticePart == 2) {
      let latticePointEditType;
      if (this.mouseOver_PartIndex == 0 || this.mouseOver_PartIndex == 2) {
        latticePointEditType = 2;
      } else {
        latticePointEditType = 1;
      }
      this.latticePoints[this.mouseOver_PartIndex].latticePointEditType = latticePointEditType;
      this.latticePoints[this.mouseOver_PartIndexTo].latticePointEditType = latticePointEditType;
      this.transformType = 1;
      this.transformCalculator = this.grabMove_Calculator;
      this.latticeState = 1;
      this.transformCalculator.prepare(ctx);
      ctx.tool.startModalTool(this.subtoolID);
    }
  }
  endTransform(ctx) {
    this.processTransform(ctx);
    this.executeCommand(ctx);
    this.transformType = 0;
    this.transformCalculator = null;
    ctx.tool.endModalTool();
  }
  cancelTransform(ctx) {
    this.transformType = 0;
    this.transformCalculator = null;
    ctx.tool.cancelModalTool();
  }
  mouseDown(e, ctx) {
    if (!ctx.tool.isModalToolRunning() && e.isLeftButtonPressing) {
      this.processMouseOver(e, ctx);
      this.startLatticeTransform(ctx);
    } else {
      if (e.isRightButtonPressing) {
        this.cancelTransform(ctx);
      }
    }
  }
  mouseMove(e, ctx) {
    if (ctx.tool.isModalToolRunning()) {
      this.processLatticePointMouseMove(ctx);
      this.processTransform(ctx);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else {
      this.processMouseOver(e, ctx);
      ctx.setRedrawEditorWindow();
    }
  }
  processMouseOver(e, ctx) {
    this.mouseOver_SelectedLatticePart = 0;
    this.mouseOver_PartIndex = -1;
    this.mouseOver_PartIndexTo = -1;
    for (const edge of this.latticeEdges) {
      edge.mouseOver = false;
    }
    const hitedPointIndex = this.getMouseOverLatticePointIndex(e, ctx);
    if (hitedPointIndex != -1) {
      this.mouseOver_SelectedLatticePart = 1;
      this.mouseOver_PartIndex = hitedPointIndex;
    } else {
      const hitedEdge = this.getMouseOverLatticeEdgeIndex(e, ctx);
      if (hitedEdge != null) {
        this.mouseOver_SelectedLatticePart = 2;
        this.mouseOver_PartIndex = hitedEdge.pointIndexFrom;
        this.mouseOver_PartIndexTo = hitedEdge.pointIndexTo;
        if (this.allEdgeSelection) {
          for (const edge of this.latticeEdges) {
            edge.mouseOver = true;
          }
        } else {
          hitedEdge.mouseOver = true;
        }
      }
    }
  }
  getMouseOverLatticePointIndex(e, ctx) {
    let resultIndex = -1;
    const scaledHitRadius = ctx.getViewScaledLength(ctx.drawStyle.latticePointHitRadius);
    for (let index2 = 0; index2 < this.latticePoints.length; index2++) {
      const latticePoint = this.latticePoints[index2];
      const distance = vec3.distance(latticePoint.displayLocation, e.location);
      if (distance <= scaledHitRadius) {
        resultIndex = index2;
        break;
      }
    }
    return resultIndex;
  }
  getMouseOverLatticeEdgeIndex(e, ctx) {
    let hitedEdge = null;
    const scaledHitRadius = ctx.getViewScaledLength(ctx.drawStyle.latticePointHitRadius);
    for (const edge of this.latticeEdges) {
      const distance = Logic_Points.pointToLineSegment_SorroundingDistance(
        edge.latticePointFrom.displayLocation,
        edge.latticePointTo.displayLocation,
        e.location
      );
      if (distance <= scaledHitRadius) {
        hitedEdge = edge;
        break;
      }
    }
    return hitedEdge;
  }
  keydown(key, commandID, ctx) {
    if (!ctx.tool.isModalToolRunning()) {
      if (ctx.isShiftKeyPressing()) {
        if (commandID == ShortcutCommandID.edit_grabMove) {
          this.startLatticeAffineTransform(1, false, ctx);
          return true;
        }
        if (commandID == ShortcutCommandID.edit_rotate) {
          this.startLatticeAffineTransform(2, false, ctx);
          return true;
        }
        if (commandID == ShortcutCommandID.edit_scale) {
          this.startLatticeAffineTransform(3, false, ctx);
          return true;
        }
      }
    } else {
      if (commandID == ShortcutCommandID.edit_fix) {
        this.endTransform(ctx);
        return true;
      }
      if (commandID == ShortcutCommandID.edit_cancel) {
        this.cancelTransform(ctx);
        return true;
      }
      if (this.handleKeyDownForTransformModifying({
        g: true,
        r: true,
        s: true,
        x: true,
        y: true,
        zero: true,
        one: true,
        shift: true,
        key,
        ctx
      })) {
        return true;
      }
    }
    return false;
  }
  handleKeyDownForTransformModifying({
    g = false,
    r: r2 = false,
    s = false,
    x: x2 = false,
    y: y2 = false,
    zero = false,
    one = false,
    shift = false,
    key,
    ctx
  }) {
    if (g && key == "g") {
      this.startLatticeAffineTransform(1, true, ctx);
      return true;
    } else if (r2 && key == "r") {
      this.startLatticeAffineTransform(2, true, ctx);
      return true;
    } else if (s && key == "s") {
      this.startLatticeAffineTransform(3, true, ctx);
      return true;
    } else if (x2 && key == "x") {
      if (this.transformLockType != 1) {
        this.transformLockType = 1;
      } else {
        this.transformLockType = 0;
      }
      this.processLatticePointMouseMove(ctx);
      this.processTransform(ctx);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else if (y2 && key == "y") {
      if (this.transformLockType != 2) {
        this.transformLockType = 2;
      } else {
        this.transformLockType = 0;
      }
      this.processLatticePointMouseMove(ctx);
      this.processTransform(ctx);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else if (zero && key == "0") {
      if (this.transformModifyType != 1) {
        this.transformModifyType = 1;
      } else {
        this.transformModifyType = 0;
      }
      this.processLatticePointMouseMove(ctx);
      this.processTransform(ctx);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else if (one && key == "1") {
      if (this.transformModifyType != 3) {
        this.transformModifyType = 3;
      } else {
        this.transformModifyType = 0;
      }
      this.processLatticePointMouseMove(ctx);
      this.processTransform(ctx);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else if (shift && key == "Shift") {
      if (this.transformModifyType != 2) {
        this.transformModifyType = 2;
      } else {
        this.transformModifyType = 0;
      }
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    }
    return false;
  }
  mouseUp(e, ctx) {
    if (ctx.tool.isModalToolRunning()) {
      if (e.isLeftButtonReleased) {
        if (this.latticeState == 2) {
          this.endTransform(ctx);
        }
      }
    }
  }
  processLatticePointMouseMove(ctx) {
    this.transformCalculator.transformLockType = this.transformLockType;
    this.transformCalculator.transformModifyType = this.transformModifyType;
    this.transformCalculator.processLatticePointMouseMove(this.latticePoints, ctx);
    this.latticeState = 2;
  }
  processTransform(_ctx) {
  }
  executeCommand(_ctx) {
  }
  onDrawEditor(ctx, drawing) {
    if (this.latticeState == 0) {
      return;
    }
    if (this.latticeState == 1) {
      this.setLatticeLocation(ctx);
    }
    this.calculateLatticeRectangleDisplayLocation(ctx);
    this.drawLatticeRectangle(ctx, drawing);
    this.drawLatticePoints(ctx, drawing);
  }
  drawLatticeRectangle(ctx, drawing) {
    if (this.latticePoints == null) {
      return;
    }
    drawing.render.setStrokeColorV(drawing.style.modalToolSelectedAreaLineColor);
    drawing.render.setStrokeWidth(ctx.getViewScaledLength(1));
    const viewScale = ctx.getViewScaledLength(1);
    this.operatorCurosrLineDashScaled[0] = this.operatorCurosrLineDash[0] * viewScale;
    this.operatorCurosrLineDashScaled[1] = this.operatorCurosrLineDash[1] * viewScale;
    drawing.render.setStrokeColorV(drawing.style.modalToolSelectedAreaLineColor);
    for (const edge of this.latticeEdges) {
      if (edge.mouseOver) {
        drawing.render.setStrokeWidth(ctx.getViewScaledLength(3));
        drawing.render.setLineDash(this.operatorCurosrLineDashNone);
      } else {
        drawing.render.setStrokeWidth(ctx.getViewScaledLength(1));
        drawing.render.setLineDash(this.operatorCurosrLineDashScaled);
      }
      drawing.render.beginPath();
      drawing.render.moveToV(edge.latticePointFrom.displayLocation);
      drawing.render.lineToV(edge.latticePointTo.displayLocation);
      drawing.render.stroke();
    }
    drawing.render.setLineDash(this.operatorCurosrLineDashNone);
  }
  drawLatticePoints(ctx, drawing) {
    for (const latticePoint of this.latticePoints) {
      this.drawLatticePoint(latticePoint, 1, ctx, drawing);
    }
    if (this.mouseOver_SelectedLatticePart == 1) {
      const latticePoint = this.latticePoints[this.mouseOver_PartIndex];
      this.drawLatticePoint(latticePoint, 3, ctx, drawing);
    }
  }
  drawLatticePoint(latticePoint, lineWidth, ctx, drawing) {
    drawing.render.beginPath();
    drawing.render.setStrokeColorV(drawing.style.modalToolSelectedAreaLineColor);
    drawing.render.setStrokeWidth(ctx.getViewScaledLength(lineWidth));
    drawing.render.circle(
      latticePoint.displayLocation[0],
      latticePoint.displayLocation[1],
      ctx.getViewScaledLength(drawing.style.latticePointRadius)
    );
    drawing.render.stroke();
  }
  calculateLatticeRectangleDisplayLocation(ctx) {
    const paddingScale = ctx.getViewScaledLength(ctx.drawStyle.latticePointPadding);
    const angle = this.calculateLatticeRectangleAngle(this.dLocation);
    mat4.identity(this.offsetMatrix);
    mat4.rotateZ(this.offsetMatrix, this.offsetMatrix, angle);
    for (const latticePoint of this.latticePoints) {
      vec3.set(
        this.offsetScale,
        latticePoint.displayBaseLocationOffset[0] + latticePoint.displayOffset[0] * paddingScale,
        latticePoint.displayBaseLocationOffset[1] + latticePoint.displayOffset[1] * paddingScale,
        0
      );
      vec3.transformMat4(this.offset, this.offsetScale, this.offsetMatrix);
      vec3.add(latticePoint.displayLocation, latticePoint.location, this.offset);
    }
  }
  calculateLatticeRectangleAngle(outDirection) {
    vec3.subtract(outDirection, this.latticePoints[1].location, this.latticePoints[0].location);
    const angle = Math.atan2(outDirection[1], outDirection[0]);
    return angle;
  }
  calculateLatticeRectangleWidth(outDirection) {
    vec3.subtract(outDirection, this.latticePoints[0].location, this.latticePoints[1].location);
    const length = vec3.length(outDirection);
    return length;
  }
  calculateLatticeRectangleHeight(outDirection) {
    vec3.subtract(outDirection, this.latticePoints[0].location, this.latticePoints[3].location);
    const length = vec3.length(outDirection);
    return length;
  }
  existsLatticeRectangleArea() {
    return this.bound_contentArea.isValidArea();
  }
}
class GrabMove_Calculator {
  constructor() {
    this.transformLockType = 0;
    this.transformModifyType = 0;
    this.integerValueOnly = false;
    this.lastLocation = vec3.create();
    this.moveAmount = vec3.create();
    this.dLocation = vec3.create();
  }
  prepare(ctx) {
    vec3.copy(this.lastLocation, ctx.mouseCursorLocation);
    vec3.set(this.moveAmount, 0, 0, 0);
  }
  processLatticePointMouseMove(latticePoints, ctx) {
    vec3.subtract(this.dLocation, ctx.mouseCursorLocation, this.lastLocation);
    if (this.transformModifyType == 2) {
      vec3.scale(this.dLocation, this.dLocation, 0.25);
    }
    vec3.add(this.moveAmount, this.moveAmount, this.dLocation);
    vec3.copy(this.lastLocation, ctx.mouseCursorLocation);
    for (const latticePoint of latticePoints) {
      let moveAmountX = 0;
      let moveAmountY = 0;
      if (latticePoint.latticePointEditType == 1) {
        moveAmountX = this.moveAmount[0];
      } else if (latticePoint.latticePointEditType == 2) {
        moveAmountY = this.moveAmount[1];
      } else if (latticePoint.latticePointEditType == 3) {
        if (this.transformLockType != 2) {
          moveAmountX = this.moveAmount[0];
        }
        if (this.transformLockType != 1) {
          moveAmountY = this.moveAmount[1];
        }
      }
      latticePoint.location[0] = latticePoint.baseLocation[0] + moveAmountX;
      latticePoint.location[1] = latticePoint.baseLocation[1] + moveAmountY;
      if (this.integerValueOnly) {
        latticePoint.location[0] = Math.floor(latticePoint.location[0]);
        latticePoint.location[1] = Math.floor(latticePoint.location[1]);
      }
    }
  }
}
class Rotate_Calculator {
  constructor() {
    this.transformModifyType = 0;
    this.lastAngle = 0;
    this.rotationAmount = 0;
    this.dLocation = vec3.create();
    this.direction = vec3.create();
    this.centerLocation = vec3.create();
    this.rotationMatrix = mat4.create();
  }
  prepare(ctx) {
    this.lastAngle = this.calulateInputAngle(ctx);
    this.rotationAmount = 0;
  }
  calulateInputAngle(ctx) {
    vec3.subtract(this.direction, ctx.mouseCursorLocation, ctx.getOperationOriginLocation());
    const angle = Math.atan2(this.direction[1], this.direction[0]);
    return angle;
  }
  processLatticePointMouseMove(latticePoints, ctx) {
    const inputedAngle = this.calulateInputAngle(ctx);
    let movedAngle = inputedAngle - this.lastAngle;
    if (movedAngle >= Math.PI) {
      movedAngle -= Math.PI * 2;
    }
    if (movedAngle <= -Math.PI) {
      movedAngle += Math.PI * 2;
    }
    if (this.transformModifyType == 2) {
      movedAngle *= 0.25;
    }
    this.rotationAmount += movedAngle;
    this.lastAngle = inputedAngle;
    vec3.copy(this.centerLocation, ctx.getOperationOriginLocation());
    vec3.scale(this.dLocation, this.centerLocation, -1);
    mat4.identity(this.rotationMatrix);
    mat4.translate(this.rotationMatrix, this.rotationMatrix, this.centerLocation);
    mat4.rotateZ(this.rotationMatrix, this.rotationMatrix, this.rotationAmount);
    mat4.translate(this.rotationMatrix, this.rotationMatrix, this.dLocation);
    for (const latticePoint of latticePoints) {
      vec3.transformMat4(latticePoint.location, latticePoint.baseLocation, this.rotationMatrix);
    }
  }
}
class Scale_Calculator {
  constructor() {
    this.transformModifyType = 0;
    this.integerValueOnly = false;
    this.initialDistance = 0;
    this.lastDistance = 0;
    this.scalingAmount = 0;
    this.dLocation = vec3.create();
    this.direction = vec3.create();
    this.centerLocation = vec3.create();
    this.rotationMatrix = mat4.create();
    this.scaling = vec3.create();
  }
  prepare(ctx) {
    this.initialDistance = this.calulateDistance(ctx);
    if (this.initialDistance == 0) {
      this.initialDistance = 1;
    }
    this.lastDistance = this.initialDistance;
    this.scalingAmount = 1;
  }
  calulateDistance(ctx) {
    vec3.subtract(this.direction, ctx.mouseCursorLocation, ctx.getOperationOriginLocation());
    const distance = vec3.length(this.direction);
    return distance;
  }
  processLatticePointMouseMove(latticePoints, ctx) {
    if (latticePoints.length == 0) {
      return;
    }
    const distance = this.calulateDistance(ctx);
    let movedDistance = distance - this.lastDistance;
    if (this.transformModifyType == 2) {
      movedDistance *= 0.25;
    }
    this.scalingAmount += movedDistance / this.initialDistance;
    this.lastDistance = distance;
    vec3.set(this.scaling, 1, 1, 1);
    const scale = this.scalingAmount;
    const firstLatticePoint = latticePoints[0];
    if (firstLatticePoint.latticePointEditType == 1) {
      this.scaling[0] = scale;
    } else if (firstLatticePoint.latticePointEditType == 2) {
      this.scaling[1] = scale;
    } else if (firstLatticePoint.latticePointEditType == 3) {
      if (this.transformLockType == 0) {
        vec3.set(this.scaling, scale, scale, 1);
      } else if (this.transformLockType == 1) {
        if (this.transformModifyType == 1) {
          vec3.set(this.scaling, 0, 1, 1);
        } else {
          vec3.set(this.scaling, scale, 1, 1);
        }
      } else if (this.transformLockType == 2) {
        if (this.transformModifyType == 1) {
          vec3.set(this.scaling, 1, 0, 1);
        } else {
          vec3.set(this.scaling, 1, scale, 1);
        }
      }
    }
    vec3.copy(this.centerLocation, ctx.getOperationOriginLocation());
    vec3.scale(this.dLocation, this.centerLocation, -1);
    mat4.identity(this.rotationMatrix);
    mat4.translate(this.rotationMatrix, this.rotationMatrix, this.centerLocation);
    mat4.scale(this.rotationMatrix, this.rotationMatrix, this.scaling);
    mat4.translate(this.rotationMatrix, this.rotationMatrix, this.dLocation);
    for (const latticePoint of latticePoints) {
      vec3.transformMat4(latticePoint.location, latticePoint.baseLocation, this.rotationMatrix);
    }
  }
}
class Tool_EditDocumentFrame extends Tool_Transform_Lattice {
  constructor() {
    super(...arguments);
    this.helpText = "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u7BC4\u56F2\u3092\u8A2D\u5B9A\u3057\u307E\u3059\u3002\u5EA7\u6A19\u306F\u6574\u6570\u5024\u306B\u306A\u308A\u307E\u3059\u3002";
  }
  isAvailable(_ctx) {
    return true;
  }
  checkTarget(_ctx) {
    return true;
  }
  prepareLatticePoints(ctx) {
    this.bound_contentArea.left = ctx.documentData.documentFrame[0];
    this.bound_contentArea.top = ctx.documentData.documentFrame[1];
    this.bound_contentArea.right = ctx.documentData.documentFrame[2];
    this.bound_contentArea.bottom = ctx.documentData.documentFrame[3];
    this.setLatticePointsByRectangle(this.bound_contentArea, this.bound_contentArea);
    this.grabMove_Calculator.integerValueOnly = true;
    return this.existsLatticeRectangleArea();
  }
  existsEditData() {
    return this.existsLatticeRectangleArea();
  }
  keydown(key, commandID, ctx) {
    if (!ctx.tool.isModalToolRunning()) {
      if (commandID == ShortcutCommandID.edit_grabMove) {
        this.startLatticeAffineTransform(TransformType.grabMove, false, ctx);
        return true;
      }
      if (commandID == ShortcutCommandID.edit_scale) {
        this.startLatticeAffineTransform(TransformType.scale, false, ctx);
        return true;
      }
    } else {
      if (this.handleKeyDownForTransformModifying({ g: true, s: true, shift: true, key, ctx })) {
        return true;
      }
    }
    return false;
  }
  executeCommand(ctx) {
    const command = new Command_EditDocumentFrame();
    command.targetDocument = ctx.documentData;
    command.newDocumentFrame[0] = Math.floor(this.latticePoints[0].location[0]);
    command.newDocumentFrame[1] = Math.floor(this.latticePoints[0].location[1]);
    command.newDocumentFrame[2] = Math.floor(this.latticePoints[2].location[0]);
    command.newDocumentFrame[3] = Math.floor(this.latticePoints[2].location[1]);
    ctx.commandHistory.executeCommand(command, ctx);
  }
}
class Command_EditDocumentFrame extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetDocument = null;
    this.newDocumentFrame = vec4.create();
    this.oldDocumentFrame = vec4.create();
  }
  execute(ctx) {
    this.errorCheck();
    vec4.copy(this.oldDocumentFrame, this.targetDocument.documentFrame);
    this.redo(ctx);
  }
  undo(ctx) {
    vec4.copy(this.targetDocument.documentFrame, this.oldDocumentFrame);
    ctx.setRedrawRibbonUI();
  }
  redo(ctx) {
    vec4.copy(this.targetDocument.documentFrame, this.newDocumentFrame);
    ctx.setRedrawRibbonUI();
  }
  errorCheck() {
    if (this.targetDocument == null) {
      throw new Error("ERROR 0801:Command_EditDocumentFrame: targetDocument is null!");
    }
  }
}
class Tool_Transform_ReferenceImage extends Tool_Transform_Lattice {
  constructor() {
    super(...arguments);
    this.allEdgeSelection = true;
    this.imageSize = vec3.create();
    this.pointLocation = vec3.create();
    this.transformMatrix = mat4.create();
    this.dLocation = vec3.create();
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerImageFileReferenceLayer();
  }
  checkTarget(ctx) {
    return ctx.isCurrentLayerImageFileReferenceLayer();
  }
  prepareLatticePoints(ctx) {
    if (!ImageFileReferenceLayer.isLoaded(ctx.currentImageFileReferenceLayer)) {
      return false;
    }
    this.calculateImageLatticePoints(
      ctx.currentImageFileReferenceLayer.runtime.imageResource.image,
      ctx.currentImageFileReferenceLayer.location,
      ctx.currentImageFileReferenceLayer.rotation,
      ctx.currentImageFileReferenceLayer.scale
    );
    return this.existsLatticeRectangleArea();
  }
  calculateImageLatticePoints(image, location, rotation, scaling) {
    mat4.identity(this.transformMatrix);
    mat4.translate(this.transformMatrix, this.transformMatrix, location);
    const angle = rotation[0];
    mat4.rotateZ(this.transformMatrix, this.transformMatrix, angle);
    vec3.set(this.imageSize, image.width, image.height, 0);
    mat4.scale(this.transformMatrix, this.transformMatrix, this.imageSize);
    mat4.scale(this.transformMatrix, this.transformMatrix, scaling);
    vec3.set(this.pointLocation, 0, 0, 0);
    vec3.transformMat4(this.latticePoints[0].baseLocation, this.pointLocation, this.transformMatrix);
    vec3.set(this.pointLocation, 1, 0, 0);
    vec3.transformMat4(this.latticePoints[1].baseLocation, this.pointLocation, this.transformMatrix);
    vec3.set(this.pointLocation, 1, 1, 0);
    vec3.transformMat4(this.latticePoints[2].baseLocation, this.pointLocation, this.transformMatrix);
    vec3.set(this.pointLocation, 0, 1, 0);
    vec3.transformMat4(this.latticePoints[3].baseLocation, this.pointLocation, this.transformMatrix);
  }
  prepareEditData(_ctx) {
    for (const latticePoint of this.latticePoints) {
      latticePoint.latticePointEditType = LatticePointEditTypeID.allDirection;
    }
  }
  existsEditData() {
    return this.existsLatticeRectangleArea();
  }
  processTransform(ctx) {
    const ifrLayer = ctx.currentImageFileReferenceLayer;
    const image = ifrLayer.runtime.imageResource.image;
    if (this.transformModifyType == TransformModifyType.one) {
      if (this.transformType == TransformType.grabMove) {
        ifrLayer.runtime.adjustingLocation[0] = -ifrLayer.runtime.imageResource.image.width / 2;
        ifrLayer.runtime.adjustingLocation[1] = -ifrLayer.runtime.imageResource.image.height / 2;
      } else if (this.transformType == TransformType.rotate) {
        ifrLayer.runtime.adjustingRotation[0] = 0;
      } else if (this.transformType == TransformType.scale) {
        vec3.set(ifrLayer.runtime.adjustingScale, 1, 1, 1);
      }
      this.calculateImageLatticePoints(
        ctx.currentImageFileReferenceLayer.runtime.imageResource.image,
        ctx.currentImageFileReferenceLayer.runtime.adjustingLocation,
        ctx.currentImageFileReferenceLayer.runtime.adjustingRotation,
        ctx.currentImageFileReferenceLayer.runtime.adjustingScale
      );
      this.resetLatticePointLocationToBaseLocation();
      this.transformModifyType = TransformModifyType.none;
      return;
    }
    vec3.copy(ifrLayer.runtime.adjustingLocation, this.latticePoints[0].location);
    const scaleX = this.calculateLatticeRectangleWidth(this.dLocation) / image.width;
    const scaleY = this.calculateLatticeRectangleHeight(this.dLocation) / image.height;
    vec3.set(ifrLayer.runtime.adjustingScale, scaleX, scaleY, 0);
    const angle = this.calculateLatticeRectangleAngle(this.dLocation);
    ifrLayer.runtime.adjustingRotation[0] = angle;
  }
  executeCommand(ctx) {
    const ifrLayer = ctx.currentImageFileReferenceLayer;
    const command = new Command_Transform_ReferenceImage();
    command.targetLayer = ifrLayer;
    vec3.copy(command.newLocation, command.targetLayer.runtime.adjustingLocation);
    vec3.copy(command.newRotation, command.targetLayer.runtime.adjustingRotation);
    vec3.copy(command.newScale, command.targetLayer.runtime.adjustingScale);
    ctx.commandHistory.executeCommand(command, ctx);
  }
  cancelModal(ctx) {
    const ifrLayer = ctx.currentImageFileReferenceLayer;
    vec3.copy(ifrLayer.runtime.adjustingLocation, ifrLayer.location);
    vec3.copy(ifrLayer.runtime.adjustingRotation, ifrLayer.rotation);
    vec3.copy(ifrLayer.runtime.adjustingScale, ifrLayer.scale);
    ctx.setRedrawMainWindowEditorWindow();
  }
}
class Command_Transform_ReferenceImage extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLayer = null;
    this.newLocation = vec3.fromValues(0, 0, 0);
    this.newRotation = vec3.fromValues(0, 0, 0);
    this.newScale = vec3.fromValues(1, 1, 1);
    this.oldLocation = vec3.fromValues(0, 0, 0);
    this.oldRotation = vec3.fromValues(0, 0, 0);
    this.oldScale = vec3.fromValues(1, 1, 1);
  }
  execute(ctx) {
    this.errorCheck();
    vec3.copy(this.oldLocation, this.targetLayer.location);
    vec3.copy(this.oldRotation, this.targetLayer.rotation);
    vec3.copy(this.oldScale, this.targetLayer.scale);
    this.redo(ctx);
  }
  undo(_ctx) {
    vec3.copy(this.targetLayer.location, this.oldLocation);
    vec3.copy(this.targetLayer.rotation, this.oldRotation);
    vec3.copy(this.targetLayer.scale, this.oldScale);
  }
  redo(_ctx) {
    vec3.copy(this.targetLayer.location, this.newLocation);
    vec3.copy(this.targetLayer.rotation, this.newRotation);
    vec3.copy(this.targetLayer.scale, this.newScale);
  }
  errorCheck() {
    if (this.targetLayer == null) {
      throw new Error("ERROR 0901:Command_LoadReferenceImageToLayer: layer is null!");
    }
  }
}
class Tool_Transform_ReferenceImage_GrabMove extends Tool_Transform_ReferenceImage {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.grabMove, ctx);
  }
}
class Tool_Transform_ReferenceImage_Rotate extends Tool_Transform_ReferenceImage {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.rotate, ctx);
  }
}
class Tool_Transform_ReferenceImage_Scale extends Tool_Transform_ReferenceImage {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.scale, ctx);
  }
}
class EditPoint {
  constructor() {
    this.targetPoint = null;
    this.relativeLocation = vec3.fromValues(0, 0, 0);
    this.newLocation = vec3.fromValues(0, 0, 0);
    this.oldLocation = vec3.fromValues(0, 0, 0);
  }
}
class Tool_Transform_Lattice_StrokePoint extends Tool_Transform_Lattice {
  constructor() {
    super(...arguments);
    this.lerpLocation1 = vec3.create();
    this.lerpLocation2 = vec3.create();
    this.lerpLocation3 = vec3.create();
    this.viewKeyframeLayers = null;
    this.targetGroups = null;
    this.targetStrokes = null;
    this.editPoints = null;
  }
  clearEditData() {
    this.targetGroups = null;
    this.targetStrokes = null;
    this.editPoints = null;
  }
  checkTarget(ctx) {
    return ctx.isCurrentLayerEditbaleLayer();
  }
  prepareLatticePoints(ctx) {
    this.bound_contentArea.setMinimumValue();
    this.inner_contentArea.setMinimumValue();
    const parStroke = ctx.operationUnitID == OperationUnitID.stroke;
    this.viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    ViewKeyframeLayer.forEachStrokeGroup(this.viewKeyframeLayers, (group, layer) => {
      for (const stroke of group.lines) {
        if (parStroke) {
          if (stroke.isSelected) {
            this.bound_contentArea.expandByRectangle(stroke.runtime.area);
            this.inner_contentArea.expandByRectangle(stroke.runtime.innerArea);
          }
        } else {
          for (const point of stroke.points) {
            if (!point.isSelected) {
              continue;
            }
            VectorStrokeLogic.expandAreasForPoint(
              this.bound_contentArea,
              this.inner_contentArea,
              point,
              layer.lineWidthBiasRate
            );
          }
        }
      }
    });
    this.setLatticePointsByRectangle(this.bound_contentArea, this.inner_contentArea);
    return this.existsLatticeRectangleArea();
  }
  prepareEditData(ctx) {
    const targetGroups = [];
    const targetStrokes = [];
    const editPoints = [];
    const parSteoke = ctx.operationUnitID == OperationUnitID.stroke;
    ViewKeyframeLayer.forEachStrokeGroup(this.viewKeyframeLayers, (group, layer) => {
      let existsInGroup = false;
      for (const stroke of group.lines) {
        let existsInLine = false;
        for (const point of stroke.points) {
          if (!(point.isSelected || parSteoke && stroke.isSelected)) {
            continue;
          }
          const editPoint = new EditPoint();
          editPoint.targetPoint = point;
          vec3.copy(editPoint.oldLocation, point.location);
          vec3.copy(editPoint.newLocation, point.location);
          const xPosition = this.inner_contentArea.getHorizontalPositionRate(point.location[0]);
          const yPosition = this.inner_contentArea.getVerticalPositionRate(point.location[1]);
          vec3.set(editPoint.relativeLocation, xPosition, yPosition, 0);
          editPoints.push(editPoint);
          existsInLine = true;
        }
        if (existsInLine) {
          targetStrokes.push({ stroke, layer });
          existsInGroup = true;
        }
      }
      if (existsInGroup) {
        targetGroups.push({ group, layer });
      }
    });
    this.targetGroups = targetGroups;
    this.targetStrokes = targetStrokes;
    this.editPoints = editPoints;
  }
  existsEditData() {
    return this.editPoints.length > 0;
  }
  cancelModal(ctx) {
    for (const editPoint of this.editPoints) {
      vec3.copy(editPoint.targetPoint.adjustingLocation, editPoint.targetPoint.location);
    }
    this.editPoints = null;
    ctx.setRedrawMainWindowEditorWindow();
  }
  processTransform(_ctx) {
    if (this.editPoints == null) {
      return;
    }
    const editPoints = this.editPoints;
    const latticePoints = this.latticePoints;
    const latticePointLocationH1A = latticePoints[0].location;
    const latticePointLocationH1B = latticePoints[1].location;
    const latticePointLocationH2A = latticePoints[3].location;
    const latticePointLocationH2B = latticePoints[2].location;
    for (const editPoint of editPoints) {
      vec3.lerp(this.lerpLocation1, latticePointLocationH1A, latticePointLocationH1B, editPoint.relativeLocation[0]);
      vec3.lerp(this.lerpLocation2, latticePointLocationH2A, latticePointLocationH2B, editPoint.relativeLocation[0]);
      vec3.lerp(editPoint.targetPoint.adjustingLocation, this.lerpLocation1, this.lerpLocation2, editPoint.relativeLocation[1]);
    }
  }
  executeCommand(ctx) {
    if (this.editPoints.length == 0) {
      return;
    }
    for (const editPoint of this.editPoints) {
      vec3.copy(editPoint.newLocation, editPoint.targetPoint.adjustingLocation);
    }
    const command = new Command_TransformLattice_LinePoint();
    command.editPoints = this.editPoints;
    command.targetStrokes = this.targetStrokes;
    for (const targetGroup of this.targetGroups) {
      command.defferedProcess.addGroup(targetGroup.layer, targetGroup.group, PostUpdateSituationTypeID.changesObjectShapes);
    }
    ctx.commandHistory.executeCommand(command, ctx);
    this.editPoints = null;
  }
}
class Command_TransformLattice_LinePoint extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetStrokes = null;
    this.editPoints = null;
  }
  execute(ctx) {
    this.errorCheck();
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editPoint of this.editPoints) {
      vec3.copy(editPoint.targetPoint.location, editPoint.oldLocation);
      vec3.copy(editPoint.targetPoint.adjustingLocation, editPoint.oldLocation);
    }
    this.updateRelatedObjects();
  }
  redo(_ctx) {
    for (const editPoint of this.editPoints) {
      vec3.copy(editPoint.targetPoint.location, editPoint.newLocation);
      vec3.copy(editPoint.targetPoint.adjustingLocation, editPoint.newLocation);
    }
    this.updateRelatedObjects();
  }
  errorCheck() {
    if (this.targetStrokes == null) {
      throw new Error("ERROR 1003:Command_TransformLattice: line is null!");
    }
    if (this.editPoints.length == 0) {
      throw new Error("ERROR 1004:Command_TransformLattice: no target point!");
    }
  }
  updateRelatedObjects() {
    for (const targetStroke of this.targetStrokes) {
      VectorStrokeLogic.calculateParameters(targetStroke.stroke, targetStroke.layer.lineWidthBiasRate);
    }
  }
}
class Tool_Transform_Lattice_GrabMove extends Tool_Transform_Lattice_StrokePoint {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.grabMove, ctx);
  }
}
class Tool_Transform_Lattice_Rotate extends Tool_Transform_Lattice_StrokePoint {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.rotate, ctx);
  }
}
class Tool_Transform_Lattice_Scale extends Tool_Transform_Lattice_StrokePoint {
  selectTransformCalculator(ctx) {
    this.setLatticeAffineTransform(TransformType.scale, ctx);
  }
}
class Tool_EditModeMain extends Tool_Transform_Lattice_StrokePoint {
  constructor() {
    super(...arguments);
    this.helpText = "\u5DE6\u30AF\u30EA\u30C3\u30AF\u3067\u77E9\u5F62\u306E\u8FBA\u3084\u89D2\u3092\u64CD\u4F5C\u3057\u3066\u3001\u9078\u629E\u4E2D\u306E\u7DDA\u307E\u305F\u306F\u70B9\u3092\u5909\u5F62\u3067\u304D\u307E\u3059\u3002<br />A\u30AD\u30FC\u3067\u5168\u9078\u629E\uFF0F\u89E3\u9664\u3057\u307E\u3059\u3002G\u3001R\u3001S\u30AD\u30FC\u3067\u79FB\u52D5\u3001\u56DE\u8EE2\u3001\u62E1\u7E2E\u3057\u307E\u3059\u3002";
  }
}
class Selector_HideLinePoint_BrushSelect extends Selector_VectorPoint_BrushSelect {
  constructor() {
    super(...arguments);
    this.lineWidth = 0;
  }
  onPointHited(point) {
    if (point.modifyFlag == VectorPointModifyFlagID.none) {
      point.adjustingLineWidth = this.lineWidth;
      this.selectionInfo.editGroup(this.currentStrokeGroup, this.currentGeometry, this.currentLayer);
      this.selectionInfo.editStroke(this.currentStroke);
      this.selectionInfo.editPoint(point);
    }
  }
}
class Tool_HideLinePoint_BrushSelect extends Tool_BrushSelectLinePointBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u7DDA\u306E\u592A\u3055\u306B\u6700\u5927\u306E\u592A\u3055\u306B\u8A2D\u5B9A\u3057\u307E\u3059\u3002<br />Shift\u30AD\u30FC\u3067\u6700\u5C0F\u306E\u592A\u3055\u306B\u8A2D\u5B9A\u3057\u307E\u3059\u3002Ctrl\u30AD\u30FC\u3067\u7DDA\u3092\u306E\u592A\u3055\u3092\uFF10\u306B\u3057\u307E\u3059\u3002";
    this.isEditTool = false;
    this.selector = new Selector_HideLinePoint_BrushSelect();
    this.brushSelector = this.selector;
  }
  onStartSelection(_e, ctx) {
    if (ctx.isShiftKeyPressing()) {
      this.selector.lineWidth = ctx.drawLineMinWidth;
    } else if (ctx.isCtrlKeyPressing()) {
      this.selector.lineWidth = 0;
    } else {
      this.selector.lineWidth = ctx.drawLineBaseWidth;
    }
  }
  executeCommand(ctx) {
    const command = new Command_EditLinePointLineWidth();
    if (command.prepareEditTargets(this.selector.selectionInfo)) {
      ctx.commandHistory.executeCommand(command, ctx);
    }
    ctx.setRedrawMainWindow();
  }
  cancelModal(ctx) {
    for (const selPoint of this.brushSelector.selectionInfo.selectedPoints) {
      selPoint.point.adjustingLineWidth = selPoint.point.lineWidth;
    }
    this.brushSelector.endProcess();
    ctx.setRedrawMainWindowEditorWindow();
  }
}
class Tool_EditLineWidth_EditPoint {
  constructor() {
    this.targetPoint = null;
    this.newLineWidth = 0;
    this.oldLineWidth = 0;
  }
}
class Command_EditLinePointLineWidth extends CommandBase {
  constructor() {
    super(...arguments);
    this.editPoints = [];
  }
  prepareEditTargets(selectionInfo) {
    let editPointCount = 0;
    for (const selPoint of selectionInfo.selectedPoints) {
      const point = selPoint.point;
      const editPoint = new Tool_EditLineWidth_EditPoint();
      editPoint.targetPoint = point;
      editPoint.oldLineWidth = point.lineWidth;
      editPoint.newLineWidth = point.adjustingLineWidth;
      this.editPoints.push(editPoint);
      editPointCount++;
    }
    if (editPointCount > 0) {
      for (const selGroup of selectionInfo.selectedGroups) {
        this.defferedProcess.addGroup(selGroup.layer, selGroup.group, PostUpdateSituationTypeID.changesObjectShapes);
      }
    }
    return editPointCount > 0;
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.targetPoint;
      targetPoint.lineWidth = editPoint.oldLineWidth;
      targetPoint.adjustingLineWidth = targetPoint.lineWidth;
    }
  }
  redo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.targetPoint;
      targetPoint.lineWidth = editPoint.newLineWidth;
      targetPoint.adjustingLineWidth = targetPoint.lineWidth;
    }
  }
}
class Tool_LocateOperatorCursor extends SubTool {
  constructor() {
    super(...arguments);
    this.usesOperatorCursor = true;
  }
  isAvailable(ctx) {
    return true;
  }
  mouseDown(e, ctx) {
    if (e.isLeftButtonPressing && !ctx.isAnyModifierKeyPressing()) {
      ctx.main.setOperatorCursorLocationToMouse();
    }
  }
  mouseMove(e, ctx) {
    this.mouseDown(e, ctx);
  }
}
class Tool_NoOperation extends SubTool {
  isAvailable(ctx) {
    return false;
  }
}
class Tool_Posing3d_ToolBase extends ModalToolBase {
  constructor() {
    super(...arguments);
    this.inputOptionButtonCount = 1;
    this.editPoint = null;
    this.editLine = null;
  }
  getOptionButtonState(_buttonIndex, _ctx) {
    return InputSideID.none;
  }
  getInputData(_ctx) {
    throw new Error("ERROR 1001:Tool_Posing3d_ToolBase: not implemented!");
  }
  copyInputLocationToPoint(e) {
    if (this.editPoint == null) {
      this.editPoint = new VectorPoint();
    }
    vec3.copy(this.editPoint.location, e.location);
  }
  copyInputLocationToLine(e) {
    if (this.editLine == null) {
      this.editLine = new VectorStroke();
    }
    const point = new VectorPoint();
    vec3.copy(point.location, e.location);
    vec3.copy(point.adjustingLocation, e.location);
    this.editLine.points.push(point);
  }
}
class Tool_Posing3d_PointInputToolBase extends Tool_Posing3d_ToolBase {
  constructor() {
    super(...arguments);
    this.tempTargetLocation = vec3.create();
    this.inputOptionButtonCount = 1;
  }
  optionButton_Click(buttonIndex, ctx) {
    if (ctx.currentPosingData != null) {
      const inputData = this.getInputData(ctx);
      if (buttonIndex == 0) {
        if (inputData.inputSideID == InputSideID.front) {
          inputData.inputSideID = InputSideID.back;
        } else {
          inputData.inputSideID = InputSideID.front;
        }
        return true;
      }
    }
    return false;
  }
  getOptionButtonState(_buttonIndex, ctx) {
    if (ctx.currentPosingData != null) {
      const inputData = this.getInputData(ctx);
      return inputData.inputSideID;
    } else {
      return InputSideID.none;
    }
  }
  mouseDown(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.execute(e, ctx);
    ctx.tool.startModalTool(this.subtoolID);
  }
  mouseMove(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    ctx.setRedrawEditorWindow();
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.execute(e, ctx);
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
  }
  execute(e, ctx) {
    const inputData = this.getInputData(ctx);
    ctx.posing3DLogic.calculateInputLocation3D(
      this.tempTargetLocation,
      e.location,
      inputData.inputSideID,
      inputData,
      ctx.currentPosingData,
      ctx.posing3DView
    );
    this.executeCommand(
      this.tempTargetLocation,
      e.location,
      e,
      ctx
    );
  }
  executeCommand(_inputLocation, _inputLocation2D, _e, _ctx) {
    throw new Error("ERROR 1002:Tool_Posing3d_ToolBase: not implemented!");
  }
}
class Tool_Posing3d_LineInputToolBase extends Tool_Posing3d_ToolBase {
  mouseDown(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.editLine = new VectorStroke();
    this.copyInputLocationToLine(e);
    ctx.tool.startModalTool(this.subtoolID);
  }
  mouseMove(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (this.editLine == null) {
      return;
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    ctx.setRedrawEditorWindow();
    this.copyInputLocationToLine(e);
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
    if (ctx.currentPosingData == null) {
      return;
    }
    if (e.isLeftButtonReleased) {
      if (this.editLine == null) {
        return;
      }
      VectorStrokeLogic.calculateParameters(this.editLine);
      if (this.editLine.points.length <= 1 || this.editLine.runtime.totalLength < 1) {
        return;
      }
      this.calculateHeadLoacation(ctx);
      return;
    }
  }
  calculateHeadLoacation(_ctx) {
  }
}
class Tool_Posing3d_JointPartInputToolBase extends Tool_Posing3d_PointInputToolBase {
  constructor() {
    super(...arguments);
    this.enableDirectionInput = true;
    this.enableRollInput = true;
    this.jointPartInputMode = 0;
    this.mouseOnInputMode = 0;
    this.inputLocation = vec3.create();
    this.relativeMouseLocation = vec3.create();
    this.rollInputRelativeLocation = vec3.create();
    this.rollInputCenterLocation = vec3.create();
    this.rollInputLocation = vec3.fromValues(0, 0, 0);
    this.inputAdditionalAngle = 0;
    this.inputStartAngle = 0;
    this.inputEndAngle = 0;
    this.inputStartLocation = vec3.create();
    this.beforeEditMatrix = mat4.create();
    this.beforeEditAngle = 0;
    this.tmpMatrix = mat4.create();
    this.tmpVec3 = vec3.create();
    this.vecZ = vec3.create();
    this.direction = vec3.create();
    this.location3D = vec3.create();
    this.location3DTo = vec3.create();
    this.location2D = vec3.create();
    this.location2DTo = vec3.create();
    this.location2DHead = vec3.create();
    this.partCenterLocation = vec3.create();
    this.rollInputCenterLocation2D = vec3.create();
    this.locationFront = vec3.create();
    this.locationBack = vec3.create();
  }
  getInputModeForMouseLocation(resultRelativeMouseLocation, ctx) {
    const inputData = this.getInputData(ctx);
    const circleRadius = this.getBoneInputCircleRadius(ctx) * ctx.drawStyle.posing3DBoneInputCircleHitRadius;
    if (!inputData.inputDone) {
      return 1;
    } else {
      if (inputData.inputDone && inputData.directionInputDone) {
        ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2D, inputData.inputLocation, ctx.currentPosingData);
        const distance = vec3.distance(ctx.mouseCursorLocation, this.location2D);
        if (resultRelativeMouseLocation != null) {
          vec3.subtract(resultRelativeMouseLocation, this.location2D, ctx.mouseCursorLocation);
        }
        if (distance <= circleRadius) {
          return 1;
        } else {
          return 2;
        }
      }
    }
    return 0;
  }
  mouseDown(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    ctx.setRedrawEditorWindow();
    const jointPartInputMode = this.getInputModeForMouseLocation(this.relativeMouseLocation, ctx);
    if (jointPartInputMode == 2) {
      const inputData = this.getInputData(ctx);
      ctx.posing3DLogic.calculateInputLocation3D(
        inputData.rollInputLocation,
        e.location,
        InputSideID.front,
        inputData,
        ctx.currentPosingData,
        ctx.posing3DView
      );
      this.calculateInputParams(inputData.rollInputLocation, inputData.matrix);
      this.inputStartAngle = this.calculateAngle(inputData.rollInputLocation, inputData.matrix);
      this.beforeEditAngle = inputData.rollInputAngle;
      mat4.copy(this.beforeEditMatrix, inputData.matrix);
      vec3.copy(this.inputStartLocation, inputData.rollInputLocation);
    }
    if (jointPartInputMode != 0) {
      this.jointPartInputMode = jointPartInputMode;
      this.execute(e, ctx);
      ctx.tool.startModalTool(this.subtoolID);
    }
  }
  mouseMove(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    const jointPartInputMode = this.getInputModeForMouseLocation(null, ctx);
    if (jointPartInputMode != this.mouseOnInputMode) {
      this.mouseOnInputMode = jointPartInputMode;
      ctx.setRedrawEditorWindow();
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    if (this.jointPartInputMode == 1) {
      this.execute(e, ctx);
    } else if (this.jointPartInputMode == 2) {
      const inputData = this.getInputData(ctx);
      ctx.posing3DLogic.calculateInputLocation3D(
        inputData.rollInputLocation,
        e.location,
        InputSideID.front,
        inputData,
        ctx.currentPosingData,
        ctx.posing3DView
      );
      this.execute(e, ctx);
    }
  }
  mouseUp(_e, ctx) {
    ctx.tool.endModalTool();
    this.jointPartInputMode = 0;
    ctx.setRedrawWebGLWindow();
    ctx.setRedrawEditorWindow();
  }
  getBoneInputCircleRadius(ctx) {
    return ctx.getViewScaledLength(ctx.drawStyle.posing3DBoneInputCircleRadius);
  }
  onDrawEditor(ctx, drawing) {
    const inputData = this.getInputData(ctx);
    if (!inputData.inputDone) {
      return;
    }
    const circleRadius = this.getBoneInputCircleRadius(ctx);
    Maths.copyTranslation(this.partCenterLocation, inputData.matrix);
    if (this.enableDirectionInput && inputData.directionInputDone) {
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2D, inputData.inputLocation, ctx.currentPosingData);
      const strokeWidth = this.mouseOnInputMode == 1 ? 4 : 2;
      drawing.drawCircle(this.location2D, circleRadius, ctx.getViewScaledLength(strokeWidth), drawing.style.posing3DBoneHeadColor);
    }
    if (this.jointPartInputMode == 1) {
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2D, this.partCenterLocation, ctx.currentPosingData);
      vec3.subtract(this.direction, inputData.inputLocation, this.partCenterLocation);
      vec3.scale(this.direction, vec3.normalize(this.direction, this.direction), inputData.hitTestSphereRadius);
      vec3.add(this.location3DTo, this.partCenterLocation, this.direction);
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2DHead, this.location3DTo, ctx.currentPosingData);
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2DTo, inputData.inputLocation, ctx.currentPosingData);
      drawing.drawLine(this.location2D, this.location2DHead, ctx.getViewScaledLength(4), drawing.style.posing3DBoneGrayColor);
      drawing.drawLine(this.location2DHead, this.location2DTo, ctx.getViewScaledLength(2), drawing.style.posing3DBoneGrayColor);
      drawing.drawCircle(this.location2D, ctx.getViewScaledLength(2), ctx.getViewScaledLength(4), drawing.style.posing3DBoneGrayColor);
      drawing.drawCircle(this.location2DHead, ctx.getViewScaledLength(2), ctx.getViewScaledLength(4), drawing.style.posing3DBoneGrayColor);
    }
    if (this.jointPartInputMode == 2) {
      vec3.transformMat4(this.location3D, vec3.set(this.tmpVec3, 1, 0, 0), this.beforeEditMatrix);
      mat4.invert(this.tmpMatrix, this.beforeEditMatrix);
      vec3.transformMat4(this.location3D, inputData.rollInputLocation, this.tmpMatrix);
      const unitAngle = 5;
      for (let count = 0; count <= 360; count += unitAngle) {
        this.calculateRingRotated2DLocation(
          this.location2D,
          this.location3D,
          this.beforeEditMatrix,
          Math.PI * 2 * count / 360,
          ctx.currentPosingData,
          ctx,
          this.tmpVec3
        );
        this.calculateRingRotated2DLocation(
          this.location2DTo,
          this.location3D,
          this.beforeEditMatrix,
          Math.PI * 2 * (count + unitAngle) / 360,
          ctx.currentPosingData,
          ctx,
          this.tmpVec3
        );
        ctx.posing3DLogic.calculateInputLocation3DForDoubleSide(
          this.locationFront,
          this.locationBack,
          this.location2D,
          this.partCenterLocation,
          inputData.hitTestSphereRadius,
          ctx.currentPosingData,
          ctx.posing3DView
        );
        if (vec3.distance(this.locationFront, this.tmpVec3) < vec3.distance(this.locationBack, this.tmpVec3)) {
          drawing.drawLine(this.location2D, this.location2DTo, ctx.getViewScaledLength(1), drawing.style.posing3DHelperGrayColor1);
        } else {
          drawing.drawLine(this.location2D, this.location2DTo, ctx.getViewScaledLength(1), drawing.style.posing3DHelperGrayColor2);
        }
      }
      {
        const piePoints = [];
        ctx.posing3DView.calculate2DLocationFrom3DLocation(this.rollInputCenterLocation2D, this.rollInputCenterLocation, ctx.currentPosingData);
        piePoints.push([this.rollInputCenterLocation2D[0], this.rollInputCenterLocation2D[1], 0]);
        this.calculateRingRotated2DLocation(this.location2D, this.location3D, this.beforeEditMatrix, 0, ctx.currentPosingData, ctx, this.tmpVec3);
        drawing.beginPath(this.location2D);
        for (let count = 0; count <= 100; count += 10) {
          this.calculateRingRotated2DLocation(
            this.location2D,
            this.location3D,
            this.beforeEditMatrix,
            -this.inputAdditionalAngle * count / 100,
            ctx.currentPosingData,
            ctx,
            this.tmpVec3
          );
          drawing.lineTo(this.location2D);
          piePoints.push([this.location2D[0], this.location2D[1], 0]);
        }
        drawing.stroke(ctx.getViewScaledLength(3), drawing.style.posing3DHelperGrayColor2);
        piePoints.push([this.rollInputCenterLocation2D[0], this.rollInputCenterLocation2D[1], 0]);
        this.fillArea(piePoints, drawing.style.posing3DHelperGrayColor2, drawing);
        drawing.drawLine(this.location2D, this.rollInputCenterLocation2D, ctx.getViewScaledLength(1), drawing.style.posing3DHelperGrayColor1);
      }
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2D, this.rollInputCenterLocation, ctx.currentPosingData);
      ctx.posing3DView.calculate2DLocationFrom3DLocation(this.location2DTo, inputData.rollInputLocation, ctx.currentPosingData);
      drawing.drawLine(this.location2D, this.location2DTo, ctx.getViewScaledLength(3), drawing.style.posing3DBoneGrayColor);
      drawing.drawCircle(this.location2DTo, ctx.getViewScaledLength(5), ctx.getViewScaledLength(4), drawing.style.posing3DBoneGrayColor);
    }
  }
  fillArea(frontPoints, color, drawing) {
    if (frontPoints.length <= 2) {
      return;
    }
    drawing.beginPath();
    drawing.moveTo(frontPoints[0]);
    for (let index2 = 1; index2 < frontPoints.length; index2++) {
      drawing.lineTo(frontPoints[index2]);
    }
    drawing.fill(color);
  }
  calculateInputParams(location, parentMatrix) {
    mat4.invert(this.tmpMatrix, parentMatrix);
    vec3.transformMat4(this.rollInputRelativeLocation, location, this.tmpMatrix);
    vec3.set(this.vecZ, 0, 0, this.rollInputRelativeLocation[2]);
    vec3.transformMat4(this.rollInputCenterLocation, this.vecZ, parentMatrix);
  }
  calculateAngle(location, parentMatrix) {
    mat4.invert(this.tmpMatrix, parentMatrix);
    vec3.transformMat4(this.tmpVec3, location, this.tmpMatrix);
    return Math.atan2(this.tmpVec3[1], this.tmpVec3[0]);
  }
  calculateRingRotated3DLocation(result, location, parentMatrix, angle) {
    mat4.rotateZ(this.tmpMatrix, parentMatrix, angle);
    vec3.transformMat4(result, location, this.tmpMatrix);
  }
  calculateRingRotated2DLocation(result, location, parentMatrix, angle, posingData, ctx, tempVec3) {
    this.calculateRingRotated3DLocation(tempVec3, location, parentMatrix, angle);
    const depth = ctx.posing3DView.calculate2DLocationFrom3DLocation(result, this.tmpVec3, posingData);
    return depth;
  }
  execute(e, ctx) {
    vec3.add(this.location2D, e.location, this.relativeMouseLocation);
    const inputData = this.getInputData(ctx);
    ctx.posing3DLogic.calculateInputLocation3D(
      this.inputLocation,
      this.location2D,
      InputSideID.front,
      inputData,
      ctx.currentPosingData,
      ctx.posing3DView
    );
    this.executeCommand(this.inputLocation, this.location2D, e, ctx);
  }
  executeCommand(inputLocation, inputLocation2D, _e, ctx) {
    const inputData = this.getInputData(ctx);
    if (this.jointPartInputMode == 1) {
      vec3.copy(inputData.inputLocation, inputLocation);
      vec3.copy(inputData.inputLocation2D, inputLocation2D);
      inputData.inputDone = true;
      inputData.directionInputDone = true;
    } else if (this.jointPartInputMode == 2) {
      this.calculateInputParams(inputData.rollInputLocation, this.beforeEditMatrix);
      this.inputEndAngle = this.calculateAngle(inputData.rollInputLocation, this.beforeEditMatrix);
      this.inputAdditionalAngle = Maths.getRoundedAngle(this.inputEndAngle - this.inputStartAngle);
      inputData.rollInputAngle = this.beforeEditAngle + this.inputAdditionalAngle;
      inputData.rollInputDone = true;
    }
    ctx.posing3DLogic.calculateAll(ctx.currentPosingData, ctx.currentPosingModel, ctx.posing3DView);
    this.updateAdditionalPart(inputData.inputLocation, ctx);
    ctx.setRedrawWebGLWindow();
    ctx.setRedrawEditorWindow();
    ctx.setRedrawRibbonUI();
  }
  updateAdditionalPart(_inputLocation, _ctx) {
  }
}
class Tool_Posing3d_LocateHead extends Tool_Posing3d_LineInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30DE\u30A6\u30B9\u3067\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u982D\u306E\u4F4D\u7F6E\u304C\u6C7A\u307E\u308A\u3001\u3055\u3089\u306B\u30C9\u30E9\u30C3\u30B0\u3059\u308B\u3068\u30B9\u30B1\u30FC\u30EB\u304C\u5909\u66F4\u3067\u304D\u307E\u3059\u3002<br />\u6B21\u306E\u64CD\u4F5C\u306B\u79FB\u308B\u306B\u306F\u753B\u9762\u53F3\u306E\u30D1\u30CD\u30EB\u306E\u300C\u982D\u306E\u5411\u304D\u300D\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u307E\u3059\u3002";
    this.inputOptionButtonCount = 0;
    this.tempVec3 = vec3.fromValues(0, 0, 0);
    this.centerLocation = vec3.fromValues(0, 0, 0);
    this.centerLocation3D = vec3.fromValues(0, 0, 0);
    this.subLocation = vec3.fromValues(0, 0, 0);
    this.inputRadius = 0;
    this.inputRadiusAdjustRate = 1;
    this.minInputRadius = 5;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null;
  }
  mouseDown(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!e.isLeftButtonPressing) {
      return;
    }
    this.calculateHeadLoacation(ctx);
    ctx.tool.startModalTool(this.subtoolID);
  }
  prepareModal(e, ctx) {
    if (ctx.currentPosingData == null) {
      return false;
    }
    vec3.copy(this.centerLocation, e.location);
    this.inputRadius = this.minInputRadius;
    return true;
  }
  mouseMove(e, ctx) {
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!e.isLeftButtonPressing || !ctx.tool.isModalToolRunning()) {
      return;
    }
    vec3.subtract(this.subLocation, e.location, this.centerLocation);
    this.inputRadius = vec3.length(this.subLocation);
    if (this.inputRadius < this.minInputRadius) {
      this.inputRadius = this.minInputRadius;
    }
    this.calculateHeadLoacation(ctx);
  }
  mouseUp(_e, ctx) {
    ctx.tool.endModalTool();
    if (ctx.currentPosingData == null) {
      return;
    }
    if (!ctx.tool.isModalToolRunning()) {
      return;
    }
    ctx.tool.endModalTool();
  }
  calculateHeadLoacation(ctx) {
    const posingData = ctx.currentPosingData;
    const radiusSum = this.inputRadius * this.inputRadiusAdjustRate;
    const real2DViewWidth = ctx.mainWindow.height / 2;
    posingData.real3DViewHalfWidth = real2DViewWidth / radiusSum * ctx.currentPosingModel.headSphereSize;
    posingData.real3DViewMeterPerPixel = posingData.real3DViewHalfWidth / real2DViewWidth;
    {
      const inputData = posingData.headLocationInputData;
      ctx.posing3DView.calculate3DLocationFrom2DLocation(
        this.centerLocation3D,
        this.centerLocation,
        posingData.real3DModelDistance,
        posingData
      );
      vec3.copy(inputData.center, this.centerLocation3D);
      inputData.radius = radiusSum;
      inputData.editLine = this.editLine;
      inputData.inputDone = true;
    }
    ctx.posing3DLogic.calculateHeadLocation(posingData, ctx.currentPosingModel);
    {
      const inputData = posingData.headRotationInputData;
      vec3.set(this.tempVec3, 0, 0, inputData.hitTestSphereRadius);
      vec3.transformMat4(inputData.inputLocation, this.tempVec3, inputData.parentMatrix);
      ctx.posing3DView.calculate2DLocationFrom3DLocation(
        inputData.inputLocation2D,
        inputData.inputLocation,
        posingData
      );
      inputData.directionInputDone = true;
      inputData.rollInputAngle = 0;
      inputData.rollInputDone = false;
    }
    ctx.setRedrawWebGLWindow();
    ctx.setRedrawRibbonUI();
  }
}
class Tool_Posing3d_RotateHead extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u753B\u9762\u306B\u8868\u793A\u3055\u308C\u305F\u7403\u306E\u3069\u3053\u304B\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u982D\u306E\u5411\u304D\u304C\u6C7A\u307E\u308A\u307E\u3059\u3002<br />\u753B\u9762\u53F3\u306E\u30D1\u30CD\u30EB\u3067\u300C\u624B\u524D\u300D\u3068\u306A\u3063\u3066\u3044\u308B\u30DC\u30BF\u30F3\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u5965\u5074\u3092\u6307\u5B9A\u3067\u304D\u308B\u3088\u3046\u306B\u306A\u308A\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.headLocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.headRotationInputData;
  }
}
class Tool_Posing3d_LocateBody extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u534A\u900F\u660E\u306E\u7403\u306E\u3069\u3053\u304B\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u982D\u306E\u5411\u304D\u3092\u6B63\u9762\u3068\u3057\u3066\u80F4\u304C\u914D\u7F6E\u3055\u308C\u307E\u3059\u3002<br />\u5C11\u3057\u5916\u5074\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u753B\u9762\u306B\u5BFE\u3057\u3066\u771F\u6A2A\u3092\u6307\u5B9A\u3067\u304D\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.headLocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.bodyLocationInputData;
  }
}
class Tool_Posing3d_LocateHips extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u8170\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.bodyLocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.hipsLocationInputData;
  }
}
class Tool_Posing3d_LocateLeftShoulder extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D2\u30B8\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u80A9\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && (ctx.currentPosingData.bodyLocationInputData.inputDone || ctx.currentPosingData.bodyRotationInputData.inputDone);
  }
  getInputData(ctx) {
    return ctx.currentPosingData.leftShoulderLocationInputData;
  }
}
class Tool_Posing3d_LocateRightShoulder extends Tool_Posing3d_LocateLeftShoulder {
  getInputData(ctx) {
    return ctx.currentPosingData.rightShoulderLocationInputData;
  }
}
class Tool_Posing3d_LocateLeftArm1 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D2\u30B8\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0A\u8155\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && (ctx.currentPosingData.bodyLocationInputData.inputDone || ctx.currentPosingData.bodyRotationInputData.inputDone);
  }
  getInputData(ctx) {
    return ctx.currentPosingData.leftArm1LocationInputData;
  }
  updateAdditionalPart(_inputLocation, ctx) {
    ctx.currentPosingData.leftShoulderLocationInputData.inputDone = true;
  }
}
class Tool_Posing3d_LocateRightArm1 extends Tool_Posing3d_LocateLeftArm1 {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D2\u30B8\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0A\u8155\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  getInputData(ctx) {
    return ctx.currentPosingData.rightArm1LocationInputData;
  }
  updateAdditionalPart(_inputLocation, ctx) {
    ctx.currentPosingData.rightShoulderLocationInputData.inputDone = true;
  }
}
class Tool_Posing3d_LocateLeftLeg1 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D2\u30B6\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0A\u811A\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.hipsLocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.leftLeg1LocationInputData;
  }
  executeCommandExt(ctx) {
    ctx.currentPosingData.leftShoulderLocationInputData.inputDone = true;
  }
}
class Tool_Posing3d_LocateRightLeg1 extends Tool_Posing3d_LocateLeftLeg1 {
  constructor() {
    super(...arguments);
    this.helpText = "\u30D2\u30B6\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0A\u811A\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  getInputData(ctx) {
    return ctx.currentPosingData.rightLeg1LocationInputData;
  }
}
class Tool_Posing3d_LocateLeftArm2 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u624B\u9996\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0B\u8155\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.leftArm1LocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.leftArm2LocationInputData;
  }
}
class Tool_Posing3d_LocateRightArm2 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u624B\u9996\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0B\u8155\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.rightArm1LocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.rightArm2LocationInputData;
  }
}
class Tool_Posing3d_LocateLeftLeg2 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u8DB3\u9996\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0B\u811A\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.leftLeg1LocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.leftLeg2LocationInputData;
  }
}
class Tool_Posing3d_LocateRightLeg2 extends Tool_Posing3d_JointPartInputToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u8DB3\u9996\u306E\u4F4D\u7F6E\u3092\u6307\u5B9A\u3057\u3066\u4E0B\u811A\u3092\u914D\u7F6E\u3057\u307E\u3059\u3002";
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerPosingLayer() && ctx.currentPosingData != null && ctx.currentPosingData.rightLeg1LocationInputData.inputDone;
  }
  getInputData(ctx) {
    return ctx.currentPosingData.rightLeg2LocationInputData;
  }
}
class EditLine {
  constructor() {
    this.targetLine = null;
    this.layer = null;
    this.oldPoints = null;
    this.newPoints = null;
  }
}
class Tool_Resample_Segment extends SubTool {
  constructor() {
    super(...arguments);
    this.helpText = "\u30A8\u30F3\u30BF\u30FC\u30AD\u30FC\u3067\u9078\u629E\u4E2D\u306E\u9802\u70B9\u306E\u9593\u3092\u753B\u9762\u306E\u62E1\u5927\u7387\u306B\u5408\u308F\u305B\u3066\u518D\u5206\u5272\u3057\u307E\u3059\u3002";
    this.targetGroups = null;
    this.editLines = null;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerEditbaleLayer();
  }
  toolWindowItemClick(ctx) {
    ctx.tool.setOperationUnit(OperationUnitID.strokePoint);
    ctx.setRedrawMainWindow();
  }
  keydown(key, commandID, ctx) {
    if (commandID == ShortcutCommandID.edit_fix) {
      if (ctx.currentVectorLayer != null) {
        this.executeCommand(ctx);
        return true;
      }
    }
    return false;
  }
  executeCommand(ctx) {
    if (this.collectEditTargets(ctx)) {
      const command = new Command_Resample_Segment();
      command.editLines = this.editLines;
      for (const targetGroup of this.targetGroups) {
        command.defferedProcess.addGroup(targetGroup.layer, targetGroup.group, PostUpdateSituationTypeID.changesObjectShapes);
      }
      ctx.commandHistory.executeCommand(command, ctx);
      ctx.setRedrawMainWindowEditorWindow();
    }
  }
  collectEditTargets(ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    const targetGroups = [];
    const editLines = [];
    const resamplingUnitLength = ctx.getViewScaledResamplingUnitLengthForBrush();
    ViewKeyframeLayer.forEachStrokeGroup(viewKeyframeLayers, (group, layer) => {
      let existsInGroup = false;
      for (const line of group.lines) {
        if (line.isSelected && this.existsSelectedSegment(line)) {
          const editLine = new EditLine();
          editLine.targetLine = line;
          editLine.layer = layer;
          editLine.oldPoints = line.points;
          editLine.newPoints = this.createResampledPoints(editLine.targetLine, resamplingUnitLength);
          editLines.push(editLine);
          existsInGroup = true;
        }
      }
      if (existsInGroup) {
        targetGroups.push({ group, layer });
      }
    });
    this.targetGroups = targetGroups;
    this.editLines = editLines;
    return editLines.length > 0;
  }
  existsSelectedSegment(line) {
    let selectedPointCount = 0;
    for (const point of line.points) {
      if (point.isSelected) {
        selectedPointCount++;
        if (selectedPointCount >= 2) {
          break;
        }
      } else {
        selectedPointCount = 0;
      }
    }
    return selectedPointCount >= 2;
  }
  createResampledPoints(line, resamplingUnitLength) {
    let currentIndex = 0;
    let segmentStartIndex = -1;
    let segmentEndIndex = -1;
    const newPoints = [];
    while (currentIndex < line.points.length) {
      const currentPoint = line.points[currentIndex];
      if (currentPoint.isSelected) {
        segmentStartIndex = currentIndex;
        for (let i = segmentStartIndex; i < line.points.length; i++) {
          const point = line.points[i];
          if (!point.isSelected) {
            break;
          }
          segmentEndIndex = i;
        }
        if (segmentEndIndex > segmentStartIndex) {
          VectorPointLogic.resamplePoints(
            newPoints,
            line.points,
            segmentStartIndex,
            segmentEndIndex,
            resamplingUnitLength
          );
        } else {
          const point = line.points[currentIndex];
          newPoints.push(point);
        }
        currentIndex = segmentEndIndex + 1;
      } else {
        segmentStartIndex = currentIndex;
        for (let i = segmentStartIndex; i < line.points.length; i++) {
          const point = line.points[i];
          if (point.isSelected) {
            break;
          }
          segmentEndIndex = i;
        }
        for (let i = segmentStartIndex; i <= segmentEndIndex; i++) {
          const point = line.points[i];
          newPoints.push(point);
        }
        currentIndex = segmentEndIndex + 1;
      }
    }
    return newPoints;
  }
}
class Command_Resample_Segment extends CommandBase {
  constructor() {
    super(...arguments);
    this.editLines = null;
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editLine of this.editLines) {
      editLine.targetLine.points = editLine.oldPoints;
    }
    this.updateRelatedObjects();
  }
  redo(_ctx) {
    for (const editLine of this.editLines) {
      editLine.targetLine.points = editLine.newPoints;
    }
    this.updateRelatedObjects();
  }
  updateRelatedObjects() {
    for (const editLine of this.editLines) {
      VectorStrokeLogic.calculateParameters(editLine.targetLine, editLine.layer.lineWidthBiasRate);
    }
  }
}
class Tool_ScratchLine_CandidatePair {
  constructor() {
    this.targetPoint = null;
    this.candidatePoint = null;
    this.normPosition = 0;
    this.totalLength = 0;
    this.influence = 0;
  }
}
class Tool_ScratchLine_EditPoint {
  constructor() {
    this.pair = null;
    this.newLocation = vec3.fromValues(0, 0, 0);
    this.oldLocation = vec3.fromValues(0, 0, 0);
  }
}
class Tool_ScratchLine extends ModalToolBase {
  constructor() {
    super(...arguments);
    this.helpText = "\u53F3\u30AF\u30EA\u30C3\u30AF\u307E\u305F\u306FG\u3067\u7DDA\u3092\u9078\u629E\u3057\u3001\u5DE6\u30AF\u30EA\u30C3\u30AF\u3067\u7DDA\u3092\u4FEE\u6B63\u3057\u307E\u3059\u3002";
    this.enableScratchEdit = true;
    this.enableExtrude = false;
    this.editStroke = null;
    this.resampledStroke = null;
    this.candidateStroke = null;
    this.forwardExtrude = false;
    this.extrudeLine = null;
    this.cutouted = false;
    this.isEditing = false;
    this.inputLocation = vec3.fromValues(0, 0, 0);
    this.inputLastLocation = vec3.fromValues(0, 0, 0);
    this.nearestPointLocation = vec3.fromValues(0, 0, 0);
    this.samplePoint = vec3.fromValues(0, 0, 0);
    this.strokeSingleHitTester = new HitTest_VectorStroke_PointToStroke_Nearest();
    this.strokeSmoothLevel = 3;
    this.selectLine_NonMovedLocationDistanceRate = 0.5;
    this.maxResamplingDivisionCount = 51;
    this.curveCheckPointCount = 3;
    this.cutoutAngle = 30 / 180 * Math.PI;
    this.editFalloffRadiusMinRate = 0.15;
    this.editFalloffRadiusMaxRate = 2;
    this.editFalloffRadiusContainsLineWidth = false;
    this.editInfluence = 0.5;
    this.editExtrudeMinRadiusRate = 0.5;
    this.editExtrudeMaxRadiusRate = 1;
    this.tool_ScratchLine_EditLine_Visible = true;
    this.tool_ScratchLine_TargetLine_Visible = true;
    this.tool_ScratchLine_SampledLine_Visible = true;
    this.tool_ScratchLine_CandidatePoints_Visible = false;
    this.tool_ScratchLine_ExtrudePoints_Visible = false;
  }
  isAvailable(ctx) {
    return ctx.isCurrentLayerEditbaleLayer();
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawPointerCursor(ctx.toolBaseViewRadius);
    if (this.tool_ScratchLine_EditLine_Visible) {
      if (this.editStroke != null && this.resampledStroke == null) {
        drawing.editorDrawer.drawOperatorSolidStroke(this.editStroke);
      }
    }
    if (this.tool_ScratchLine_TargetLine_Visible) {
      if (ctx.activeVectorLine != null) {
        {
          if (ctx.activeVectorLine.points.length >= 2) {
            const firstPoint = ctx.activeVectorLine.points[0];
            const lastPoint = ctx.activeVectorLine.points[ctx.activeVectorLine.points.length - 1];
            drawing.drawCircle(
              firstPoint.location,
              VectorPointLogic.getPointRadius(firstPoint) + ctx.getViewScaledLength(3),
              ctx.getViewScaledLength(1),
              ctx.drawStyle.sampledPointColor
            );
            drawing.drawCircle(
              lastPoint.location,
              VectorPointLogic.getPointRadius(lastPoint) + ctx.getViewScaledLength(3),
              ctx.getViewScaledLength(1),
              ctx.drawStyle.sampledPointColor
            );
          }
        }
      }
    }
    if (this.tool_ScratchLine_SampledLine_Visible) {
      if (this.resampledStroke != null) {
        drawing.editorDrawer.drawEditorStrokePoints(this.resampledStroke, drawing.style.sampledPointColor, false);
      }
    }
    if (this.tool_ScratchLine_CandidatePoints_Visible) {
      if (this.candidateStroke != null) {
        drawing.editorDrawer.drawEditorStrokePoints(this.candidateStroke, drawing.style.linePointColor, false);
      }
    }
    if (this.tool_ScratchLine_ExtrudePoints_Visible) {
      if (this.extrudeLine != null) {
        drawing.editorDrawer.drawEditorStrokePoints(this.extrudeLine, drawing.style.extrutePointColor, false);
      }
    }
  }
  mouseDown(e, ctx) {
    this.setInputLocation(e, true);
    if (e.isLeftButtonPressing) {
      this.resetState(true);
      ctx.tool.startModalTool(this.subtoolID);
    }
  }
  mouseMove(e, ctx) {
    this.setInputLocation(e, false);
    ctx.setRedrawEditorWindow();
    if (!this.isEditing) {
      this.resetState();
      ctx.setRedrawEditorWindow();
      return;
    }
    if (e.isLeftButtonPressing && !this.cutouted) {
      this.addPointToEditLine(ctx);
    }
  }
  mouseUp(e, ctx) {
    ctx.tool.endModalTool();
    this.setInputLocation(e, false);
    ctx.setRedrawEditorWindow();
    if (!e.isPointerMoved) {
      this.selectStroke(this.inputLocation, ctx);
      this.resetState();
      return;
    }
    if (!this.isEditing || ctx.activeVectorLine == null || this.editStroke == null) {
      this.resetState();
      return;
    }
    VectorStrokeLogic.calculateParameters(this.editStroke);
    if (VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      this.resetState();
      return;
    }
    this.executeCommand(ctx);
    this.isEditing = false;
  }
  resetState(isForOperationStart = false) {
    this.editStroke = null;
    this.resampledStroke = null;
    this.candidateStroke = null;
    this.isEditing = isForOperationStart;
    this.cutouted = false;
    if (isForOperationStart) {
      this.editStroke = new VectorStroke();
    }
  }
  setInputLocation(e, pointerDown) {
    if (pointerDown) {
      vec3.copy(this.inputLastLocation, e.location);
    }
    vec3.copy(this.inputLocation, e.location);
  }
  addPointToEditLine(ctx) {
    const point = new VectorPoint();
    vec3.copy(point.location, this.inputLocation);
    vec3.copy(point.adjustingLocation, this.inputLocation);
    point.lineWidth = ctx.drawLineBaseWidth;
    this.editStroke.points.push(point);
    VectorStrokeLogic.calculateParameters(this.editStroke);
    if (!VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      this.resampledStroke = this.generateResampledEditorStroke(this.editStroke, ctx);
    }
  }
  selectStroke(location, ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    let hitedGeometry = null;
    let hitedGroup = null;
    let hitedStroke = null;
    ViewKeyframeLayer.forEachVectorGeometry(viewKeyframeLayers, (geometry, layer) => {
      if (hitedStroke == null) {
        this.strokeSingleHitTester.startProcess();
        this.strokeSingleHitTester.processGeometry(layer, geometry, location, ctx.toolBaseViewRadius);
        hitedGeometry = this.strokeSingleHitTester.hitedGeometry;
        hitedGroup = this.strokeSingleHitTester.hitedGroup;
        hitedStroke = this.strokeSingleHitTester.hitedStoke;
      }
    });
    if (hitedStroke != null) {
      ctx.setActiveVectorStroke(hitedStroke, hitedGroup, hitedGeometry);
      ctx.setRedrawCurrentLayer();
      ctx.setRedrawEditorWindow();
    } else {
      ctx.unsetAcrtiveVectorStrokeAndGroup();
    }
  }
  executeCommand(ctx) {
    if (VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      return;
    }
    let isExtrudeDone = false;
    let isScratchingDone = false;
    const targetLine = ctx.activeVectorLine;
    const targetGroup = ctx.activeVectorGroup;
    const targetLayer = ctx.currentLayer;
    const oldPoints = targetLine.points;
    const resamplingUnitLengthForBrush = ctx.getViewScaledResamplingUnitLengthForBrush();
    if (this.enableExtrude) {
      this.resampledStroke = VectorStrokeLogic.createResampledLine(this.editStroke, resamplingUnitLengthForBrush);
      isExtrudeDone = this.executeExtrudeLine(targetLine, targetGroup, targetLayer, this.resampledStroke, ctx);
    }
    if (this.enableScratchEdit) {
      this.resampledStroke = this.generateResampledEditorStroke(this.editStroke, ctx);
      isScratchingDone = this.executeScratchingLine(
        targetLine,
        targetGroup,
        targetLayer,
        this.resampledStroke,
        isExtrudeDone,
        ctx
      );
    }
    if (isExtrudeDone || isScratchingDone) {
      this.deleteDuplications(
        targetLine,
        targetGroup,
        targetLayer,
        resamplingUnitLengthForBrush,
        ctx
      );
    }
    VectorLayerLogic.clearPointModifyFlags(oldPoints);
    ctx.setRedrawCurrentLayer();
  }
  cutoutLine(result) {
    VectorStrokeLogic.smooth(result);
    const startIndex = this.searchCutoutIndex(result, false);
    const endIndex = this.searchCutoutIndex(result, true);
    const lastPointCount = result.points.length;
    result.points = Lists.getRange(result.points, startIndex, endIndex - startIndex + 1);
    VectorStrokeLogic.applyAdjustments(result);
    return lastPointCount != result.points.length;
  }
  searchCutoutIndex(editorLine, isForward) {
    const scanDirection = isForward ? 1 : -1;
    let cutoutIndex = isForward ? editorLine.points.length - 1 : 0;
    const centerIndex = Math.floor(editorLine.points.length / 2);
    const limitCurvature = this.cutoutAngle;
    let k = centerIndex;
    while (k >= 0 && k < editorLine.points.length) {
      let scanCount = this.curveCheckPointCount;
      let totalCurvature = 0;
      let i = k + scanDirection;
      while (i >= 0 && i < editorLine.points.length) {
        const point = editorLine.points[i];
        totalCurvature += point.curvature;
        scanCount--;
        if (scanCount == 0) {
          break;
        }
        i += scanDirection;
      }
      if (totalCurvature >= limitCurvature) {
        cutoutIndex = i;
        break;
      }
      k += scanDirection;
    }
    return cutoutIndex;
  }
  generateResampledEditorStroke(editorStroke, ctx) {
    let resamplingUnitLength = ctx.getViewScaledResamplingUnitLengthForEdit();
    let divisionCount = VectorStrokeLogic.clalculateSamplingDivisionCount(editorStroke.runtime.totalLength, resamplingUnitLength);
    if (divisionCount > this.maxResamplingDivisionCount) {
      resamplingUnitLength = editorStroke.runtime.totalLength / this.maxResamplingDivisionCount;
    }
    const resampledLine = VectorStrokeLogic.createResampledLine(editorStroke, resamplingUnitLength);
    VectorStrokeLogic.smooth(resampledLine, this.strokeSmoothLevel);
    this.cutouted = this.cutoutLine(resampledLine);
    return resampledLine;
  }
  executeExtrudeLine(targetLine, targetGroup, targetLayer, resampledLine, ctx) {
    const baseRadius = ctx.toolBaseViewRadius;
    const editExtrudeMinRadius = baseRadius * this.editExtrudeMinRadiusRate;
    const editExtrudeMaxRadius = baseRadius * this.editExtrudeMaxRadiusRate;
    let forwardExtrude = true;
    let extrudeLine = this.generateExtrudePoints(
      false,
      targetLine,
      resampledLine,
      editExtrudeMinRadius,
      editExtrudeMaxRadius
    );
    if (extrudeLine == null) {
      extrudeLine = this.generateExtrudePoints(
        true,
        targetLine,
        resampledLine,
        editExtrudeMinRadius,
        editExtrudeMaxRadius
      );
      if (extrudeLine != null) {
        forwardExtrude = false;
      }
    }
    this.forwardExtrude = forwardExtrude;
    this.extrudeLine = extrudeLine;
    if (extrudeLine != null && extrudeLine.points.length > 0) {
      const command = new Command_ExtrudeLine();
      command.targetLine = targetLine;
      command.forwardExtrude = forwardExtrude;
      command.extrudeLine = extrudeLine;
      command.defferedProcess.addGroup(targetLayer, targetGroup, PostUpdateSituationTypeID.changesObjectShapes);
      ctx.commandHistory.executeCommand(command, ctx);
      return true;
    } else {
      return false;
    }
  }
  generateExtrudePoints(fromTargetLineTop, targetLine, sampleLine, editExtrudeMinRadius, editExtrudeMaxRadius) {
    let startPoint;
    if (fromTargetLineTop) {
      startPoint = targetLine.points[0];
    } else {
      startPoint = targetLine.points[targetLine.points.length - 1];
    }
    const sampleLine_NearestPointIndex = this.findNearestPointIndex_PointToPoint(sampleLine, startPoint, 0, editExtrudeMaxRadius);
    if (sampleLine_NearestPointIndex == -1) {
      return null;
    }
    const nearPointCount_SampleLineForward = this.getNearPointCount(targetLine, sampleLine, sampleLine_NearestPointIndex, true, editExtrudeMaxRadius);
    const nearPointCount_SampleLineBackward = this.getNearPointCount(targetLine, sampleLine, sampleLine_NearestPointIndex, false, editExtrudeMaxRadius);
    const isForwardExtrudeInSampleLine = nearPointCount_SampleLineForward < 0 && nearPointCount_SampleLineBackward >= 0;
    const isBackwardExtrudeInSampleLine = nearPointCount_SampleLineForward >= 0 && nearPointCount_SampleLineBackward < 0;
    const extrudable = isForwardExtrudeInSampleLine || isBackwardExtrudeInSampleLine;
    if (!extrudable) {
      return null;
    }
    const extrudePoints = this.getExtrudePoints(targetLine, sampleLine, sampleLine_NearestPointIndex, isForwardExtrudeInSampleLine, editExtrudeMinRadius, editExtrudeMaxRadius);
    if (extrudePoints == null) {
      return null;
    }
    const extrudeLine = new VectorStroke();
    extrudeLine.points = extrudePoints;
    return extrudeLine;
  }
  getExtrudePoints(targetLine, sampleLine, searchStartIndex, forwardSearch, limitMinDistance, limitMaxDistance) {
    const scanDirection = forwardSearch ? 1 : -1;
    let startIndex = -1;
    let currentIndex = searchStartIndex;
    let nextIndex = currentIndex + scanDirection;
    while (nextIndex >= 0 && nextIndex < sampleLine.points.length) {
      const point1 = sampleLine.points[currentIndex];
      const point2 = sampleLine.points[nextIndex];
      const nearestPointIndex = this.findNearestPointIndex_LineSegmentToPoint(targetLine, point1, point2, limitMinDistance, limitMaxDistance, false, true);
      if (nearestPointIndex == -1) {
        startIndex = nextIndex;
        break;
      }
      currentIndex += scanDirection;
      nextIndex += scanDirection;
    }
    if (startIndex == -1) {
      return null;
    }
    const result = [];
    if (forwardSearch) {
      for (let i = startIndex; i < sampleLine.points.length; i++) {
        result.push(sampleLine.points[i]);
      }
    } else {
      for (let i = startIndex; i >= 0; i--) {
        result.push(sampleLine.points[i]);
      }
    }
    return result;
  }
  executeScratchingLine(targetLine, targetGroup, targetLayer, resampledLine, isExtrudeDone, ctx) {
    const baseRadius = ctx.toolBaseViewRadius;
    const editFalloffRadiusMin = baseRadius * this.editFalloffRadiusMinRate;
    const editFalloffRadiusMax = baseRadius * this.editFalloffRadiusMaxRate;
    const candidatePointPairs = this.ganerateScratchingCandidatePoints(
      targetLine,
      resampledLine,
      editFalloffRadiusMin,
      editFalloffRadiusMax,
      this.editFalloffRadiusContainsLineWidth
    );
    this.candidateStroke = new VectorStroke();
    for (const pair of candidatePointPairs) {
      this.candidateStroke.points.push(pair.candidatePoint);
    }
    if (candidatePointPairs != null && candidatePointPairs.length > 0) {
      const command = new Command_ScratchLine();
      command.isContinued = isExtrudeDone;
      command.targetLine = targetLine;
      command.layer = targetLayer;
      for (const pair of candidatePointPairs) {
        const editPoint = new Tool_ScratchLine_EditPoint();
        editPoint.pair = pair;
        command.editPoints.push(editPoint);
      }
      command.defferedProcess.addGroup(targetLayer, targetGroup, PostUpdateSituationTypeID.changesObjectShapes);
      ctx.commandHistory.executeCommand(command, ctx);
      return true;
    } else {
      return false;
    }
  }
  ganerateScratchingCandidatePoints(target_Line, editorLine, _editFalloffRadiusMin, editFalloffRadiusMax, containsPointLineWidth) {
    const result = [];
    for (const point of target_Line.points) {
      let minDistance = 99999;
      let nearestSegmentIndex = -1;
      for (let i = 0; i < editorLine.points.length - 1; i++) {
        const editPoint1 = editorLine.points[i];
        const editPoint2 = editorLine.points[i + 1];
        const distance = Logic_Points.pointToLineSegment_SorroundingDistance(
          editPoint1.location,
          editPoint2.location,
          point.location
        );
        if (distance < minDistance) {
          minDistance = distance;
          nearestSegmentIndex = i;
        }
      }
      if (nearestSegmentIndex != -1) {
        const nearestLinePoint1 = editorLine.points[nearestSegmentIndex];
        const nearestLinePoint2 = editorLine.points[nearestSegmentIndex + 1];
        const nearestPoint_Available = Logic_Points.pointToLine_NearestLocation(
          this.nearestPointLocation,
          nearestLinePoint1.location,
          nearestLinePoint2.location,
          point.location
        );
        if (!nearestPoint_Available) {
          continue;
        }
        let directDistance = vec3.distance(point.location, this.nearestPointLocation);
        if (containsPointLineWidth) {
          directDistance -= point.lineWidth * 0.5;
          if (directDistance < 0) {
            directDistance = 0;
          }
        }
        if (directDistance > editFalloffRadiusMax) {
          continue;
        }
        const sorroundingDistance = Logic_Points.pointToLineSegment_SorroundingDistance(
          nearestLinePoint1.location,
          nearestLinePoint2.location,
          this.nearestPointLocation
        );
        if (sorroundingDistance > editFalloffRadiusMax) {
          continue;
        }
        const normPositionInEditorLineSegment = Logic_Points.pointToLineSegment_NormalizedPosition(
          nearestLinePoint1.location,
          nearestLinePoint2.location,
          point.location
        );
        const totalLengthInEditorLine = nearestLinePoint1.totalLength + (nearestLinePoint2.totalLength - nearestLinePoint1.totalLength) * normPositionInEditorLineSegment;
        const influence = this.calculateScratchingCandidatePointInfluence(
          editorLine.runtime.totalLength,
          sorroundingDistance,
          totalLengthInEditorLine,
          editFalloffRadiusMax
        );
        if (influence > 0) {
          const candidatePoint = new VectorPoint();
          vec3.copy(candidatePoint.location, this.nearestPointLocation);
          vec3.copy(candidatePoint.adjustingLocation, candidatePoint.location);
          candidatePoint.lineWidth = Maths.lerp(normPositionInEditorLineSegment, nearestLinePoint1.lineWidth, nearestLinePoint2.lineWidth);
          const pair = new Tool_ScratchLine_CandidatePair();
          pair.targetPoint = point;
          pair.candidatePoint = candidatePoint;
          pair.normPosition = normPositionInEditorLineSegment;
          pair.totalLength = totalLengthInEditorLine;
          pair.influence = influence;
          result.push(pair);
          point.modifyFlag = VectorPointModifyFlagID.edit;
        }
      }
    }
    return result;
  }
  calculateScratchingCandidatePointInfluence(editorLine_TotalLength, sorroundingDistance, totalLengthInEditorLine, editFalloffRadiusMax) {
    let falloffDistance = 1;
    if (editorLine_TotalLength > editFalloffRadiusMax * 2) {
      if (totalLengthInEditorLine < editFalloffRadiusMax) {
        falloffDistance = totalLengthInEditorLine / editFalloffRadiusMax;
      }
      if (totalLengthInEditorLine > editorLine_TotalLength - editFalloffRadiusMax) {
        falloffDistance = (editorLine_TotalLength - totalLengthInEditorLine) / editFalloffRadiusMax;
      }
    } else {
      falloffDistance = 1 - sorroundingDistance / editFalloffRadiusMax;
    }
    let influence = Maths.clamp(falloffDistance, 0, 1);
    if (influence == 0) {
      return 0;
    }
    influence *= this.editInfluence * Maths.sigmoid10(1 - sorroundingDistance / editFalloffRadiusMax);
    return influence;
  }
  deleteDuplications(targetLine, targetGroup, targetLayer, resamplingUnitLength, ctx) {
    let firstPointIndex = -1;
    let lastPointIndex = -1;
    for (let i = 0; i < targetLine.points.length; i++) {
      const point = targetLine.points[i];
      if (point.modifyFlag == VectorPointModifyFlagID.edit) {
        if (firstPointIndex == -1) {
          firstPointIndex = i;
        }
        lastPointIndex = i;
      }
    }
    if (firstPointIndex > 0) {
      firstPointIndex--;
    }
    if (lastPointIndex < targetLine.points.length - 1) {
      lastPointIndex++;
    }
    if (lastPointIndex - firstPointIndex < 2) {
      return;
    }
    const newPoints = Lists.getRange(targetLine.points, 0, firstPointIndex);
    VectorPointLogic.resamplePoints(
      newPoints,
      targetLine.points,
      firstPointIndex,
      lastPointIndex,
      resamplingUnitLength
    );
    for (let index2 = lastPointIndex + 1; index2 < targetLine.points.length; index2++) {
      newPoints.push(targetLine.points[index2]);
    }
    const command = new Command_DeleteDuplicationInLine();
    command.isContinued = true;
    command.targetLine = targetLine;
    command.layer = targetLayer;
    command.oldPoints = targetLine.points;
    command.newPoints = newPoints;
    command.defferedProcess.addGroup(targetLayer, targetGroup, PostUpdateSituationTypeID.changesObjectShapes);
    ctx.commandHistory.executeCommand(command, ctx);
  }
  findNearestPointIndex_LineSegmentToPoint(line, point1, point2, limitMinDistance, limitMaxDistance, includeInnerSide, includeOuterSide) {
    let minDistance = 99999;
    let nearestPointIndex = -1;
    for (let i = 0; i < line.points.length - 1; i++) {
      const linePoint = line.points[i];
      const distance = vec3.distance(point1.location, linePoint.location);
      if (distance < minDistance) {
        const normPosition = Logic_Points.pointToLineSegment_NormalizedPosition(point1.location, point2.location, linePoint.location);
        if (includeInnerSide && normPosition >= 0 && normPosition <= 1 || includeOuterSide && (normPosition < 0 || normPosition > 1)) {
          if (distance > limitMinDistance && distance < limitMaxDistance) {
            minDistance = distance;
            nearestPointIndex = i;
          }
        }
      }
    }
    return nearestPointIndex;
  }
  findNearestPointIndex_PointToPoint(line, point, limitMinDistance, limitMaxDistance) {
    let minDistance = 99999;
    let nearestPointIndex = -1;
    for (let i = 0; i < line.points.length - 1; i++) {
      const linePoint = line.points[i];
      const distance = vec3.distance(point.location, linePoint.location);
      if (distance < minDistance && distance > limitMinDistance && distance < limitMaxDistance) {
        minDistance = distance;
        nearestPointIndex = i;
      }
    }
    return nearestPointIndex;
  }
  getNearPointCount(targetLine, sampleLine, searchStartIndex, forwardSearch, limitMaxDistance) {
    let nearPointCcount = 0;
    const scanDirection = forwardSearch ? 1 : -1;
    let currentIndex = searchStartIndex;
    let nextIndex = currentIndex + scanDirection;
    while (nextIndex >= 0 && nextIndex < sampleLine.points.length) {
      const point1 = sampleLine.points[currentIndex];
      const point2 = sampleLine.points[nextIndex];
      const nearestPointIndex = this.findNearestPointIndex_LineSegmentToPoint(targetLine, point1, point2, 0, limitMaxDistance, true, false);
      if (nearestPointIndex != -1) {
        nearPointCcount++;
      } else {
        nearPointCcount--;
      }
      currentIndex += scanDirection;
      nextIndex += scanDirection;
    }
    return nearPointCcount;
  }
}
class Command_ExtrudeLine extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLine = null;
    this.forwardExtrude = false;
    this.extrudeLine = null;
    this.oldPointList = null;
    this.newPointList = null;
  }
  execute(ctx) {
    this.prepareEditPoints();
    this.redo(ctx);
  }
  prepareEditPoints() {
    this.oldPointList = this.targetLine.points;
    if (this.forwardExtrude) {
      this.newPointList = Lists.clone(this.targetLine.points);
      Lists.addRange(this.newPointList, this.extrudeLine.points);
    } else {
      this.newPointList = [];
      for (let i = this.extrudeLine.points.length - 1; i >= 0; i--) {
        this.newPointList.push(this.extrudeLine.points[i]);
      }
      Lists.addRange(this.newPointList, this.targetLine.points);
    }
  }
  undo(_ctx) {
    this.targetLine.points = this.oldPointList;
  }
  redo(_ctx) {
    this.targetLine.points = this.newPointList;
  }
}
class Command_ScratchLine extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLine = null;
    this.editPoints = [];
    this.layer = null;
  }
  execute(ctx) {
    this.prepareEditPoints();
    this.redo(ctx);
  }
  prepareEditPoints() {
    for (const editPoint of this.editPoints) {
      const candidatePoint = editPoint.pair.candidatePoint;
      const targetPoint = editPoint.pair.targetPoint;
      vec3.copy(editPoint.oldLocation, targetPoint.adjustingLocation);
      if (editPoint.pair.influence > 0) {
        vec3.lerp(editPoint.newLocation, targetPoint.location, candidatePoint.location, editPoint.pair.influence);
      } else {
        vec3.copy(editPoint.newLocation, targetPoint.location);
      }
    }
  }
  undo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.pair.targetPoint;
      vec3.copy(targetPoint.location, editPoint.oldLocation);
      vec3.copy(targetPoint.adjustingLocation, targetPoint.location);
    }
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
  redo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.pair.targetPoint;
      vec3.copy(targetPoint.location, editPoint.newLocation);
      vec3.copy(targetPoint.adjustingLocation, targetPoint.location);
    }
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
}
class Command_DeleteDuplicationInLine extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLine = null;
    this.layer = null;
    this.oldPoints = null;
    this.newPoints = null;
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    this.targetLine.points = this.oldPoints;
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
  redo(_ctx) {
    this.targetLine.points = this.newPoints;
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
}
class SubjoinProcessingState {
  constructor() {
    this.newLine = null;
    this.subjoinedStroke = null;
    this.subjoinedForward = false;
    this.deleteLines = [];
  }
}
class Tool_ScratchLineDraw extends Tool_ScratchLine {
  constructor() {
    super(...arguments);
    this.helpText = "\u65E2\u5B58\u306E\u7DDA\u306E\u7AEF\u70B9\u8FD1\u304F\u306B\u7DDA\u3092\u63CF\u3044\u3066\u7DDA\u3092\u7D50\u5408\u3057\u307E\u3059\u3002";
    this.editLineVec = vec3.fromValues(0, 0, 0);
    this.targetLineVec = vec3.fromValues(0, 0, 0);
  }
  onDrawEditor(ctx, drawing) {
    drawing.editorDrawer.drawaBrushCursor(ctx.brushBaseSize, ctx.currentVectorLayer.lineWidthBiasRate);
    drawing.editorDrawer.drawPointerCursor(ctx.toolBaseViewRadius);
    if (this.resampledStroke != null) {
      drawing.editorDrawer.drawOperatorSolidStroke(this.resampledStroke, ctx.currentVectorLayer.lineWidthBiasRate);
    }
  }
  mouseUp(_e, ctx) {
    ctx.tool.endModalTool();
    ctx.setRedrawEditorWindow();
    if (!this.isEditing || this.editStroke == null) {
      this.resetState(false);
      return;
    }
    VectorStrokeLogic.calculateParameters(this.editStroke);
    if (VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      this.resetState(false);
      return;
    }
    this.editStroke = this.generateResampledEditorStroke(this.editStroke, ctx);
    this.executeCommand(ctx);
    this.resetState(false);
  }
  keydown(_key, _commandID, _ctx) {
    return false;
  }
  generateResampledEditorStroke(editorLine, ctx) {
    const resamplingUnitLength = ctx.getViewScaledResamplingUnitLengthForEdit();
    const resampledLine = VectorStrokeLogic.createResampledLine(editorLine, resamplingUnitLength);
    VectorStrokeLogic.smooth(resampledLine, this.strokeSmoothLevel);
    return resampledLine;
  }
  getNearestStroke(targetPoint, geometry, minDistanceRange) {
    let nearestStroke = null;
    let nearestStroke_index = VectorStrokeHitTestLogic.InvalidIndex;
    let nearestStroke_segmentIndex = VectorStrokeHitTestLogic.InvalidIndex;
    let nearestStroke_drawingUnit = null;
    let nearestStroke_group = null;
    let minDistance = VectorStrokeHitTestLogic.MaxDistance;
    for (const unit of geometry.units) {
      for (const group of unit.groups) {
        for (const [strokeIndex, stroke] of group.lines.entries()) {
          if (stroke.runtime.modifyFlag != VectorStrokeModifyFlagID.none) {
            continue;
          }
          if (VectorStrokeHitTestLogic.hitTestLocationToStrokeByRectangle(targetPoint.location, stroke, minDistanceRange)) {
            const nearestSegmentIndex = VectorStrokeHitTestLogic.getNearestSegmentIndex(
              stroke,
              targetPoint.location
            );
            if (nearestSegmentIndex != VectorStrokeHitTestLogic.InvalidIndex) {
              const distance = Logic_Points.pointToLineSegment_SorroundingDistance(
                stroke.points[nearestSegmentIndex].location,
                stroke.points[nearestSegmentIndex + 1].location,
                targetPoint.location
              );
              if (distance < minDistanceRange) {
                if (distance < minDistance) {
                  minDistance = distance;
                  nearestStroke = stroke;
                  nearestStroke_index = strokeIndex;
                  nearestStroke_segmentIndex = nearestSegmentIndex;
                  nearestStroke_drawingUnit = unit;
                  nearestStroke_group = group;
                }
              }
            }
          }
        }
      }
    }
    return {
      isAvailable: nearestStroke != null,
      stroke: nearestStroke,
      strokeIndex: nearestStroke_index,
      segmentIndex: nearestStroke_segmentIndex,
      unit: nearestStroke_drawingUnit,
      group: nearestStroke_group
    };
  }
  getSearchDirectionForTargetLine(nearestStroke, nearestStroke_segmentIndex, inputStroke_firstPoint, inputStroke_secondPoint) {
    const point1 = nearestStroke.points[nearestStroke_segmentIndex];
    const point2 = nearestStroke.points[nearestStroke_segmentIndex + 1];
    const firstPoint_Position = Logic_Points.pointToLineSegment_NormalizedPosition(
      point1.location,
      point2.location,
      inputStroke_firstPoint.location
    );
    const secondPoint_Position = Logic_Points.pointToLineSegment_NormalizedPosition(
      point1.location,
      point2.location,
      inputStroke_secondPoint.location
    );
    return {
      isAvailable: secondPoint_Position != firstPoint_Position,
      searchForward: secondPoint_Position >= firstPoint_Position
    };
  }
  getLineOverlappingInfo(sourcePoints, source_StartIndex, targetPoints, target_StartIndex, minDistanceRange, searchForward) {
    let source_Index = source_StartIndex;
    let target_Index = target_StartIndex;
    let isAvailable = true;
    let overlap_FirstIndex = -1;
    let overlap_LastIndex = -1;
    while (source_Index < sourcePoints.length && target_Index + 1 < targetPoints.length) {
      const sourcePoint = sourcePoints[source_Index];
      const targetPoint1 = targetPoints[target_Index];
      const targetPoint2 = targetPoints[target_Index + 1];
      const distance = Logic_Points.pointToLine_Distance(
        targetPoint1.location,
        targetPoint2.location,
        sourcePoint.location
      );
      if (distance > minDistanceRange) {
        isAvailable = false;
        break;
      }
      const localPosition = Logic_Points.pointToLineSegment_NormalizedPosition(
        targetPoint1.location,
        targetPoint2.location,
        sourcePoint.location
      );
      if (localPosition <= 1) {
        if (localPosition >= 0) {
          if (overlap_FirstIndex == -1) {
            overlap_FirstIndex = source_Index;
          }
          overlap_LastIndex = source_Index;
        }
        if (source_Index >= sourcePoints.length - 1) {
          break;
        } else {
          source_Index++;
        }
      } else {
        if (target_Index >= targetPoints.length - 2) {
          break;
        } else {
          target_Index++;
        }
      }
    }
    const firstIndex = this.getReorderedPointIndex(sourcePoints.length, overlap_FirstIndex, searchForward);
    const lastIndex = this.getReorderedPointIndex(sourcePoints.length, overlap_LastIndex, searchForward);
    return {
      isAvailable,
      overlap_FirstIndex: searchForward ? firstIndex : lastIndex,
      overlap_LastIndex: searchForward ? lastIndex : firstIndex
    };
  }
  createSubjoinedLine(topPoints, followingPoints, followingPoints_OverlappingInfo, resamplingUnitLength, subjoinToAfter) {
    let newPoints = [];
    let subjoinedIndex;
    if (subjoinToAfter) {
      Lists.addRange(newPoints, topPoints);
      subjoinedIndex = newPoints.length - 1;
      const followingPoints_startIndex = followingPoints_OverlappingInfo.overlap_LastIndex != -1 ? followingPoints_OverlappingInfo.overlap_LastIndex + 1 : 0;
      Lists.addRange(newPoints, Lists.getRangeToLast(followingPoints, followingPoints_startIndex));
    } else {
      const followingPoints_length = followingPoints_OverlappingInfo.overlap_FirstIndex != -1 ? followingPoints_OverlappingInfo.overlap_FirstIndex : followingPoints.length;
      Lists.addRange(newPoints, Lists.getRange(followingPoints, 0, followingPoints_length));
      subjoinedIndex = newPoints.length - 1;
      Lists.addRange(newPoints, topPoints);
    }
    if (subjoinedIndex < 0) {
      subjoinedIndex = 0;
    }
    if (subjoinedIndex - 2 >= 0 && subjoinedIndex + 4 <= newPoints.length - 1) {
      const resampledPoins = [];
      Lists.addRange(resampledPoins, Lists.getRange(newPoints, 0, subjoinedIndex - 2 + 1));
      VectorPointLogic.resamplePoints(
        resampledPoins,
        newPoints,
        subjoinedIndex - 1,
        subjoinedIndex + 3,
        resamplingUnitLength
      );
      Lists.addRange(resampledPoins, Lists.getRangeToLast(newPoints, subjoinedIndex + 4));
      newPoints = resampledPoins;
    }
    const new_stroke = new VectorStroke();
    for (const point of newPoints) {
      new_stroke.points.push(VectorPoint.clone(point));
    }
    return new_stroke;
  }
  executeProcessForStroke(state, input_stroke, subjoinFromTailOfInput, ctx, limitTargetForSurroundingFillLayer = false) {
    const input_points = this.getReorderedPoints(input_stroke.points, subjoinFromTailOfInput);
    const input_firstPoint = input_points[0];
    const minDistanceRange = ctx.toolBaseViewRadius;
    const nearest_stroke = this.getNearestStroke(input_firstPoint, ctx.currentVectorLayerGeometry, minDistanceRange);
    if (!nearest_stroke.isAvailable) {
      return false;
    }
    const input_secondPoint = input_points[1];
    const searchDirection = this.getSearchDirectionForTargetLine(
      nearest_stroke.stroke,
      nearest_stroke.segmentIndex,
      input_firstPoint,
      input_secondPoint
    );
    if (!searchDirection.isAvailable) {
      return false;
    }
    if (state.subjoinedStroke != null) {
      if (limitTargetForSurroundingFillLayer) {
        if (nearest_stroke.group != state.subjoinedStroke.group) {
          return false;
        }
        const isAvailable = nearest_stroke.strokeIndex == state.subjoinedStroke.strokeIndex + 1 && !searchDirection.searchForward || nearest_stroke.strokeIndex == state.subjoinedStroke.strokeIndex - 1 && searchDirection.searchForward;
        if (!isAvailable) {
          return false;
        }
      } else {
        if (nearest_stroke.group != state.subjoinedStroke.group) {
          return false;
        }
      }
    }
    const target_reorderedPoints = this.getReorderedPoints(nearest_stroke.stroke.points, searchDirection.searchForward);
    const target_segmentIndex = this.getReorderedSegmentIndex(nearest_stroke.stroke.points.length, nearest_stroke.segmentIndex, searchDirection.searchForward);
    const input_overlappingInfo = this.getLineOverlappingInfo(
      input_points,
      0,
      target_reorderedPoints,
      target_segmentIndex,
      minDistanceRange,
      searchDirection.searchForward
    );
    const target_overlappingInfo = this.getLineOverlappingInfo(
      target_reorderedPoints,
      target_segmentIndex,
      input_points,
      0,
      minDistanceRange,
      searchDirection.searchForward
    );
    if (!input_overlappingInfo.isAvailable || !target_overlappingInfo.isAvailable) {
      return false;
    }
    const reordered_inputPoints = this.getReorderedPoints(input_points, searchDirection.searchForward);
    const resamplingUnitLengthBrush = ctx.getViewScaledResamplingUnitLengthForBrush();
    const new_stroke = this.createSubjoinedLine(
      nearest_stroke.stroke.points,
      reordered_inputPoints,
      input_overlappingInfo,
      resamplingUnitLengthBrush,
      searchDirection.searchForward
    );
    VectorStrokeLogic.calculateParameters(new_stroke);
    nearest_stroke.stroke.runtime.modifyFlag = VectorStrokeModifyFlagID.delete;
    state.deleteLines.push(nearest_stroke.stroke);
    state.newLine = new_stroke;
    state.subjoinedStroke = nearest_stroke;
    state.subjoinedForward = searchDirection.searchForward;
    return true;
  }
  getReorderedPoints(points, searchForward) {
    return searchForward ? points : Lists.cloneReversed(points);
  }
  getReorderedSegmentIndex(strokePointCount, segmentIndex, searchForward) {
    return searchForward ? segmentIndex : strokePointCount - 1 - segmentIndex - 1;
  }
  getReorderedPointIndex(strokePointCount, pointIndex, searchForward) {
    if (pointIndex < 0) {
      return pointIndex;
    }
    return searchForward ? pointIndex : strokePointCount - 1 - pointIndex;
  }
  executeCommand(ctx) {
    if (VectorStrokeLogic.isEmptyStroke(this.editStroke)) {
      return;
    }
    let state = new SubjoinProcessingState();
    const forward_isAvailable = this.executeProcessForStroke(state, this.editStroke, true, ctx);
    let backward_isAvailable = false;
    if (!forward_isAvailable) {
      state = new SubjoinProcessingState();
      backward_isAvailable = this.executeProcessForStroke(state, this.editStroke, false, ctx);
    }
    if (forward_isAvailable || backward_isAvailable) {
      const first_subjoinedStroke = state.subjoinedStroke;
      const limitTargetForSurroundingFillLayer = VectorLayer.isSurroundingFillLayer(ctx.currentLayer);
      this.executeProcessForStroke(state, state.newLine, !state.subjoinedForward, ctx, limitTargetForSurroundingFillLayer);
      VectorStrokeLogic.calculateParameters(state.newLine, ctx.currentVectorLayer.lineWidthBiasRate);
      const command = new Command_InsertStroke();
      command.setTarget(
        ctx.currentVectorLayer,
        ctx.currentVectorLayerGeometry,
        first_subjoinedStroke.group,
        state.newLine,
        first_subjoinedStroke.strokeIndex
      );
      ctx.commandHistory.executeCommand(command, ctx);
    }
    ctx.setRedrawCurrentLayer();
    ctx.setRedrawEditorWindow();
  }
}
class Command_InsertStroke extends CommandBase {
  constructor() {
    super(...arguments);
    this.layer = null;
    this.geometry = null;
    this.group = null;
    this.stroke = null;
    this.insertIndex = -1;
  }
  setTarget(layer, geometry, group, stroke, insertIndex) {
    this.layer = layer;
    this.geometry = geometry;
    this.group = group;
    this.stroke = stroke;
    this.insertIndex = insertIndex;
  }
  execute(ctx) {
    this.redo(ctx);
    this.defferedProcess.addGroup(this.layer, this.group, PostUpdateSituationTypeID.changesObjectShapes);
    this.defferedProcess.addGeometryForDeletingEmpties(this.geometry);
  }
  undo(_ctx) {
    Lists.removeAt(this.group.lines, this.insertIndex);
  }
  redo(_ctx) {
    Lists.insertAt(this.group.lines, this.insertIndex, this.stroke);
  }
}
class Tool_ScratchLineWidth_EditPoint {
  constructor() {
    this.pair = null;
    this.newLineWidth = 0;
    this.oldLineWidth = 0;
    this.newLocation = vec3.create();
    this.oldLocation = vec3.create();
  }
}
class Tool_OverWriteLineWidth extends Tool_ScratchLine {
  constructor() {
    super(...arguments);
    this.helpText = "\u7DDA\u3092\u6700\u5927\u306E\u592A\u3055\u306B\u8FD1\u3065\u3051\u307E\u3059\u3002Shift\u30AD\u30FC\u3067\u7DDA\u3092\u7D30\u304F\u3057\u307E\u3059\u3002<br />Ctrl\u30AD\u30FC\u3067\u6700\u5927\u306E\u592A\u3055\u56FA\u5B9A\u306B\u306A\u308A\u307E\u3059\u3002";
    this.editFalloffRadiusContainsLineWidth = true;
  }
  executeCommand(ctx) {
    if (VectorStrokeLogic.isEmptyStroke(this.resampledStroke)) {
      return;
    }
    const baseRadius = ctx.toolBaseViewRadius;
    const targetLine = ctx.activeVectorLine;
    const oldPoints = targetLine.points;
    const editFalloffRadiusMin = baseRadius * this.editFalloffRadiusMinRate;
    const editFalloffRadiusMax = baseRadius * this.editFalloffRadiusMaxRate;
    const candidatePointPairs = this.ganerateScratchingCandidatePoints(
      targetLine,
      this.resampledStroke,
      editFalloffRadiusMin,
      editFalloffRadiusMax,
      this.editFalloffRadiusContainsLineWidth
    );
    if (candidatePointPairs != null && candidatePointPairs.length > 0) {
      const command = new Command_ScratchLineWidth();
      command.targetLine = targetLine;
      command.layer = ctx.currentVectorLayer;
      for (const pair of candidatePointPairs) {
        const editPoint = new Tool_ScratchLineWidth_EditPoint();
        editPoint.pair = pair;
        editPoint.oldLineWidth = editPoint.pair.targetPoint.lineWidth;
        vec3.copy(editPoint.oldLocation, editPoint.pair.targetPoint.location);
        this.processPoint(editPoint, ctx);
        command.editPoints.push(editPoint);
      }
      command.defferedProcess.addGroup(ctx.currentLayer, ctx.activeVectorGroup, PostUpdateSituationTypeID.changesObjectShapes);
      ctx.commandHistory.executeCommand(command, ctx);
    }
    VectorLayerLogic.clearPointModifyFlags(oldPoints);
  }
  processPoint(editPoint, ctx) {
    let setTo_LineWidth = ctx.drawLineBaseWidth;
    if (ctx.isShiftKeyPressing()) {
      setTo_LineWidth = ctx.drawLineMinWidth;
    }
    let fixedOverWriting = false;
    if (ctx.isCtrlKeyPressing()) {
      fixedOverWriting = true;
    }
    vec3.copy(editPoint.newLocation, editPoint.pair.targetPoint.location);
    if (editPoint.pair.influence > 0) {
      if (fixedOverWriting) {
        editPoint.newLineWidth = setTo_LineWidth;
      } else {
        editPoint.newLineWidth = Maths.lerp(
          editPoint.pair.influence * 0.5,
          editPoint.pair.targetPoint.lineWidth,
          setTo_LineWidth
        );
      }
    } else {
      editPoint.newLineWidth = editPoint.pair.targetPoint.lineWidth;
    }
  }
}
class Tool_ScratchLineWidth extends Tool_OverWriteLineWidth {
  constructor() {
    super(...arguments);
    this.helpText = "\u7DDA\u306E\u592A\u3055\u3092\u8DB3\u3057\u307E\u3059\u3002Shift\u30AD\u30FC\u3067\u6E1B\u3089\u3057\u307E\u3059\u3002";
    this.editFalloffRadiusMinRate = 0.15;
    this.editFalloffRadiusMaxRate = 1;
    this.editInfluence = 1;
    this.subtructVector = vec3.create();
    this.moveVector = vec3.create();
  }
  processPoint(editPoint, ctx) {
    const targetPoint = editPoint.pair.targetPoint;
    const candidatePoint = editPoint.pair.candidatePoint;
    const targetPointRadius = targetPoint.lineWidth * 0.5;
    const candidatePointRadius = candidatePoint.lineWidth * 0.5;
    const distance = vec3.distance(targetPoint.location, candidatePoint.location);
    if (!ctx.isShiftKeyPressing()) {
      if (distance + candidatePointRadius > targetPointRadius && distance - candidatePointRadius > -targetPointRadius) {
        const totalDiameter = targetPointRadius + distance + candidatePointRadius;
        const totalRadius = totalDiameter * 0.5;
        const newRadius = Maths.lerp(
          editPoint.pair.influence,
          targetPointRadius,
          totalRadius
        );
        editPoint.newLineWidth = newRadius * 2;
        vec3.subtract(this.subtructVector, candidatePoint.location, targetPoint.location);
        vec3.normalize(this.subtructVector, this.subtructVector);
        vec3.scale(this.moveVector, this.subtructVector, -targetPointRadius + newRadius);
        vec3.add(editPoint.newLocation, targetPoint.location, this.moveVector);
      } else if (candidatePointRadius > targetPointRadius) {
        editPoint.newLineWidth = candidatePointRadius * 2;
        vec3.copy(editPoint.newLocation, candidatePoint.location);
      } else {
        editPoint.newLineWidth = targetPoint.lineWidth;
        vec3.copy(editPoint.newLocation, targetPoint.location);
      }
    } else {
      if (distance - candidatePointRadius < targetPointRadius && distance - candidatePointRadius > -targetPointRadius) {
        const totalDiameter = targetPointRadius + distance - candidatePointRadius;
        const totalRadius = totalDiameter * 0.5;
        const newRadius = Maths.lerp(
          editPoint.pair.influence,
          targetPointRadius,
          totalRadius
        );
        editPoint.newLineWidth = newRadius * 2;
        vec3.subtract(this.subtructVector, candidatePoint.location, targetPoint.location);
        vec3.normalize(this.subtructVector, this.subtructVector);
        vec3.scale(this.moveVector, this.subtructVector, -targetPointRadius + newRadius);
        vec3.add(editPoint.newLocation, targetPoint.location, this.moveVector);
      } else if (distance < candidatePointRadius) {
        editPoint.newLineWidth = 0;
        vec3.copy(editPoint.newLocation, targetPoint.location);
      } else {
        editPoint.newLineWidth = targetPoint.lineWidth;
        vec3.copy(editPoint.newLocation, targetPoint.location);
      }
    }
  }
}
class Command_ScratchLineWidth extends CommandBase {
  constructor() {
    super(...arguments);
    this.targetLine = null;
    this.editPoints = [];
    this.layer = null;
  }
  execute(ctx) {
    this.redo(ctx);
  }
  undo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.pair.targetPoint;
      targetPoint.lineWidth = editPoint.oldLineWidth;
      targetPoint.adjustingLineWidth = editPoint.oldLineWidth;
      vec3.copy(targetPoint.location, editPoint.oldLocation);
      vec3.copy(targetPoint.adjustingLocation, editPoint.oldLocation);
    }
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
  redo(_ctx) {
    for (const editPoint of this.editPoints) {
      const targetPoint = editPoint.pair.targetPoint;
      targetPoint.lineWidth = editPoint.newLineWidth;
      targetPoint.adjustingLineWidth = editPoint.newLineWidth;
      vec3.copy(targetPoint.location, editPoint.newLocation);
      vec3.copy(targetPoint.adjustingLocation, editPoint.newLocation);
    }
    VectorStrokeLogic.calculateParameters(this.targetLine, this.layer.lineWidthBiasRate);
  }
}
class Tool_Select_All_LinePoint extends SubTool {
  executeToggleSelection(ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    const existsSelectedPoints = this.isSelectedAnyPoint(viewKeyframeLayers);
    return this.executeModifySelection(viewKeyframeLayers, existsSelectedPoints, ctx);
  }
  executeSelectAll(ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    return this.executeModifySelection(viewKeyframeLayers, false, ctx);
  }
  executeClearSelectAll(ctx) {
    const viewKeyframeLayers = ctx.main.collectVectorViewKeyframeLayersForEdit();
    return this.executeModifySelection(viewKeyframeLayers, true, ctx);
  }
  executeModifySelection(editableKeyframeLayers, clearSelection, ctx) {
    let selectionInfo;
    if (clearSelection) {
      selectionInfo = this.createSelectionInfo_ClearAllSelection(editableKeyframeLayers);
    } else {
      selectionInfo = this.createSelectionInfo_SelectAll(editableKeyframeLayers);
    }
    if (selectionInfo.selectedPoints.length == 0) {
      return false;
    }
    selectionInfo.updateLineSelectionState();
    this.executeCommand(selectionInfo, ctx);
    selectionInfo.resetModifyStates();
    ctx.setRedrawMainWindowEditorWindow();
    return true;
  }
  isSelectedAnyPoint(viewKeyframeLayers) {
    let isSelected = false;
    ViewKeyframeLayer.forEachStrokeGroup(viewKeyframeLayers, (group) => {
      for (const line of group.lines) {
        if (line.isSelected) {
          isSelected = true;
          break;
        }
        for (const point of line.points) {
          if (point.isSelected) {
            isSelected = true;
            break;
          }
        }
      }
    });
    return isSelected;
  }
  createSelectionInfo_SelectAll(viewKeyframeLayers) {
    const selectionInfo = new VectorLayerSelectionInfo();
    ViewKeyframeLayer.forEachStrokeGroup(viewKeyframeLayers, (group) => {
      for (const line of group.lines) {
        for (const point of line.points) {
          if (!point.isSelected) {
            selectionInfo.selectPoint(line, point, SelectionEditMode.setSelected);
          }
        }
      }
    });
    return selectionInfo;
  }
  createSelectionInfo_ClearAllSelection(viewKeyframeLayers) {
    const selectionInfo = new VectorLayerSelectionInfo();
    ViewKeyframeLayer.forEachStrokeGroup(viewKeyframeLayers, (group) => {
      for (const line of group.lines) {
        for (const point of line.points) {
          if (point.isSelected) {
            selectionInfo.selectPoint(line, point, SelectionEditMode.setUnselected);
          }
        }
      }
    });
    return selectionInfo;
  }
  executeCommand(selectionInfo, ctx) {
    const command = new Command_Select();
    command.selectionInfo = selectionInfo;
    ctx.commandHistory.executeCommand(command, ctx);
  }
}
class App_Tool {
  constructor() {
    this.tool_None = new Tool_None();
    this.subTools = [];
    this.modalSubTools = [];
    this.posing3dSubTools = [];
    this.tool_NoOperation = new Tool_NoOperation();
    this.tool_DrawLine = new Tool_DrawLine();
    this.tool_ScratchLine = new Tool_ScratchLine();
    this.tool_ExtrudeLine = new Tool_ScratchLineDraw();
    this.tool_OverWriteLineWidth = new Tool_OverWriteLineWidth();
    this.tool_ScratchLineWidth = new Tool_ScratchLineWidth();
    this.tool_DeletePoints_DivideLine = new Tool_DeletePoints_DivideLine();
    this.tool_EditLinePointWidth_BrushSelect = new Tool_HideLinePoint_BrushSelect();
    this.tool_DrawPointBrush = new Tool_DrawPointBrush();
    this.tool_PointBrush_ExtrudeLine = new Tool_ScratchLineDraw();
    this.tool_AddAutoFillPoint = new Tool_AddAutoFillPoint();
    this.tool_DeleteAutoFillPoint = new Tool_DeleteAutoFillPoint();
    this.tool_EditModeMain = new Tool_EditModeMain();
    this.tool_LocateOperatorCursor = new Tool_LocateOperatorCursor();
    this.tool_BrushSelect = new Tool_Select_BrushSelect();
    this.tool_ResampleSegment = new Tool_Resample_Segment();
    this.tool_Transform_Lattice_GrabMove = new Tool_Transform_Lattice_GrabMove();
    this.tool_Transform_Lattice_Rotate = new Tool_Transform_Lattice_Rotate();
    this.tool_Transform_Lattice_Scale = new Tool_Transform_Lattice_Scale();
    this.tool_EditDocumentFrame = new Tool_EditDocumentFrame();
    this.tool_Transform_ReferenceImage_GrabMove = new Tool_Transform_ReferenceImage_GrabMove();
    this.tool_Transform_ReferenceImage_Rotate = new Tool_Transform_ReferenceImage_Rotate();
    this.tool_Transform_ReferenceImage_Scale = new Tool_Transform_ReferenceImage_Scale();
    this.tool_SelectAllPoints = new Tool_Select_All_LinePoint();
    this.hittest_Line_IsCloseTo = new HitTest_VectorStroke_IsCloseToMouse();
    this.tool_Posing3d_LocateHead = new Tool_Posing3d_LocateHead();
    this.tool_Posing3d_RotateHead = new Tool_Posing3d_RotateHead();
    this.tool_Posing3d_LocateBody = new Tool_Posing3d_LocateBody();
    this.tool_Posing3d_LocateHips = new Tool_Posing3d_LocateHips();
    this.tool_Posing3d_LocateLeftShoulder = new Tool_Posing3d_LocateLeftShoulder();
    this.tool_Posing3d_LocateRightShoulder = new Tool_Posing3d_LocateRightShoulder();
    this.tool_Posing3d_LocateLeftArm1 = new Tool_Posing3d_LocateLeftArm1();
    this.tool_Posing3d_LocateLeftArm2 = new Tool_Posing3d_LocateLeftArm2();
    this.tool_Posing3d_LocateRightArm1 = new Tool_Posing3d_LocateRightArm1();
    this.tool_Posing3d_LocateRightArm2 = new Tool_Posing3d_LocateRightArm2();
    this.tool_Posing3d_LocateLeftLeg1 = new Tool_Posing3d_LocateLeftLeg1();
    this.tool_Posing3d_LocateLeftLeg2 = new Tool_Posing3d_LocateLeftLeg2();
    this.tool_Posing3d_LocateRightLeg1 = new Tool_Posing3d_LocateRightLeg1();
    this.tool_Posing3d_LocateRightLeg2 = new Tool_Posing3d_LocateRightLeg2();
    this.pointerParameters = [
      { parameterID: PointerParameterID.none, baseSize: 0, minSize: 0 },
      { parameterID: PointerParameterID.extrudeLine, baseSize: 20, minSize: 1 },
      { parameterID: PointerParameterID.eracer, baseSize: 20, minSize: 1 },
      { parameterID: PointerParameterID.scratchLine, baseSize: 25, minSize: 1 },
      { parameterID: PointerParameterID.setLineWidth, baseSize: 20, minSize: 1 },
      { parameterID: PointerParameterID.brushSelect, baseSize: 20, minSize: 1 }
    ];
    this.brushParameters = [
      { parameterID: BrushParameterID.none, brushType: BrushTypeID.none, baseSize: 0, minSize: 0, stepRate: 1 },
      { parameterID: BrushParameterID.solidStroke, brushType: BrushTypeID.solidBrushStroke, baseSize: 1, minSize: 1, stepRate: 1 },
      { parameterID: BrushParameterID.pointBrush, brushType: BrushTypeID.radialBrush, baseSize: 25, minSize: 1, stepRate: 0.25 }
    ];
    this.subToolParameters = [
      { parameterID: SubToolParameterID.none, pointerType: PointerTypeID.none, pointerParameterID: PointerParameterID.none, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.drawLine, pointerType: PointerTypeID.brush, pointerParameterID: PointerParameterID.none, brushParameterID: BrushParameterID.solidStroke },
      { parameterID: SubToolParameterID.extrudeLine, pointerType: PointerTypeID.brushWithCircularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.solidStroke },
      { parameterID: SubToolParameterID.eracer, pointerType: PointerTypeID.circularRange, pointerParameterID: PointerParameterID.eracer, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.scratchLine, pointerType: PointerTypeID.circularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.setLineWidth, pointerType: PointerTypeID.circularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.scratchLineWidth, pointerType: PointerTypeID.circularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.brushSelect, pointerType: PointerTypeID.circularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.none },
      { parameterID: SubToolParameterID.drawPointBrush, pointerType: PointerTypeID.brush, pointerParameterID: PointerParameterID.none, brushParameterID: BrushParameterID.pointBrush },
      { parameterID: SubToolParameterID.pointBrush_extrudeLine, pointerType: PointerTypeID.brushWithCircularRange, pointerParameterID: PointerParameterID.extrudeLine, brushParameterID: BrushParameterID.pointBrush }
    ];
    this.mainTools = [];
    this.current_MainTool = null;
    this.current_MainToolTab = null;
    this.current_SubTool = null;
    this.current_ModalTool = null;
    this.modalBeforeTool = null;
    this.appView = null;
    this.appDrawing = null;
    this.docContext = null;
    this.subToolContext = null;
    this.baseColor = vec4.fromValues(0, 0, 0, 1);
  }
  link(appView, appDrawing) {
    this.appView = appView;
    this.appDrawing = appDrawing;
  }
  linkContexts(docContext, toolContext) {
    this.docContext = docContext;
    this.subToolContext = toolContext;
  }
  initializeTools() {
    this.appDrawing.posing3DView.storeResources(this.appView.modelFile, this.appView.imageResurces);
    const commonTabs = new MainToolCommonTabSet();
    commonTabs.edit = new MainToolTab_Edit();
    commonTabs.edit_disabled = new MainToolTab_EditDisabled();
    commonTabs.document = new MainToolTab_Document();
    commonTabs.layer = new MainToolTab_Layer();
    commonTabs.view = new MainToolTab_View();
    this.addMainTool(new MainTool_GroupLayer(commonTabs));
    this.addMainTool(new MainTool_VectorLayer(commonTabs));
    this.addMainTool(new MainTool_ImageFileReferenceLayer(commonTabs));
    this.addMainTool(new MainTool_AutoFillLayer(commonTabs));
    this.addMainTool(new MainTool_Poing3DLayer(commonTabs));
    this.addMainTool(new MainTool_PointBrushFillLayer(commonTabs));
    this.addSubTool(this.tool_NoOperation, SubToolID.noOperation, SubToolParameterID.none);
    this.addModalSubTool(this.tool_DrawLine, SubToolID.drawLine, SubToolParameterID.drawLine);
    this.addModalSubTool(this.tool_ScratchLine, SubToolID.scratchLine, SubToolParameterID.scratchLine);
    this.addModalSubTool(this.tool_ExtrudeLine, SubToolID.extrudeLine, SubToolParameterID.extrudeLine);
    this.addModalSubTool(this.tool_OverWriteLineWidth, SubToolID.overWriteLineWidth, SubToolParameterID.setLineWidth);
    this.addModalSubTool(this.tool_ScratchLineWidth, SubToolID.scratchLineWidth, SubToolParameterID.scratchLineWidth);
    this.addModalSubTool(this.tool_DeletePoints_DivideLine, SubToolID.deletePointBrush, SubToolParameterID.eracer);
    this.addModalSubTool(this.tool_EditLinePointWidth_BrushSelect, SubToolID.editLinePointWidth_BrushSelect, SubToolParameterID.brushSelect);
    this.addModalSubTool(this.tool_DrawPointBrush, SubToolID.drawPointBrush, SubToolParameterID.drawPointBrush);
    this.addModalSubTool(this.tool_PointBrush_ExtrudeLine, SubToolID.pointBrush_extrudeLine, SubToolParameterID.pointBrush_extrudeLine);
    this.addSubTool(this.tool_AddAutoFillPoint, SubToolID.addAutoFillPoint, SubToolParameterID.brushSelect);
    this.addSubTool(this.tool_DeleteAutoFillPoint, SubToolID.deleteAutoFillPoint, SubToolParameterID.brushSelect);
    this.addModalSubTool(this.tool_EditModeMain, SubToolID.editModeMain, SubToolParameterID.brushSelect);
    this.addSubTool(this.tool_LocateOperatorCursor, SubToolID.locateOperatorCursor);
    this.addModalSubTool(this.tool_BrushSelect, SubToolID.brushSelect, SubToolParameterID.brushSelect);
    this.addSubTool(this.tool_ResampleSegment, SubToolID.resampleSegment, SubToolParameterID.brushSelect);
    this.addModalSubTool(this.tool_Transform_Lattice_GrabMove, SubToolID.edit_GrabMove);
    this.addModalSubTool(this.tool_Transform_Lattice_Rotate, SubToolID.edit_Rotate);
    this.addModalSubTool(this.tool_Transform_Lattice_Scale, SubToolID.edit_Scale);
    this.addModalSubTool(this.tool_EditDocumentFrame, SubToolID.editDocumentFrame);
    this.addModalSubTool(this.tool_Transform_ReferenceImage_GrabMove, SubToolID.image_GrabMove);
    this.addModalSubTool(this.tool_Transform_ReferenceImage_Rotate, SubToolID.image_Rotate);
    this.addModalSubTool(this.tool_Transform_ReferenceImage_Scale, SubToolID.image_Scale);
    this.addModalSubTool(this.tool_Posing3d_LocateHead, SubToolID.p3d_locateHead);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateHead, SubToolID.p3d_locateHead, 0);
    this.addPosing3DSubTool(this.tool_Posing3d_RotateHead, SubToolID.p3d_rotateHead, 1);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateBody, SubToolID.p3d_locateBody, 2);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateHips, SubToolID.p3d_locateHips, 3);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateLeftShoulder, SubToolID.p3d_locateLeftShoulder, 4);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateLeftArm1, SubToolID.p3d_locateLeftArm1, 4);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateLeftArm2, SubToolID.p3d_locateLeftArm2, 5);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateRightShoulder, SubToolID.p3d_locateRightShoulder, 6);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateRightArm1, SubToolID.p3d_locateRightArm1, 6);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateRightArm2, SubToolID.p3d_locateRightArm2, 7);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateLeftLeg1, SubToolID.p3d_locateLeftLeg1, 8);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateLeftLeg2, SubToolID.p3d_locateLeftLeg2, 9);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateRightLeg1, SubToolID.p3d_locateRightLeg1, 10);
    this.addPosing3DSubTool(this.tool_Posing3d_LocateRightLeg2, SubToolID.p3d_locateRightLeg2, 11);
    this.updateSubToolParameterReferences();
    this.current_MainTool = this.getMainTool(MainToolID.vector);
    this.current_MainToolTab = this.current_MainTool.mainToolTabs[0];
    this.current_MainToolTab.current_SubTool = this.getSubTool(this.current_MainToolTab.default_SubToolID);
    this.current_SubTool = this.current_MainToolTab.current_SubTool;
  }
  addMainTool(tool) {
    tool.drawMode_MainToolTab = tool.mainToolTabs[0];
    this.mainTools.push(tool);
  }
  addSubTool(tool, subtoolID, parameterID) {
    tool.subtoolID = subtoolID;
    tool.subToolParameterID = parameterID != null ? parameterID : SubToolParameterID.none;
    this.subTools.push(tool);
  }
  addModalSubTool(tool, subtoolID, parameterID) {
    this.addSubTool(tool, subtoolID, parameterID);
    this.modalSubTools.push(tool);
  }
  addPosing3DSubTool(tool, subtoolID, toolBarImageIndex) {
    this.addModalSubTool(tool, subtoolID);
    tool.toolBarImage = this.appView.subToolImages[0];
    tool.toolBarImageIndex = toolBarImageIndex;
    this.posing3dSubTools.push(tool);
  }
  updateBrushParameterReferences() {
    if (this.docContext != null) {
      this.docContext.currentBrushParameter = this.brushParameters[0];
    }
  }
  updateSubToolParameterReferences() {
    for (const subToolParameter of this.subToolParameters) {
      const pointerParameter = this.pointerParameters.find((param) => param.parameterID == subToolParameter.pointerParameterID);
      subToolParameter.pointer = pointerParameter != null ? pointerParameter : null;
      const brushParameter = this.brushParameters.find((param) => param.parameterID == subToolParameter.brushParameterID);
      subToolParameter.brush = brushParameter != null ? brushParameter : null;
    }
    for (const subTool of this.subTools) {
      if (subTool.subToolParameterID != SubToolParameterID.none) {
        const subToolParameter = this.subToolParameters.find((param) => param.parameterID == subTool.subToolParameterID);
        if (subToolParameter) {
          subTool.subToolParameter = subToolParameter;
        }
      }
    }
  }
  changeCurrentMainToolForEditMode(editModeID) {
    const mainTool = this.getCurrentMainTool();
    let mainToolTab;
    if (editModeID == EditModeID.drawMode) {
      mainToolTab = mainTool.drawMode_MainToolTab;
    } else {
      mainToolTab = this.getCurrentMainToolEditTab();
    }
    if (mainToolTab == null || mainToolTab.disabled) {
      return;
    }
    this.changeCurrentMainToolTab(mainToolTab.tabID);
    this.setCurrentSubToolForCurrentTab();
  }
  executeMainToolKeyDown(key, commandID) {
    return this.current_MainToolTab.keydown(key, commandID, this.subToolContext);
  }
  executeMainToolButtonClick(id2) {
    return this.current_MainToolTab.buttonClick(id2, this.subToolContext);
  }
  getCurrentMainTool() {
    return this.current_MainTool;
  }
  getMainTool(mainToolID) {
    return this.mainTools.find((tool) => tool.mainToolID == mainToolID);
  }
  getMainToolForLayer(layer) {
    let mainToolID = MainToolID.none;
    switch (layer.type) {
      case LayerTypeID.groupLayer:
        mainToolID = MainToolID.group;
        break;
      case LayerTypeID.autoFillLayer:
        mainToolID = MainToolID.autoFill;
        break;
      case LayerTypeID.vectorLayer:
      case LayerTypeID.surroundingFillLayer:
        mainToolID = MainToolID.vector;
        break;
      case LayerTypeID.pointBrushFillLayer:
        mainToolID = MainToolID.pointBrushFill;
        break;
      case LayerTypeID.imageFileReferenceLayer:
        mainToolID = MainToolID.imageFileReference;
        break;
      case LayerTypeID.posingLayer:
        mainToolID = MainToolID.posing3D;
        break;
    }
    const mainTool = this.mainTools.find((mainTool2) => mainTool2.mainToolID == mainToolID);
    if (mainTool) {
      return mainTool;
    } else {
      throw new Error(`ERROR 0003:There is no main tool for the layer. (${LayerTypeID[layer.type]})`);
    }
  }
  setCurrentMainTool(mainToolID) {
    let isChanged = this.docContext.mainToolID != mainToolID;
    const mainTool = this.getMainTool(mainToolID);
    this.current_MainTool = mainTool;
    this.docContext.mainToolID = mainToolID;
    this.docContext.mainToolTabs = mainTool.mainToolTabs;
    if (mainTool.mainToolID == MainToolID.posing3D) {
      this.appView.subToolWindow.collectViewItems(this.posing3dSubTools, this.subToolContext);
    }
    if (isChanged) {
      this.setCurrentMainToolTabForCurrentMainTool();
      this.setCurrentSubToolForCurrentTab();
      this.activateCurrentTool();
      this.subToolContext.setRedrawWindowsForCurrentToolChanging();
      this.updateFooterMessage();
    }
  }
  changeCurrentMainToolTab(tabID) {
    this.setCurrentMainToolTab(tabID);
    this.setCurrentSubToolForCurrentTab();
  }
  setCurrentMainToolTabForCurrentMainTool() {
    const mainToolTab = this.findMainToolTab(this.docContext.mainToolTabID);
    if (mainToolTab) {
      this.setCurrentMainToolTab(mainToolTab.tabID);
    } else {
      const mainTool = this.getCurrentMainTool();
      this.setCurrentMainToolTab(mainTool.mainToolTabs[0].tabID);
    }
  }
  setCurrentMainToolTab(tabID) {
    const mainToolTab = this.findMainToolTab(tabID);
    if (mainToolTab.type == MainToolTabTypeID.editingTool) {
      this.docContext.editMode = EditModeID.editMode;
    } else {
      this.docContext.editMode = EditModeID.drawMode;
    }
    this.current_MainToolTab = mainToolTab;
    if (mainToolTab.current_SubTool == null) {
      const subtool = this.getSubTool(mainToolTab.default_SubToolID);
      mainToolTab.current_SubTool = subtool;
    }
    this.docContext.mainToolTabID = tabID;
    if (this.subToolContext.isDrawMode()) {
      const mainTool = this.getCurrentMainTool();
      mainTool.drawMode_MainToolTab = this.current_MainToolTab;
    }
  }
  findMainToolTab(tabID) {
    const tab = this.current_MainTool.mainToolTabs.find((tab2) => tab2.tabID == tabID);
    return tab;
  }
  getCurrentSubTool() {
    return this.current_SubTool;
  }
  isSubToolAvailable(subToolID) {
    const ctx = this.subToolContext;
    const subTool = this.getSubTool(subToolID);
    return subTool.isAvailable(ctx);
  }
  isCurrentSubToolAvailable() {
    return this.current_SubTool.isAvailable(this.subToolContext);
  }
  changeCurrentSubToolForSubtoolID(subToolID) {
    this.setCurrentSubTool(subToolID);
    this.activateCurrentTool();
    this.getCurrentSubTool().toolWindowItemClick(this.subToolContext);
  }
  setCurrentSubTool(subtoolID) {
    var _a, _b, _c, _d, _e;
    const subtool = this.getSubTool(subtoolID);
    this.cancelModalTool();
    this.current_SubTool = subtool;
    this.current_MainToolTab.current_SubTool = subtool;
    this.docContext.subtoolID = subtool.subtoolID;
    this.docContext.currentSubToolParameter = (_a = this.current_SubTool.subToolParameter) != null ? _a : null;
    this.docContext.currentBrushParameter = (_c = (_b = this.current_SubTool.subToolParameter) == null ? void 0 : _b.brush) != null ? _c : null;
    this.docContext.currentPointerParameter = (_e = (_d = this.current_SubTool.subToolParameter) == null ? void 0 : _d.pointer) != null ? _e : null;
    this.subToolContext.updateContext();
    this.activateCurrentTool();
    this.subToolContext.setRedrawWindowsForCurrentToolChanging();
    this.updateFooterMessage();
  }
  setCurrentSubToolForCurrentTab() {
    this.setCurrentSubTool(this.current_MainToolTab.current_SubTool.subtoolID);
  }
  getSubTool(subtoolID) {
    const subTool = this.subTools.find((tool) => tool.subtoolID == subtoolID);
    if (!subTool) {
      throw new Error("ERROR 0004:Sub tool does not exists.");
    }
    return subTool;
  }
  getModalSubTool(subtoolID) {
    const subTool = this.modalSubTools.find((tool) => tool.subtoolID == subtoolID);
    if (!subTool) {
      throw new Error("ERROR 0004:Modal sub tool does not exists.");
    }
    return subTool;
  }
  getCurrentMainToolEditTab() {
    const tab = this.current_MainTool.mainToolTabs.find((tab2) => tab2.type == MainToolTabTypeID.editingTool);
    return tab;
  }
  updateFooterMessage() {
    this.appView.footerWindow.setFooterText(this.current_SubTool.helpText);
    this.docContext.redrawFooterWindow = true;
  }
  updateContextCurrentRefferences() {
    const viewKeyframe = this.docContext.currentViewKeyframe;
    const currentLayer = this.docContext.currentLayer;
    this.docContext.currentStrokeDrawable = null;
    this.docContext.currentFillDrawable = null;
    this.docContext.currentVectorLayer = null;
    this.docContext.currentVectorLayerKeyframe = null;
    this.docContext.currentVectorLayerGeometry = null;
    if (VectorLayer.isVectorLayer(currentLayer) && viewKeyframe != null) {
      const viewKeyframeLayer = ViewKeyframe.findViewKeyframeLayer(viewKeyframe, currentLayer);
      const geometry = viewKeyframeLayer.vectorLayerKeyframe.geometry;
      this.docContext.currentVectorLayer = currentLayer;
      this.docContext.currentVectorLayerKeyframe = viewKeyframeLayer.vectorLayerKeyframe;
      this.docContext.currentVectorLayerGeometry = geometry;
      this.docContext.currentStrokeDrawable = this.docContext.currentVectorLayer;
      this.docContext.currentFillDrawable = this.docContext.currentVectorLayer;
    }
    this.docContext.currentPosingLayer = null;
    this.docContext.currentPosingData = null;
    this.docContext.currentPosingModel = null;
    if (PosingLayer.isPosingLayer(currentLayer)) {
      const posingLayer = currentLayer;
      this.docContext.currentPosingLayer = posingLayer;
      this.docContext.currentPosingData = posingLayer.posingData;
      this.docContext.currentPosingModel = posingLayer.posingModel;
    }
    this.docContext.currentAutoFillLayer = null;
    if (AutoFillLayer.isAutoFillLayer(currentLayer) && viewKeyframe != null) {
      this.docContext.currentAutoFillLayer = currentLayer;
      this.docContext.currentFillDrawable = this.docContext.currentAutoFillLayer;
    }
    this.docContext.currentImageFileReferenceLayer = null;
    if (ImageFileReferenceLayer.isImageFileReferenceLayer(currentLayer)) {
      const imageFileReferenceLayer = currentLayer;
      this.docContext.currentImageFileReferenceLayer = imageFileReferenceLayer;
    }
    this.updateCurrentPaintParameters();
    this.updateActiveRefferences();
  }
  updateActiveRefferences() {
    var _a, _b;
    const viewKeyframe = this.docContext.currentViewKeyframe;
    const currentLayer = this.docContext.currentLayer;
    if (VectorLayer.isVectorLayer(currentLayer) && viewKeyframe != null) {
      const viewKeyframeLayer = ViewKeyframe.findViewKeyframeLayer(viewKeyframe, currentLayer);
      const geometry = viewKeyframeLayer.vectorLayerKeyframe.geometry;
      const lastGroup = (_b = (_a = geometry.units.at(-1)) == null ? void 0 : _a.groups.at(-1)) != null ? _b : null;
      if (VectorLayer.isSingleGroupVectorLayer(currentLayer)) {
        this.docContext.activeVectorGeometry = geometry;
        this.docContext.activeVectorGroup = lastGroup;
      }
    }
  }
  updateCurrentPaintParameters() {
    if (this.docContext.currentVectorLayer != null) {
      this.appDrawing.drawingVectorLayer.getStrokeColor(
        this.baseColor,
        this.docContext.currentVectorLayer,
        this.docContext.documentData,
        false,
        false
      );
      vec4.copy(this.docContext.currentPaintParameter.baseColor, this.baseColor);
    } else {
      vec4.set(this.docContext.currentPaintParameter.baseColor, 0, 0, 0, 1);
    }
  }
  executeSubToolKeyDown(key, commandID) {
    return this.current_SubTool.keydown(key, commandID, this.subToolContext);
  }
  executeSubToolMouseDown(e) {
    this.current_SubTool.mouseDown(e, this.subToolContext);
  }
  executeSubToolMouseMove(e) {
    this.current_SubTool.mouseMove(e, this.subToolContext);
  }
  executeSubToolMouseUp(e) {
    this.current_SubTool.mouseUp(e, this.subToolContext);
  }
  executeUndo() {
    this.docContext.commandHistory.undo(this.subToolContext);
  }
  executeRedo() {
    this.docContext.commandHistory.redo(this.subToolContext);
  }
  selectLayer(layer, toggleSelection = false, deselectLayer = true) {
    if (layer == null) {
      throw new Error("ERROR 0005 cannot select null layer");
    }
    const isSelected = toggleSelection ? !layer.isSelected : true;
    if (deselectLayer) {
      this.deselectAllLayer();
    }
    this.setCurrentLayer(layer);
    this.setLayerSelection(layer, isSelected);
    LayerLogic.updateHierarchicalSelectRecursive(layer);
    const mainTool = this.getMainToolForLayer(layer);
    this.setCurrentMainTool(mainTool.mainToolID);
  }
  activateCurrentTool() {
    if (this.current_SubTool == null) {
      return;
    }
    this.docContext.needsDrawOperatorCursor = this.current_SubTool.isEditTool || this.current_SubTool.usesOperatorCursor;
    this.current_SubTool.onActivated(this.subToolContext);
  }
  setLayerCommandParameters(layerCommand, currentLayerWindowItem, documentData) {
    const currentLayer = currentLayerWindowItem.layer;
    const currentLayerParent = currentLayerWindowItem.parentLayer;
    let previousLayer = null;
    let previousLayerParent = null;
    if (currentLayerWindowItem.previousItem != null) {
      previousLayer = currentLayerWindowItem.previousItem.layer;
      previousLayerParent = currentLayerWindowItem.previousItem.parentLayer;
    }
    let nextLayer = null;
    let nextLayerParent = null;
    if (currentLayerWindowItem.nextSiblingItem != null) {
      nextLayer = currentLayerWindowItem.nextSiblingItem.layer;
      nextLayerParent = currentLayerWindowItem.nextSiblingItem.parentLayer;
    }
    layerCommand.setPrameters(
      documentData,
      currentLayer,
      currentLayerParent,
      previousLayer,
      previousLayerParent,
      nextLayer,
      nextLayerParent
    );
  }
  selectNextOrPreviousLayer(selectNext) {
    const item = this.appView.viewLayerList.findItemForLayer(this.docContext, this.docContext.currentLayer);
    if (selectNext) {
      if (item.nextItem != null) {
        this.selectLayer(item.nextItem.layer);
      }
    } else {
      if (item.previousItem != null) {
        this.selectLayer(item.previousItem.layer);
      }
    }
  }
  setLayerSelection(layer, isSelected) {
    layer.isSelected = isSelected;
  }
  setLayerVisiblity(layer, isVisible) {
    layer.isVisible = isVisible;
  }
  setCurrentLayer(layer) {
    if (this.docContext.currentLayer == null || layer == null || this.docContext.currentLayer != layer) {
      this.subToolContext.setRedrawWindowsForCurrentLayerChanging();
    }
    this.docContext.currentLayer = layer;
    this.subToolContext.unsetAcrtiveVectorStrokeAndGroup();
    this.updateContextCurrentRefferences();
    this.appView.paletteSelectorWindow.setCurrentTargetForLayer(this.docContext);
  }
  deselectAllLayer() {
    this.deselectAllLayerRecursive(this.docContext.documentData.rootLayer);
  }
  deselectAllLayerRecursive(layer) {
    layer.isSelected = false;
    for (const childLayer of layer.childLayers) {
      this.deselectAllLayerRecursive(childLayer);
    }
  }
  setOperationUnit(operationUnitID) {
    this.docContext.operationUnitID = operationUnitID;
  }
  setOperationOriginType(operationOriginTypeID) {
    this.docContext.operationOriginTypeID = operationOriginTypeID;
  }
  updateOperationOriginByRectangleArea(rectangleArea) {
    if (this.docContext.operationOriginTypeID == OperationOriginTypeID.medianCenter) {
      this.docContext.operationOriginLocation[0] = rectangleArea.getMedianHrizontalPosition();
      this.docContext.operationOriginLocation[1] = rectangleArea.getMedianVerticalPosition();
    }
  }
  updateOperationOriginByPoints(points) {
    if (this.docContext.operationOriginTypeID == OperationOriginTypeID.medianCenter && points.length > 0) {
      let medianX = 0;
      let medianY = 0;
      for (const point of points) {
        medianX += point.location[0];
        medianY += point.location[1];
      }
      medianX /= points.length;
      medianY /= points.length;
      this.docContext.operationOriginLocation[0] = medianX;
      this.docContext.operationOriginLocation[1] = medianY;
    }
  }
  startModalTool(subtoolID) {
    const modalTool = this.getModalSubTool(subtoolID);
    const toolPointerEvent = this.appView.tooPointerEvent.attach(this.appView.mainWindow);
    const available = modalTool.prepareModal(toolPointerEvent, this.subToolContext);
    if (!available) {
      console.debug("Can't start modal tool.");
      return;
    }
    modalTool.startModal(this.subToolContext);
    this.modalBeforeTool = this.current_SubTool;
    this.current_ModalTool = modalTool;
    this.current_SubTool = modalTool;
  }
  endModalTool() {
    if (!this.isModalToolRunning()) {
      return;
    }
    this.subToolContext.updateContext();
    this.current_ModalTool.endModal(this.subToolContext);
    this.setModalToolBefore();
    this.activateCurrentTool();
    this.subToolContext.setRedrawMainWindowEditorWindow();
  }
  cancelModalTool() {
    if (!this.isModalToolRunning()) {
      return;
    }
    this.subToolContext.updateContext();
    this.current_ModalTool.cancelModal(this.subToolContext);
    this.setModalToolBefore();
    this.activateCurrentTool();
  }
  setModalToolBefore() {
    this.current_SubTool = this.modalBeforeTool;
    this.current_ModalTool = null;
    this.modalBeforeTool = null;
  }
  isModalToolRunning() {
    return this.current_ModalTool != null;
  }
  executeToggleSelection() {
    const chenged = this.tool_SelectAllPoints.executeToggleSelection(this.subToolContext);
    this.activateCurrentTool();
    return chenged;
  }
  executeClearSelection() {
    const chenged = this.tool_SelectAllPoints.executeClearSelectAll(this.subToolContext);
    this.activateCurrentTool();
    return chenged;
  }
  visualHittestToStrokes(location, minDistance) {
    if (this.subToolContext.currentVectorLayer == null || this.subToolContext.currentVectorLayerGeometry == null) {
      return false;
    }
    this.hittest_Line_IsCloseTo.startProcess();
    this.hittest_Line_IsCloseTo.processGeometry(
      this.subToolContext.currentVectorLayer,
      this.subToolContext.currentVectorLayerGeometry,
      location,
      minDistance
    );
    this.hittest_Line_IsCloseTo.endProcess();
    return this.hittest_Line_IsCloseTo.isChanged;
  }
}
class App_UserSetting {
  constructor() {
    this.settingFile = new UserSettingFileLogic();
    this.userUIState = new UserUIStateLogic();
    this.shortcutKey = new ShortcutKeyLogic();
  }
  link() {
    this.settingFile.link(this.userUIState, this.shortcutKey);
    this.userUIState.link(this.settingFile);
  }
  loadSettings() {
    this.shortcutKey.initializeDefaultSettings();
    this.settingFile.loadSettings();
  }
  saveSettings() {
    this.settingFile.saveSettings();
  }
}
class App_View {
  constructor() {
    this.viewOperation = new ViewOperation();
    this.layerHighlight = new LayerHighlightingLogic();
    this.viewKeyframe = new ViewKeyframeLogic();
    this.viewLayerList = new ViewLayerListLogic();
    this.pointerInput = new PointerInputLogic();
    this.dom = new DOMLogic();
    this.dialogScreen = new DialogScreenLogic();
    this.modalWindow = new ModalWindowLogic();
    this.popover = new PopoverLogic();
    this.tooPointerEvent = new ToolPointerEventProvider();
    this.isForMobile = false;
    this.mainWindow = new PointerInputWindow();
    this.editorWindow = new PointerInputWindow();
    this.headerWindow = new HeaderWindow();
    this.ribbonUIWindow = new RibbonUIWindow();
    this.footerWindow = new FooterWindow();
    this.operationPanel = new OperationPanel();
    this.canvasRulerH = new CanvasRuler();
    this.canvasRulerV = new CanvasRuler();
    this.canvasFrame = new CanvasFrame();
    this.layerWindow = new LayerWindow();
    this.timeLineWindow = new TimeLineWindow();
    this.paletteSelectorWindow = new PaletteSelectorWindow();
    this.colorMixerWindow = new ColorMixerWindow();
    this.subToolWindow = new SubToolWindow();
    this.posingLayerOptions = [];
    this.activeCanvasWindow = null;
    this.left_SideBarContainerRef = {};
    this.right_SideBarContainerRef = {};
    this.sideBarContentStateSettings = [
      { contentID: SideBarContentID.layerWindow, uiStateName: UIStateNames.layerWindow },
      { contentID: SideBarContentID.paletteWindow, uiStateName: UIStateNames.paletteSelectorWindow },
      { contentID: SideBarContentID.colorMixerWindow, uiStateName: UIStateNames.colorMixerWindow }
    ];
    this.foreLayerRenderBuffer = new CanvasWindow();
    this.backLayerRenderBuffer = new CanvasWindow();
    this.drawGPUWindow = new CanvasWindow();
    this.webglWindow = new CanvasWindow();
    this.imageResurces = [];
    this.systemImage = null;
    this.subToolImages = [];
    this.modelFile = new ModelFile().file("models.json");
    this.modelResources = [];
  }
  link(canvasRender, drawStyle, main) {
    this.layerHighlight.link(this.viewLayerList);
    this.colorMixerWindow.link(canvasRender);
    this.headerWindow.link(this.dom);
    this.footerWindow.link(this.dom);
    this.timeLineWindow.link(canvasRender, drawStyle, this.dom, this.popover.selectBoxPopoverRef);
    this.ribbonUIWindow.link(this.popover.mainMenuUIRef, this.popover.brushPropertyBoxRef, this.popover.selectBoxPopoverRef);
    this.operationPanel.link(drawStyle);
    this.canvasRulerH.link(drawStyle);
    this.canvasRulerV.link(drawStyle);
    this.canvasFrame.link(drawStyle);
    this.dialogScreen.link(main, this.dom, this.popover.selectBoxPopoverRef);
  }
  initializeViewDevices() {
    this.imageResurces = [];
    this.imageResurces.push(new ImageResource().set({ filePath: "./res/texture01.png", isGLTexture: true }));
    this.imageResurces.push(new ImageResource().set({ filePath: "./res/system_image01.png", cssImageClassName: "image-splite-system" }));
    this.imageResurces.push(new ImageResource().set({ filePath: "./res/toolbar_image03.png", cssImageClassName: "image-splite-posing3d" }));
    this.systemImage = this.imageResurces[1];
    this.subToolImages = [];
    this.subToolImages.push(this.imageResurces[2]);
    this.modelFile.file("models.json");
    this.foreLayerRenderBuffer.createCanvas();
    this.backLayerRenderBuffer.createCanvas();
    this.drawGPUWindow.createCanvas();
    this.mainWindow.initializeContext();
    this.editorWindow.initializeContext();
    this.foreLayerRenderBuffer.initializeContext();
    this.backLayerRenderBuffer.initializeContext();
    this.colorMixerWindow.colorCanvas.initializeContext();
    this.timeLineWindow.canvasWindow.initializeContext();
    this.paletteSelectorWindow.initialize();
    this.startLoadingImageResources();
    this.activeCanvasWindow = this.mainWindow;
  }
  startLoadingImageResources() {
    this.operationPanel.startLoadingImageResources();
  }
  initializeViewState() {
    this.mainWindow.centerLocationRate[0] = 0.5;
    this.mainWindow.centerLocationRate[1] = 0.5;
  }
  resizeWindows() {
    this.dom.resizing.resizeCanvasToParent(this.mainWindow);
    this.dom.resizing.resizeCanvasToCanvasWindow(this.editorWindow, this.mainWindow, 1);
    this.dom.resizing.resizeCanvasToCanvasWindow(this.foreLayerRenderBuffer, this.mainWindow, 1);
    this.dom.resizing.resizeCanvasToCanvasWindow(this.backLayerRenderBuffer, this.mainWindow, 1);
    this.dom.resizing.resizeCanvasToCanvasWindow(this.webglWindow, this.mainWindow, 1);
    this.dom.resizing.resizeCanvasToCanvasWindow(this.drawGPUWindow, this.mainWindow, 2);
    this.dom.resizing.resizeCanvasToParent(this.timeLineWindow.canvasWindow);
    this.dom.resizing.fitFixedPositionToBoundingClientRect(this.dom.ID.leftSidePanel, this.dom.ID.leftSidePanelDock, true, true);
    this.dom.resizing.fitFixedPositionToBoundingClientRect(this.dom.ID.rightSidePanel, this.dom.ID.rightSidePanelDock, true, true);
    this.operationPanel.updateLayout(this.editorWindow);
    this.canvasRulerH.updateLayout(this.mainWindow, CanvasRulerOrientation.horizontalTop);
    this.canvasRulerV.updateLayout(this.mainWindow, CanvasRulerOrientation.verticalLeft);
  }
  setMobileMode() {
    const targets = [
      this.dom.ID.screenMain
    ];
    for (const target of targets) {
      if (this.isForMobile) {
        this.dom.getElement(target).classList.add("mobile-screen");
      } else {
        this.dom.getElement(target).classList.remove("mobile-screen");
      }
    }
  }
  restoreUIStatesFromUserSetting(userUIState) {
    for (const setting of this.sideBarContentStateSettings) {
      const uiState = userUIState.getUIState(setting.uiStateName);
      if (uiState) {
        this.right_SideBarContainerRef.setContentOpened(setting.contentID, uiState.visible);
      }
    }
    this.right_SideBarContainerRef.update();
    {
      const uiState = userUIState.getUIState(UIStateNames.timeLineWindow);
      if (uiState) {
        this.timeLineWindow.setVisibility(uiState.visible);
      }
    }
    {
      const uiState = userUIState.getUIState(UIStateNames.touchOperationPanel);
      if (uiState) {
        this.operationPanel.setVisibility(uiState.visible);
      }
    }
  }
  updateTabs(docContext) {
    this.ribbonUIWindow.switchTabAndRibbon(docContext);
  }
  updateRibbonUI(docContext, forceRedraw = false) {
    this.ribbonUIWindow.updateMainToolRibbonUI(docContext);
    this.updateRibbonUI_Layer(docContext);
    if (this.subToolWindow.uiSubToolWindowRef.update) {
      if (forceRedraw) {
        this.subToolWindow.uiSubToolWindowRef.update(this.subToolWindow.subToolViewItems.slice(), docContext.subtoolID);
      } else {
        this.subToolWindow.uiSubToolWindowRef.update(this.subToolWindow.subToolViewItems, docContext.subtoolID);
      }
    }
  }
  updateRibbonUI_Layer(docContext) {
    this.ribbonUIWindow.updateLayerRibbonUI(docContext, this.posingLayerOptions);
  }
}
class DocumentContext {
  constructor() {
    this.drawStyle = null;
    this.commandHistory = new CommandHistory();
    this.documentData = null;
    this.documentFilePath = "";
    this.clipboard = new ToolClipboard();
    this.mainWindow = null;
    this.posing3DView = null;
    this.posing3DLogic = null;
    this.lazy_DrawPathContext = null;
    this.drawCPUOnly = true;
    this.editMode = EditModeID.drawMode;
    this.mainToolID = MainToolID.none;
    this.mainToolTabID = MainToolTabID.none;
    this.mainToolTabs = [];
    this.subtoolID = SubToolID.none;
    this.needsDrawOperatorCursor = false;
    this.currentSubToolParameter = null;
    this.currentBrushParameter = null;
    this.currentPointerParameter = null;
    this.currentPaintParameter = { baseColor: vec4.fromValues(0, 0, 0, 1) };
    this.operationUnitID = OperationUnitID.stroke;
    this.operatorCursor = new OperatorCursor();
    this.operationOriginTypeID = OperationOriginTypeID.medianCenter;
    this.operationOriginLocation = vec3.fromValues(0, 0, 0);
    this.dragStartThresholdDistance = 5;
    this.resamplingUnitLengthForSolidBrush = 10;
    this.resamplingUnitLengthForSolidBrushMin = 1e-3;
    this.resamplingUnitMinLengthForPointBrush = 0.1;
    this.resamplingUnitMinLengthForEdit = 7;
    this.defaultTouchSize = 40;
    this.mouseCursorLocation = vec3.fromValues(0, 0, 0);
    this.currentLayer = null;
    this.currentVectorLayer = null;
    this.currentVectorLayerKeyframe = null;
    this.currentVectorLayerGeometry = null;
    this.currentPosingLayer = null;
    this.currentPosingModel = null;
    this.currentPosingData = null;
    this.currentAutoFillLayer = null;
    this.currentImageFileReferenceLayer = null;
    this.currentStrokeDrawable = null;
    this.currentFillDrawable = null;
    this.activeVectorGeometry = null;
    this.activeVectorGroup = null;
    this.activeVectorLine = null;
    this.layerListItems = [];
    this.keyframes = null;
    this.currentViewKeyframe = null;
    this.previousKeyframe = null;
    this.nextKeyframe = null;
    this.redrawMainWindow = false;
    this.redrawCurrentLayer = false;
    this.redrawEditorWindow = false;
    this.redrawLayerWindow = false;
    this.redrawRibbonUI = false;
    this.redrawTimeLineWindow = false;
    this.redrawWebGLWindow = false;
    this.redrawHeaderWindow = false;
    this.redrawFooterWindow = false;
    this.redrawPaletteSelectorWindow = false;
    this.redrawColorMixerWindow = false;
    this.redrawColorMixerSample = false;
    this.shiftKey = false;
    this.altKey = false;
    this.ctrlKey = false;
    this.animationPlaying = false;
    this.animationPlayingFPS = 24;
  }
  unsetCurrentLayer() {
    this.currentLayer = null;
    this.currentVectorLayer = null;
    this.currentVectorLayerKeyframe = null;
    this.currentVectorLayerGeometry = null;
    this.currentPosingLayer = null;
    this.currentPosingModel = null;
    this.currentPosingData = null;
    this.currentAutoFillLayer = null;
    this.currentImageFileReferenceLayer = null;
    this.currentStrokeDrawable = null;
    this.currentFillDrawable = null;
    this.activeVectorGeometry = null;
    this.activeVectorGroup = null;
    this.activeVectorLine = null;
  }
  getCurrentLayerLineColor() {
    let color = null;
    if (this.currentStrokeDrawable != null) {
      if (this.currentStrokeDrawable.drawLineType == DrawLineTypeID.paletteColor) {
        color = this.documentData.paletteColors[this.currentStrokeDrawable.line_PaletteColorIndex].color;
      } else {
        color = this.currentStrokeDrawable.layerColor;
      }
    }
    return color;
  }
  getCurrentLayerFillColor() {
    let color = null;
    if (this.currentFillDrawable != null) {
      if (this.currentFillDrawable.fillAreaType == FillAreaTypeID.paletteColor) {
        color = this.documentData.paletteColors[this.currentFillDrawable.fill_PaletteColorIndex].color;
      } else {
        color = this.currentFillDrawable.fillColor;
      }
    }
    return color;
  }
  getOperationOriginLocation() {
    if (this.operationOriginTypeID == OperationOriginTypeID.medianCenter) {
      return this.operationOriginLocation;
    } else {
      return this.operatorCursor.location;
    }
  }
}
class SubToolContext {
  constructor(docContext, appMain, appDocument, appTool) {
    this._docContext = null;
    this._appMain = null;
    this._appDocument = null;
    this._appTool = null;
    this._mouseCursorLocation = vec3.fromValues(0, 0, 0);
    this._docContext = docContext;
    this._appMain = appMain;
    this._appDocument = appDocument;
    this._appTool = appTool;
  }
  get main() {
    return this._appMain;
  }
  get tool() {
    return this._appTool;
  }
  get document() {
    return this._appDocument;
  }
  get documentData() {
    return this._docContext.documentData;
  }
  get documentFilePath() {
    return this._docContext.documentFilePath;
  }
  get mainWindow() {
    return this._docContext.mainWindow;
  }
  get drawStyle() {
    return this._docContext.drawStyle;
  }
  get commandHistory() {
    return this._docContext.commandHistory;
  }
  get operatorCursor() {
    return this._docContext.operatorCursor;
  }
  get clipboard() {
    return this._docContext.clipboard;
  }
  get posing3DView() {
    return this._docContext.posing3DView;
  }
  get posing3DLogic() {
    return this._docContext.posing3DLogic;
  }
  get operationUnitID() {
    return this._docContext.operationUnitID;
  }
  get currentSubtoolID() {
    return this._docContext.subtoolID;
  }
  get drawLineBaseWidth() {
    return this._docContext.currentBrushParameter.baseSize;
  }
  get drawLineMinWidth() {
    return this._docContext.currentBrushParameter.minSize;
  }
  get toolBaseViewRadius() {
    if (this._docContext.currentPointerParameter.parameterID != PointerParameterID.none) {
      return this.getViewScaledLength(this._docContext.currentPointerParameter.baseSize);
    } else {
      return 0;
    }
  }
  get brushBaseSize() {
    if (this._docContext.currentBrushParameter.parameterID != BrushParameterID.none) {
      return this._docContext.currentBrushParameter.baseSize;
    } else {
      return 0;
    }
  }
  get touchViewRadius() {
    return this.getViewScaledLength(this._docContext.defaultTouchSize);
  }
  get currentLayer() {
    return this._docContext.currentLayer;
  }
  get currentVectorLayer() {
    return this._docContext.currentVectorLayer;
  }
  get currentAutoFillLayer() {
    return this._docContext.currentAutoFillLayer;
  }
  get currentPosingLayer() {
    return this._docContext.currentPosingLayer;
  }
  get currentPosingModel() {
    return this._docContext.currentPosingModel;
  }
  get currentPosingData() {
    return this._docContext.currentPosingData;
  }
  get currentImageFileReferenceLayer() {
    return this._docContext.currentImageFileReferenceLayer;
  }
  get currentVectorLayerKeyframe() {
    return this._docContext.currentVectorLayerKeyframe;
  }
  get currentVectorLayerGeometry() {
    return this._docContext.currentVectorLayerGeometry;
  }
  get currentTimeFrame() {
    return this._docContext.documentData.animationSettingData.currentTimeFrame;
  }
  get activeVectorGroup() {
    if (this._docContext.activeVectorGroup != null && this._docContext.activeVectorGroup.runtime.modifyFlag != VectorStrokeGroupModifyFlagID.delete) {
      return this._docContext.activeVectorGroup;
    } else {
      return null;
    }
  }
  get activeVectorLine() {
    if (this._docContext.activeVectorLine != null && this._docContext.activeVectorLine.runtime.modifyFlag != VectorStrokeModifyFlagID.delete) {
      return this._docContext.activeVectorLine;
    } else {
      return null;
    }
  }
  get mouseCursorLocation() {
    return this._mouseCursorLocation;
  }
  updateContext() {
    vec3.copy(this.mouseCursorLocation, this._docContext.mouseCursorLocation);
  }
  setRedrawHeaderWindow() {
    this._docContext.redrawHeaderWindow = true;
  }
  setRedrawMainWindow() {
    this._docContext.redrawMainWindow = true;
    this._docContext.redrawCurrentLayer = false;
  }
  setRedrawCurrentLayer() {
    if (!this._docContext.redrawMainWindow) {
      this._docContext.redrawCurrentLayer = true;
    }
    this._docContext.redrawMainWindow = true;
  }
  setRedrawEditorWindow() {
    this._docContext.redrawEditorWindow = true;
  }
  setRedrawMainWindowEditorWindow() {
    this.setRedrawMainWindow();
    this.setRedrawEditorWindow();
    this.setRedrawWebGLWindow();
  }
  setRedrawLayerWindow() {
    this._docContext.redrawLayerWindow = true;
    this._docContext.redrawPaletteSelectorWindow = true;
    this._docContext.redrawColorMixerWindow = true;
  }
  setRedrawPaletteWindow() {
    this._docContext.redrawPaletteSelectorWindow = true;
    this._docContext.redrawColorMixerWindow = true;
  }
  updateLayerStructure() {
    this._appMain.updateLayerStructure();
    this.setRedrawLayerWindow();
    this.setRedrawTimeLineWindow();
    this.setRedrawMainWindowEditorWindow();
  }
  setRedrawRibbonUI() {
    this._docContext.redrawRibbonUI = true;
  }
  setRedrawTimeLineWindow() {
    this._docContext.redrawTimeLineWindow = true;
  }
  setRedrawPalleteSelectorWindow() {
    this._docContext.redrawPaletteSelectorWindow = true;
  }
  setRedrawColorMixerWindow() {
    this._docContext.redrawColorMixerWindow = true;
  }
  setRedrawWebGLWindow() {
    this._docContext.redrawWebGLWindow = true;
  }
  setRedrawAllWindows() {
    this.setRedrawMainWindowEditorWindow();
    this.setRedrawRibbonUI();
    this.setRedrawLayerWindow();
    this.setRedrawTimeLineWindow();
    this.setRedrawPalleteSelectorWindow();
    this.setRedrawWebGLWindow();
  }
  setRedrawWindowsForCurrentToolChanging() {
    this.setRedrawHeaderWindow();
    this.setRedrawMainWindowEditorWindow();
    this.setRedrawRibbonUI();
  }
  setRedrawWindowsForCurrentLayerChanging() {
    this.setRedrawRibbonUI();
    this.setRedrawLayerWindow();
    this.setRedrawTimeLineWindow();
  }
  setRedrawWindowsForLayerPropertyChanging() {
    this.setRedrawMainWindowEditorWindow();
    this.setRedrawRibbonUI();
  }
  setRedrawWindowsForLayerColorChanging() {
    this.setRedrawMainWindowEditorWindow();
    this.setRedrawRibbonUI();
    this.setRedrawPalleteSelectorWindow();
    this.setRedrawColorMixerWindow();
    this.setRedrawLayerWindow();
  }
  isAnyModifierKeyPressing() {
    return this._docContext.shiftKey || this._docContext.altKey || this._docContext.ctrlKey;
  }
  isShiftKeyPressing() {
    return this._docContext.shiftKey;
  }
  isCtrlKeyPressing() {
    return this._docContext.ctrlKey;
  }
  isAltKeyPressing() {
    return this._docContext.altKey;
  }
  isDrawMode() {
    return this._docContext.editMode == EditModeID.drawMode;
  }
  isEditMode() {
    return this._docContext.editMode == EditModeID.editMode;
  }
  isCurrentLayerStrokeDrawableLayer() {
    return VectorLayer.isVectorLayer(this.currentLayer) && Layer.isVisible(this.currentLayer);
  }
  isCurrentLayerEditbaleLayer() {
    return Layer.isEditTarget(this.currentLayer) && (VectorLayer.isVectorLayer(this.currentLayer) || GroupLayer.isGroupLayer(this.currentLayer));
  }
  isCurrentLayerAutoFillLayer() {
    return AutoFillLayer.isAutoFillLayer(this.currentLayer) && Layer.isVisible(this.currentLayer);
  }
  isCurrentLayerPosingLayer() {
    return PosingLayer.isPosingLayer(this.currentLayer) && Layer.isVisible(this.currentLayer);
  }
  isCurrentLayerImageFileReferenceLayer() {
    return ImageFileReferenceLayer.isImageFileReferenceLayer(this.currentLayer) && Layer.isVisible(this.currentLayer);
  }
  isCurrentLayerGroupLayer() {
    return GroupLayer.isGroupLayer(this.currentLayer) && Layer.isVisible(this.currentLayer);
  }
  needsDrawOperatorCursor() {
    return this._docContext.needsDrawOperatorCursor;
  }
  unsetCurrentLayer() {
    this._docContext.unsetCurrentLayer();
  }
  setActiveVectorStroke(line, group, geometry) {
    if (!group) {
      throw new Error("ERROR 0020:Needs group value. If to reset active line, use unsetAcrtiveVectorLine.");
    }
    this._docContext.activeVectorLine = line;
    this._docContext.activeVectorGroup = group;
    this._docContext.activeVectorGeometry = geometry;
  }
  unsetAcrtiveVectorStrokeAndGroup() {
    this._docContext.activeVectorGeometry = null;
    this._docContext.activeVectorGroup = null;
    this._docContext.activeVectorLine = null;
  }
  getOperationOriginLocation() {
    return this._docContext.getOperationOriginLocation();
  }
  getViewScaledLength(length) {
    return this._docContext.mainWindow.getViewScaledLength(length);
  }
  getViewScaledResamplingUnitLengthForBrush() {
    let target_brushType = BrushTypeID.none;
    if (this._docContext.activeVectorGeometry != null) {
      if (VectorLayerGeometry.isStrokeDraw(this._docContext.activeVectorGeometry)) {
        target_brushType = BrushTypeID.solidBrushStroke;
      } else {
        target_brushType = BrushTypeID.radialBrush;
      }
    } else {
      target_brushType = this._docContext.currentBrushParameter.brushType;
    }
    let resamplingUnitLength = 0;
    switch (target_brushType) {
      case BrushTypeID.solidBrushStroke:
        resamplingUnitLength = this.getViewScaledLength(this._docContext.resamplingUnitLengthForSolidBrush);
        if (resamplingUnitLength < this._docContext.resamplingUnitLengthForSolidBrushMin) {
          resamplingUnitLength = this._docContext.resamplingUnitLengthForSolidBrushMin;
        }
        break;
      case BrushTypeID.radialBrush:
      case BrushTypeID.bitmapBrush:
      case BrushTypeID.none:
        {
          resamplingUnitLength += this.drawLineBaseWidth * this._docContext.currentBrushParameter.stepRate;
          if (resamplingUnitLength < this._docContext.resamplingUnitMinLengthForPointBrush) {
            resamplingUnitLength = this._docContext.resamplingUnitMinLengthForPointBrush;
          }
        }
        break;
    }
    return resamplingUnitLength;
  }
  getViewScaledResamplingUnitLengthForEdit() {
    const recomendedSize = this._docContext.resamplingUnitMinLengthForEdit;
    let resamplingUnitLength = this.getViewScaledLength(recomendedSize);
    if (resamplingUnitLength < recomendedSize) {
      resamplingUnitLength = recomendedSize;
    }
    return resamplingUnitLength;
  }
  collectHierarchicalLayerInfos() {
    const layerInfos = [];
    LayerLogic.collectHierarchicalLayerInfoRecursive(layerInfos, this.documentData.rootLayer);
    return layerInfos;
  }
}
class SubToolDrawingContext {
  constructor(editorDrawer, render, style) {
    this.canvasWindow = null;
    this.editorDrawer = null;
    this.render = null;
    this.style = null;
    this.operatorCurosrLineDashScaled = [0, 0];
    this.editorDrawer = editorDrawer;
    this.render = render;
    this.style = style;
  }
  setCanvasWindow(canvasWindow) {
    this.canvasWindow = canvasWindow;
  }
  beginPath(locationFrom) {
    this.render.beginPath();
    if (locationFrom) {
      this.render.moveTo(locationFrom[0], locationFrom[1]);
    }
  }
  stroke(strokeWidth, color) {
    this.render.setStrokeColorV(color);
    this.render.setStrokeWidth(strokeWidth);
    this.render.stroke();
  }
  fill(color) {
    this.render.setFillColorV(color);
    this.render.fill();
  }
  moveTo(location) {
    this.render.moveTo(location[0], location[1]);
  }
  lineTo(location) {
    this.render.lineTo(location[0], location[1]);
  }
  drawLine(locationFrom, locationTo, strokeWidth, color) {
    this.render.setStrokeColorV(color);
    this.render.setStrokeWidth(strokeWidth);
    this.render.beginPath();
    this.render.moveTo(locationFrom[0], locationFrom[1]);
    this.render.lineTo(locationTo[0], locationTo[1]);
    this.render.stroke();
  }
  drawCircle(center, raduis, strokeWidth, color) {
    this.render.setStrokeColorV(color);
    this.render.setStrokeWidth(strokeWidth);
    this.render.beginPath();
    this.render.circle(center[0], center[1], raduis);
    this.render.stroke();
  }
  setLineDash(scale) {
    const viewScale = this.render.getViewScaledSize(scale);
    this.operatorCurosrLineDashScaled[0] = this.style.operatorCurosrLineDash[0] * viewScale;
    this.operatorCurosrLineDashScaled[1] = this.style.operatorCurosrLineDash[1] * viewScale;
    this.render.setLineDash(this.operatorCurosrLineDashScaled);
  }
  cancelLineDash() {
    this.render.clearLineDash();
  }
}
var MainProcessStateID = /* @__PURE__ */ ((MainProcessStateID2) => {
  MainProcessStateID2[MainProcessStateID2["none"] = 0] = "none";
  MainProcessStateID2[MainProcessStateID2["startup"] = 1] = "startup";
  MainProcessStateID2[MainProcessStateID2["pause"] = 2] = "pause";
  MainProcessStateID2[MainProcessStateID2["systemResourceLoading"] = 3] = "systemResourceLoading";
  MainProcessStateID2[MainProcessStateID2["documentJSONLoading"] = 4] = "documentJSONLoading";
  MainProcessStateID2[MainProcessStateID2["documentResourceLoading"] = 5] = "documentResourceLoading";
  MainProcessStateID2[MainProcessStateID2["running"] = 6] = "running";
  return MainProcessStateID2;
})(MainProcessStateID || {});
class App_Main {
  constructor() {
    this.appView = new App_View();
    this.appDrawing = new App_Drawing();
    this.appTool = new App_Tool();
    this.appUserSetting = new App_UserSetting();
    this.appDocument = new App_Document();
    this.appEvent = new App_Event();
    this.appDefferedProcess = new App_DefferedProcess();
    this.docContext = null;
    this.subtoolContext = null;
    this.subtoolDrawingContext = null;
    this.systemResourceLoading = new SystemResourceLoading();
    this.mainProcessState = 1;
    this.isDeferredWindowResizeWaiting = false;
    this.deferredWindowResizeWaitingDuration = 250;
    this.deferredWindowResizeWaitingEndTime = 0;
    this.lastTime = 0;
    this.elapsedTime = 0;
    this.isFirstStartup = true;
    this.activeLayerBufferDrawn = false;
    this.appView.link(this.appDrawing.canvasRender, this.appDrawing.drawStyle, this);
    this.appDrawing.link(this.appView);
    this.appTool.link(this.appView, this.appDrawing);
    this.appUserSetting.link();
    this.appDocument.link(this.appView, this.appDrawing, this.appTool, this.appUserSetting.settingFile);
    this.appEvent.link(this.appView, this.appDrawing, this.appDocument, this.appTool, this.appUserSetting, this);
    this.appDefferedProcess.link(this.appDrawing, this.appDrawing.drawPathBuffering, this.appDocument.posing3D, this.appDrawing.posing3DView);
    this.systemResourceLoading.link(this.appDrawing.posing3DViewRender, this.appDocument.posing3DModel);
  }
  onInitializeSystemDevices() {
    this.appUserSetting.loadSettings();
    this.appView.initializeViewDevices();
    this.appDrawing.initializeDrawingDevices(this.appView.webglWindow, this.appView.drawGPUWindow);
    this.startLoadingSystemResources();
  }
  startLoadingSystemResources() {
    this.systemResourceLoading.startLoadingSystemResources(this.appView.modelFile, this.appView.imageResurces);
    this.mainProcessState = 3;
  }
  processLoadingSystemResources() {
    if (this.systemResourceLoading.isLoading()) {
      return;
    }
    this.appView.timeLineWindow.systemImage = this.appView.systemImage;
    if (this.appUserSetting.settingFile.localSetting.lastUsedFilePaths.length == 0) {
      this.startWidhDefaultDocumentData();
    } else {
      const lastURL = this.appUserSetting.settingFile.localSetting.lastUsedFilePaths[0];
      const documentData = new DocumentData();
      this.appDocument.documentLoading.startLoadingDocumentFromURL(documentData, lastURL);
      this.mainProcessState = 4;
    }
  }
  startReloadDocument(filepath) {
    const documentData = new DocumentData();
    this.appDocument.documentLoading.startLoadingDocumentFromURL(documentData, filepath);
    this.mainProcessState = 4;
  }
  startReloadDocumentFromFile(file, url) {
    if (Strings.isNullOrEmpty(url)) {
      throw new Error("ERROR 0001:both of url and file are null or empty");
    }
    const isAvailable = this.appDocument.documentLoading.startLoadingDocumentFromFile(file, url);
    if (isAvailable) {
      this.mainProcessState = 4;
    } else {
      console.debug("error: not supported file type.");
    }
  }
  processLoadingDocumentFile() {
    if (this.appDocument.documentLoading.hasErrorOnLoadingDocument()) {
      console.error("ERROR 0003:An error occured while loading document data.");
      this.startWidhDefaultDocumentData();
      return;
    }
    if (!this.appDocument.documentLoading.isDocumentLoaded()) {
      return;
    }
    this.appDocument.fixLoadedDocumentData(
      this.appDocument.documentLoading.loading_DocumentData,
      this.appView.modelFile
    );
    this.appDocument.documentLoading.startLoadingDocumentResources(
      this.appDocument.documentLoading.loading_DocumentData,
      this.appDocument.documentLoading.loading_DocumentFilePath
    );
    this.appDocument.documentLoading.finishDocumentDataLoading();
    this.mainProcessState = 5;
  }
  startLoadingDocumentResourcesProcess(document2) {
    this.appDocument.documentLoading.startLoadingDocumentResources(document2, this.docContext.documentFilePath);
    this.mainProcessState = 5;
  }
  processLoadingDocumentResources() {
    if (this.appDocument.documentLoading.isDocumentResourceLoading()) {
      return;
    }
    if (this.appDocument.documentLoading.hasErrorOnLoadingDocumentResource()) {
      console.error("ERROR 0004:An error occured while loading document resource.");
      this.startWidhDefaultDocumentData();
      return;
    }
    if (this.appDocument.documentLoading.isDocumentLoading() && this.docContext != null && this.docContext.documentData != null) {
      DocumentSerializingLogic.releaseDocumentResources(this.docContext.documentData, this.appDrawing.drawGPURender);
      this.docContext.documentData = null;
    }
    DocumentDeserializingLogic.finishResourceLoading(this.appDocument.documentLoading.resourceLoading_DocumentData);
    this.start(
      this.appDocument.documentLoading.resourceLoading_DocumentData,
      this.appDocument.documentLoading.loading_DocumentFilePath,
      false
    );
    if (!this.isFirstStartup) {
      this.appUserSetting.saveSettings();
    }
  }
  start(documentData, document_filePath, isNew) {
    this.initializeDocumentContext(documentData, document_filePath);
    this.appTool.initializeTools();
    this.appView.initializeViewState();
    this.updateLayerStructureInternal(true, true, false, false);
    const layers = LayerLogic.collectLayers(documentData.rootLayer);
    const selected_layers = layers.filter((layer) => Layer.isSelected(layer));
    if (selected_layers.length > 0) {
      this.docContext.currentLayer = selected_layers[0];
      this.appTool.selectLayer(this.docContext.currentLayer, false, false);
    } else {
      this.appTool.selectLayer(documentData.rootLayer.childLayers[0]);
    }
    this.updateLayerStructureInternal(false, false, true, true);
    this.appView.mainWindow.viewScale = documentData.defaultViewScale;
    this.appView.mainWindow.viewRotation = 0;
    this.appView.mainWindow.mirrorX = false;
    this.appView.mainWindow.mirrorY = false;
    this.appView.viewOperation.copyLastViewLocation(false, this.appView.mainWindow);
    this.subtoolContext.updateContext();
    if (!isNew) {
      this.appUserSetting.settingFile.registerLastUsedFile(document_filePath);
    }
    this.updateHeaderDocumentFileName(document_filePath);
    this.prepareDrawPathBuffers();
    this.setLazyUpdateNeeded();
    this.appView.updateTabs(this.docContext);
    this.appView.updateRibbonUI(this.docContext, true);
    this.resizeWindowsAndBuffers();
    this.appTool.updateFooterMessage();
    this.appView.restoreUIStatesFromUserSetting(this.appUserSetting.userUIState);
    if (!this.appEvent.isEventSetDone) {
      this.appEvent.setEvents();
    }
    this.initialUpdatesForLayers(this.collectVectorViewKeyframeLayersForEdit());
    this.subtoolContext.setRedrawAllWindows();
    if (this.appView.right_SideBarContainerRef.isContentOpened(SideBarContentID.colorMixerWindow)) {
      this.docContext.redrawColorMixerSample = true;
    }
    this.mainProcessState = 6;
    this.isFirstStartup = false;
  }
  startWidhDefaultDocumentData() {
    const documentData = this.appDocument.createDefaultDocumentData();
    const filePath = DocumentFileNameLogic.getDefaultDocumentFilePath(this.appUserSetting.settingFile.localSetting);
    this.start(documentData, filePath, true);
  }
  initializeDocumentContext(documentData, document_filePath) {
    this.docContext = new DocumentContext();
    this.docContext.documentData = documentData;
    this.docContext.drawStyle = this.appDrawing.drawStyle;
    this.docContext.mainWindow = this.appView.mainWindow;
    this.docContext.posing3DView = this.appDrawing.posing3DView;
    this.docContext.posing3DLogic = this.appDocument.posing3D;
    this.docContext.lazy_DrawPathContext = this.appDrawing.lazy_drawPathContext;
    this.docContext.documentFilePath = document_filePath;
    this.subtoolContext = new SubToolContext(this.docContext, this, this.appDocument, this.appTool);
    this.subtoolDrawingContext = new SubToolDrawingContext(this.appDrawing.editorDrawer, this.appDrawing.canvasRender, this.appDrawing.drawStyle);
    this.appTool.linkContexts(this.docContext, this.subtoolContext);
    this.appEvent.linkContexts(this.docContext, this.subtoolContext);
    this.appDocument.linkContexts(this.docContext, this.subtoolContext);
    this.appDefferedProcess.linkContexts(this.docContext, this.subtoolContext);
    this.appTool.updateBrushParameterReferences();
    this.appView.viewOperation.setViewToDefaultState(this.appView.mainWindow, 1);
  }
  initialUpdatesForLayers(viewKeyframeLayers) {
    for (const viewKeyframeLayer of viewKeyframeLayers) {
      viewKeyframeLayer.layer.runtime.needsPostUpdate = true;
    }
    this.appDefferedProcess.setPostUpdateNeeded();
    this.appDefferedProcess.executePostUpdate(
      this.appDrawing.main_drawPathContext,
      this.docContext.currentViewKeyframe,
      false,
      this.subtoolContext
    );
    this.appDrawing.drawPathBuffering.updateRenderCaches(
      this.appDrawing.main_drawPathContext,
      this.docContext.currentViewKeyframe
    );
    for (const viewKeyframeLayer of viewKeyframeLayers) {
      this.setRedrawDrawPathForLayer(viewKeyframeLayer.layer);
    }
  }
  run() {
    if (this.isDeferredWindowResizeWaiting && Platform.getCurrentTime() > this.deferredWindowResizeWaitingEndTime) {
      this.isDeferredWindowResizeWaiting = false;
      this.resizeWindowsAndBuffers();
      this.subtoolContext.setRedrawAllWindows();
    }
    const currentTime = Platform.getCurrentTime();
    if (this.lastTime == 0) {
      this.elapsedTime = 100;
    } else {
      this.elapsedTime = currentTime - this.lastTime;
    }
    this.lastTime = currentTime;
    this.appView.layerHighlight.processHighlightingAnimation(this.elapsedTime, this.subtoolContext);
    if (this.docContext.animationPlaying) {
      const aniSetting = this.docContext.documentData.animationSettingData;
      aniSetting.currentTimeFrame += 1;
      if (aniSetting.currentTimeFrame >= aniSetting.loopEndFrame) {
        aniSetting.currentTimeFrame = aniSetting.loopStartFrame;
      }
      this.setCurrentFrameInternal(aniSetting.currentTimeFrame);
      this.subtoolContext.setRedrawMainWindow();
      this.subtoolContext.setRedrawTimeLineWindow();
    }
  }
  draw() {
    const currentLayerOnly = this.appView.layerHighlight.isAnimating();
    this.appView.mainWindow.caluclateViewMatrix(this.appView.mainWindow.view2DMatrix);
    mat4.invert(this.appView.mainWindow.invView2DMatrix, this.appView.mainWindow.view2DMatrix);
    this.subtoolContext.updateContext();
    if (this.docContext.redrawMainWindow) {
      this.appDrawing.drawMainWindow(
        this.appView.mainWindow,
        this.docContext,
        this.subtoolContext.isDrawMode(),
        this.subtoolContext.isEditMode(),
        this.subtoolContext.tool.isModalToolRunning(),
        this.docContext.drawCPUOnly,
        this.docContext.redrawCurrentLayer,
        currentLayerOnly
      );
      this.docContext.redrawMainWindow = false;
    }
    if (this.docContext.redrawEditorWindow) {
      this.appDrawing.clearWindow(this.appView.editorWindow);
      this.drawEditorWindow(this.appView.editorWindow, this.appView.mainWindow);
      this.docContext.redrawEditorWindow = false;
    }
    if (this.docContext.redrawLayerWindow) {
      this.appView.layerWindow.update(this.docContext, this.docContext.currentLayer);
      this.appView.layerWindow.uiRef.update(this.docContext.layerListItems);
      this.appView.updateRibbonUI_Layer(this.docContext);
      this.docContext.redrawLayerWindow = false;
    }
    if (this.docContext.redrawRibbonUI) {
      this.appTool.updateCurrentPaintParameters();
      this.appView.subToolWindow.updateViewItemState(this.subtoolContext);
      this.appView.updateTabs(this.docContext);
      this.appView.updateRibbonUI(this.docContext, true);
      this.docContext.redrawRibbonUI = false;
    }
    if (this.docContext.redrawPaletteSelectorWindow) {
      this.drawPaletteSelectorWindow();
      this.appView.paletteSelectorWindow.uiRef.update(this.docContext.documentData.paletteColors);
      this.docContext.redrawPaletteSelectorWindow = false;
    }
    if (this.docContext.redrawColorMixerWindow) {
      this.drawColorMixerWindow();
      this.docContext.redrawColorMixerWindow = false;
    }
    if (this.docContext.redrawColorMixerSample) {
      this.drawColorMixerSample();
      this.docContext.redrawColorMixerSample = false;
    }
    if (this.docContext.redrawTimeLineWindow) {
      this.drawTimeLineWindow();
      this.docContext.redrawTimeLineWindow = false;
    }
    if (this.docContext.redrawWebGLWindow) {
      this.appDrawing.drawingPosing3D.drawPosing3DView(
        this.appView.webglWindow,
        this.docContext.layerListItems,
        this.appView.mainWindow,
        this.docContext,
        currentLayerOnly
      );
      this.docContext.redrawWebGLWindow = false;
    }
    if (this.docContext.redrawHeaderWindow) {
      this.docContext.redrawHeaderWindow = false;
    }
    if (this.docContext.redrawFooterWindow) {
      this.appView.footerWindow.updateFooterText();
      this.docContext.redrawFooterWindow = false;
    }
    this.executeLazyUpdates();
    this.docContext.redrawCurrentLayer = false;
  }
  drawEditorWindow(editorWindow, mainWindow) {
    mainWindow.updateViewMatrix();
    mainWindow.copyTransformTo(editorWindow);
    this.appDrawing.canvasRender.setContext(editorWindow);
    if (this.subtoolContext.needsDrawOperatorCursor()) {
      this.appDrawing.operatorCursor.drawOperatorCursor(this.docContext.operatorCursor);
    }
    this.appDrawing.drawingEyesSymmetry.drawEyesSymmetries(this.docContext.layerListItems, this.subtoolContext);
    const current_SubTool = this.appTool.getCurrentSubTool();
    if (current_SubTool != null) {
      this.subtoolContext.updateContext();
      this.subtoolDrawingContext.setCanvasWindow(editorWindow);
      current_SubTool.onDrawEditor(this.subtoolContext, this.subtoolDrawingContext);
    }
    this.appView.operationPanel.draw(this.appDrawing.canvasRender);
  }
  drawTimeLineWindow() {
    this.appView.dom.resizing.resizeCanvasToParent(this.appView.timeLineWindow.canvasWindow);
    this.appDrawing.clearWindow(this.appView.timeLineWindow.canvasWindow);
    this.appView.timeLineWindow.drawCommandButton(this.docContext);
    this.appView.timeLineWindow.drawTimeLine(this.docContext);
  }
  drawPaletteSelectorWindow() {
    this.appView.paletteSelectorWindow.updateCommandButtons();
    this.appView.paletteSelectorWindow.updatePaletteItems(this.docContext);
  }
  drawColorMixerWindow() {
    const color = this.appView.paletteSelectorWindow.getCurrentLayerTargetColorRef(this.docContext);
    this.appView.colorMixerWindow.updateInputControls(color);
  }
  drawColorMixerSample() {
    if (this.appView.colorMixerWindow.isDrawingDone) {
      return;
    }
    this.appView.dom.resizing.resizeCanvasToBoundingClientRect(this.appView.colorMixerWindow.colorCanvas);
    this.appView.colorMixerWindow.drawPaletteColorMixer();
    this.appView.colorMixerWindow.isDrawingDone = true;
  }
  executeLazyUpdates() {
    const drawPathContext = this.appDrawing.lazy_drawPathContext;
    const state = this.appDefferedProcess.drawing_LazyUpdateState;
    if (state.isFinished) {
      return;
    }
    if (state.needsStartingLazyUpdate) {
      this.appDefferedProcess.startLazyUpdates();
      state.startLazyCalculation();
      return;
    }
    if (state.isLazyUpdateWaiting()) {
      return;
    }
    if (state.isFirstTime) {
      state.isFirstTime = false;
    }
    if (!this.appDefferedProcess.isLazyCalculationFinished()) {
      this.appDefferedProcess.executeLazyUpdate(
        drawPathContext,
        this.docContext.currentViewKeyframe
      );
      this.executePostUpdate();
    } else if (!state.isLazyDrawingFinished) {
      if (!this.docContext.drawCPUOnly) {
        this.appDefferedProcess.drawDrawPathForLazyDraw(
          this.appView.mainWindow,
          this.docContext,
          this.subtoolContext,
          drawPathContext
        );
      } else {
        this.subtoolContext.setRedrawMainWindowEditorWindow();
      }
      state.finishLazyDrawing();
    }
  }
  prepareDrawPathBuffers() {
    this.appDrawing.drawPathBuffering.prepareDrawPathBuffers(
      this.appDrawing.main_drawPathContext,
      this.appView.mainWindow
    );
    this.appDrawing.drawPathBuffering.prepareForLazyDrawComposition(
      this.appDrawing.lazy_drawPathContext,
      this.appView.mainWindow.width,
      this.appView.mainWindow.height,
      false
    );
    this.appDrawing.drawPathBuffering.updateAllRenderCaches(
      this.appDrawing.main_drawPathContext,
      this.docContext.currentViewKeyframe
    );
  }
  resizeWindowsAndBuffers() {
    this.appView.resizeWindows();
    this.prepareDrawPathBuffers();
  }
  updateLayerStructureInternal(updateLayerWindowItems, updateViewKeyframes, updateHierarchicalStates, updateDrawPath, updateContextCurrentRefferences = true) {
    if (updateHierarchicalStates) {
      LayerLogic.updateHierarchicalStatesRecursive(this.docContext.documentData.rootLayer);
    }
    if (updateViewKeyframes) {
      this.appView.viewKeyframe.collectViewKeyframesToContext(this.docContext);
    }
    if (updateLayerWindowItems) {
      this.appView.viewLayerList.collectItemsToContext(this.docContext);
      this.appView.posingLayerOptions = this.appView.viewLayerList.collectPosingLayerOptions(this.docContext);
    }
    if (updateDrawPath) {
      this.appDrawing.collectDrawPathsForDocument(this.docContext);
      this.prepareDrawPathBuffers();
    }
    if (updateContextCurrentRefferences) {
      this.appTool.updateContextCurrentRefferences();
    }
  }
  setCurrentFrameInternal(frame, skipCollectDrawPaths = false) {
    const aniSetting = this.docContext.documentData.animationSettingData;
    aniSetting.currentTimeFrame = frame;
    if (aniSetting.currentTimeFrame < 0) {
      aniSetting.currentTimeFrame = 0;
    }
    if (aniSetting.currentTimeFrame > aniSetting.maxFrame) {
      aniSetting.currentTimeFrame = aniSetting.maxFrame;
    }
    const viewKeyframeChanged = this.appView.viewKeyframe.updateContextForViewKeyframeReferences(this.docContext, aniSetting.currentTimeFrame);
    if (viewKeyframeChanged) {
      if (!skipCollectDrawPaths) {
        this.updateLayerStructureInternal(false, false, false, true, false);
      }
      this.appTool.updateContextCurrentRefferences();
    }
    this.subtoolContext.setRedrawMainWindowEditorWindow();
    this.subtoolContext.setRedrawTimeLineWindow();
  }
  updateHeaderDocumentFileName(filePath) {
    Platform.path.getFileName(filePath);
  }
  executeSubToolKeyDown(key, commandID) {
    return this.appTool.executeSubToolKeyDown(key, commandID);
  }
  executeSubToolMouseDown(e) {
    this.appTool.executeSubToolMouseDown(e);
    this.executePostUpdate();
  }
  executeSubToolMouseMove(e) {
    this.appTool.executeSubToolMouseMove(e);
    this.executePostUpdate();
  }
  executeSubToolMouseUp(e) {
    this.appTool.executeSubToolMouseUp(e);
    this.executePostUpdate();
  }
  executeUndo() {
    this.appTool.executeUndo();
    this.executePostUpdate(true);
    this.appTool.activateCurrentTool();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
  }
  executeRedo() {
    this.appTool.executeRedo();
    this.executePostUpdate();
    this.appTool.activateCurrentTool();
    this.subtoolContext.setRedrawMainWindowEditorWindow();
  }
  executePostUpdateForCurrentLayer() {
    this.docContext.currentLayer.runtime.needsPostUpdate = true;
    this.appDefferedProcess.setPostUpdateNeeded();
    this.executePostUpdate();
    this.setRedrawDrawPathForLayer(this.docContext.currentLayer);
    this.subtoolContext.setRedrawWindowsForLayerColorChanging();
  }
  executePostUpdate(isUndo = false) {
    const isUpdated = this.appDefferedProcess.executePostUpdate(
      this.appDrawing.main_drawPathContext,
      this.docContext.currentViewKeyframe,
      isUndo,
      this.subtoolContext
    );
    if (!isUpdated) {
      return;
    }
    this.appDrawing.drawPathBuffering.updateRenderCaches(
      this.appDrawing.main_drawPathContext,
      this.docContext.currentViewKeyframe
    );
    this.appTool.updateActiveRefferences();
  }
  setRedrawDrawPathForLayer(layer) {
    for (const drawPathStep of this.appDrawing.main_drawPathContext.steps) {
      if (drawPathStep.layer == layer) {
        drawPathStep.needsRedraw = true;
      }
    }
  }
  setCurrentFrame(frame) {
    this.setCurrentFrameInternal(frame, false);
  }
  onWindowBlur() {
    if (this.mainProcessState == 6) {
      this.mainProcessState = 2;
    }
  }
  onWindowFocus() {
    if (this.mainProcessState == 2) {
      this.mainProcessState = 6;
    }
  }
  isWhileLoading() {
    return this.mainProcessState == 3 || this.mainProcessState == 5;
  }
  setDefferedWindowResize() {
    this.isDeferredWindowResizeWaiting = true;
    this.deferredWindowResizeWaitingEndTime = Platform.getCurrentTime() + this.deferredWindowResizeWaitingDuration;
  }
  isEventDisabled() {
    return this.isWhileLoading() || this.isDeferredWindowResizeWaiting || this.appView.modalWindow.isActive() || this.appView.dialogScreen.isActive() || this.appView.dialogScreen.isDialogWindowOpened() || this.appView.popover.isActive();
  }
  resetDocument() {
    DocumentSerializingLogic.releaseDocumentResources(this.docContext.documentData, this.appDrawing.drawGPURender);
    this.startWidhDefaultDocumentData();
  }
  saveDocument() {
    this.saveDocumentToFile(this.docContext.documentFilePath);
  }
  saveAsDocument(directoryPath, fileName) {
    const filePath = Platform.path.join(directoryPath, fileName);
    this.saveDocumentToFile(filePath);
  }
  saveDocumentToFile(filePath) {
    const documentData = this.docContext.documentData;
    if (Strings.isNullOrEmpty(filePath)) {
      this.appView.dialogScreen.messageBox("\u30D5\u30A1\u30A4\u30EB\u540D\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002");
      return;
    }
    this.appDocument.saveDocumentData(filePath, documentData, false);
    this.appUserSetting.saveSettings();
    this.appView.dialogScreen.messageBox("\u4FDD\u5B58\u3057\u307E\u3057\u305F\u3002");
  }
  getLocalSetting() {
    return this.appUserSetting.settingFile.localSetting;
  }
  setUIStateVisible(uiStateName, visible) {
    const uiState = this.appUserSetting.userUIState.getUIState(uiStateName);
    if (uiState) {
      uiState.visible = visible;
    }
  }
  setOperatorCursorLocationToMouse() {
    vec3.copy(this.docContext.operatorCursor.location, this.appView.mainWindow.pointerEvent.location);
    this.subtoolContext.setRedrawEditorWindow();
  }
  setLazyUpdateNeeded() {
    this.appDefferedProcess.startLazyUpdates();
  }
  setPostUpdateNeeded() {
    this.appDefferedProcess.setPostUpdateNeeded();
  }
  openFileDialog(targetID) {
    if (targetID == OpenFileDialogTargetID.imageFileReferenceLayerFilePath) {
      if (!ImageFileReferenceLayer.isImageFileReferenceLayer(this.docContext.currentLayer)) {
        throw new Error("ERROR 0002:OpenFileDialog Invalid execution for current layer.");
      }
      this.appView.modalWindow.openImageFileReferenceModal();
    }
  }
  collectVectorViewKeyframeLayers() {
    return this.docContext.currentViewKeyframe.layers.slice();
  }
  collectVectorViewKeyframeLayersForEdit() {
    return this.appView.viewKeyframe.collectVectorViewKeyframeLayersForEdit(this.docContext.currentViewKeyframe, true);
  }
  updateLayerStructure() {
    this.updateLayerStructureInternal(true, true, true, true);
  }
  getPosingModelByName(name) {
    return this.appView.modelFile.posingModelDictionary.get(name);
  }
  getDocumentData() {
    return this.docContext.documentData;
  }
  updateForLayerProperty() {
    this.updateLayerStructureInternal(true, true, true, true);
  }
  exportImageFile(param) {
    this.docContext.documentData.exportImageSetting.fileName = param.fileName;
    this.docContext.documentData.exportImageSetting.exportDirectory = param.exportDirectory;
    this.docContext.documentData.exportImageSetting.imageFileType = param.imageFileType;
    this.docContext.documentData.exportImageSetting.backGroundType = param.backGroundType;
    this.docContext.documentData.exportImageSetting.scale = param.scale;
    this.docContext.documentData.exportImageSetting.autoNumberingEnabled = param.autoNumberingEnabled;
    this.docContext.documentData.exportImageSetting.exportingCount = param.exportingCount;
    this.appDocument.exportImageFile(param.fileName, param.exportDirectory, param.scale, param.imageFileType, param.backGroundType, param.exportingCount);
  }
  executeLayerCommand(layerCommand) {
    this.appDocument.executeLayerCommand(layerCommand);
  }
}
function UI_RibbonUI_Separator() {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "separator"
  });
}
function UI_RibbonUI_Button({ ribbonUIRef, icon, label, id: id2 }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "button",
    onPointerDown: () => ribbonUIRef.button_Clicked(id2)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "button-inner"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "icon"
  }, /* @__PURE__ */ react.exports.createElement("img", {
    src: icon
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, label.map((labelText, index2) => /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, {
    key: index2
  }, /* @__PURE__ */ react.exports.createElement("span", null, labelText), index2 != label.length - 1 && /* @__PURE__ */ react.exports.createElement("br", null))))));
}
function UI_RibbonUI_SubToolButton({ icon, label, subtoolID, currentSubtoolID, onClick }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `tool-button selectable-item ${subtoolID == currentSubtoolID ? "selected" : ""}`,
    onPointerDown: () => onClick(subtoolID)
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "tool-button-inner selectable-item-inner"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "icon"
  }, /* @__PURE__ */ react.exports.createElement("img", {
    src: icon
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, label.map((labelText, index2) => /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, {
    key: index2
  }, /* @__PURE__ */ react.exports.createElement("span", null, labelText), index2 != label.length - 1 && /* @__PURE__ */ react.exports.createElement("br", null))))));
}
function UI_RibbonUI_InputLabel({ label = "" }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "input-label"
  }, label);
}
function UI_RibbonUI_TextInput({ maxLength = 100, value, onChange }) {
  let valueText = "";
  if (typeof value == "string") {
    valueText = value;
  }
  function handleChange(event) {
    let inputValue = event.target.value;
    if (inputValue.length > maxLength) {
      inputValue = Strings.substring(inputValue, 0, maxLength);
    }
    if (onChange) {
      onChange(inputValue);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("input", {
    className: "text-input",
    value: valueText,
    onChange: handleChange
  });
}
function UI_RibbonUI_ToggleButtonGroup({ children, id: id2, currentValue, large, onClick }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `toggle-button-group${large ? " large" : ""}`
  }, react.exports.Children.map(
    children,
    (child, i) => {
      return react.exports.cloneElement(child, { id: id2, currentValue, onClick });
    }
  ));
}
function UI_RibbonUI_ToggleButton({ label, id: id2, value, currentValue, onClick }) {
  function handleClick() {
    if (onClick) {
      onClick(id2, value);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `toggle-button selectable-item ${currentValue == value ? "selected" : ""}`,
    onPointerDown: handleClick
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "toggle-button-inner selectable-item-inner-sq"
  }, label));
}
function UI_RibbonUI_RGBAColor({ value, onClick }) {
  function handleClick() {
    if (onClick) {
      onClick();
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "rgba-color",
    onPointerDown: handleClick
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "alpha alpha-checker-background-pallete"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "alpha-color",
    style: { backgroundColor: `rgba(${ColorLogic.rgbaToRgbaString(value)})` }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "rgb",
    style: { backgroundColor: `#${ColorLogic.rgbToHex2String(value)}` }
  }));
}
function UI_RibbonUI_AutoFillLayer({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.autoFill],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      set_currentSubtoolID(subtoolID);
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-auto-fill${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.draw,
    label: ["\u8FFD\u52A0", "1"],
    subtoolID: SubToolID.addAutoFillPoint,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.eracer,
    label: ["\u524A\u9664", "2/E"],
    subtoolID: SubToolID.deleteAutoFillPoint,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUI_Document({ ribbonUIRef, isVisible }) {
  const layout = DocumentData.getDocumentLayout(ribbonUIRef.docContext.documentData, 1);
  const [documentFrame_left, set_documentFrame_left] = react.exports.useState(layout.left);
  const [documentFrame_top, set_documentFrame_top] = react.exports.useState(layout.top);
  const [documentFrame_width, set_documentFrame_width] = react.exports.useState(layout.width);
  const [documentFrame_height, set_documentFrame_height] = react.exports.useState(layout.height);
  const [lineWidthBiasRate, set_lineWidthBiasRate] = react.exports.useState(ribbonUIRef.docContext.documentData.lineWidthBiasRate);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.document],
    update: (docContext) => {
      const layout2 = DocumentData.getDocumentLayout(docContext.documentData, 1);
      set_documentFrame_left(layout2.left);
      set_documentFrame_top(layout2.top);
      set_documentFrame_width(layout2.width);
      set_documentFrame_height(layout2.height);
      set_lineWidthBiasRate(docContext.documentData.lineWidthBiasRate);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function documentFrame_Changed(left, top, width, height) {
    const values = [left, top, width, height];
    if (values.find((value) => !Number.isSafeInteger(value))) {
      return;
    }
    if (ribbonUIRef.documentFrame_Changed) {
      ribbonUIRef.documentFrame_Changed(left, top, width, height);
    }
  }
  function numberInput_Changed(id2, value, setFunction) {
    setFunction(value);
    if (ribbonUIRef.numberInput_Changed) {
      ribbonUIRef.numberInput_Changed(id2, value);
    }
  }
  const positionStepValue = 1;
  const minPositionValue = -1e5;
  const maxPositionValue = 1e5;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-document${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30AD\u30E3\u30F3\u30D0\u30B9\u7BC4\u56F2"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "vertical-layout document-size-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u6A2A\u4F4D\u7F6E"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: documentFrame_left,
    digit: 0,
    step: positionStepValue,
    min: minPositionValue,
    max: maxPositionValue,
    onChange: (value) => {
      set_documentFrame_left(value);
      documentFrame_Changed(value, documentFrame_top, documentFrame_width, documentFrame_height);
    }
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u7E26\u4F4D\u7F6E"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: documentFrame_top,
    digit: 0,
    step: positionStepValue,
    min: minPositionValue,
    max: maxPositionValue,
    onChange: (value) => {
      set_documentFrame_top(value);
      documentFrame_Changed(documentFrame_left, value, documentFrame_width, documentFrame_height);
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30B5\u30A4\u30BA"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: documentFrame_width,
    digit: 0,
    step: positionStepValue,
    min: 1,
    max: maxPositionValue,
    onChange: (value) => {
      set_documentFrame_width(value);
      documentFrame_Changed(documentFrame_left, documentFrame_top, value, documentFrame_height);
    }
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\xD7"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: documentFrame_height,
    digit: 0,
    step: positionStepValue,
    min: 1,
    max: maxPositionValue,
    onChange: (value) => {
      set_documentFrame_height(value);
      documentFrame_Changed(documentFrame_left, documentFrame_top, documentFrame_width, value);
    }
  }))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u63CF\u753B"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "vertical-layout document-size-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30D9\u30FC\u30B9\u7DDA\u5E45"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: lineWidthBiasRate,
    digit: 2,
    step: 0.1,
    min: 0.01,
    max: 10,
    onChange: (value) => {
      set_lineWidthBiasRate(value);
      numberInput_Changed(RibbonUIControlID.document_lineWidthBiasRate, value, set_lineWidthBiasRate);
    }
  }))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null));
}
function UI_RibbonUI_Edit({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const [operationUnitID, set_operationUnitID] = react.exports.useState(ribbonUIRef.docContext.operationUnitID);
  const [operationOriginTypeID, set_operationOriginTypeID] = react.exports.useState(ribbonUIRef.docContext.operationOriginTypeID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.edit],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
      set_operationUnitID(docContext.operationUnitID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  function tobbleButton_Clickd(id2, value, setFunction) {
    setFunction(value);
    if (ribbonUIRef.toggleButton_Clicked) {
      ribbonUIRef.toggleButton_Clicked(id2, value);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-edit${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u7DE8\u96C6\u30C4\u30FC\u30EB"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents grouped-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column-inner"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u7DE8\u96C6\u5358\u4F4D"
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.edit_operationUnit,
    currentValue: operationUnitID,
    onClick: (id2, value) => tobbleButton_Clickd(id2, value, set_operationUnitID)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u7DDA",
    value: OperationUnitID.stroke
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u7DDA\u5206",
    value: OperationUnitID.strokeSegment
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u70B9",
    value: OperationUnitID.strokePoint
  })), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u539F\u70B9"
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.edit_operationOrigin,
    currentValue: operationOriginTypeID,
    onClick: (id2, value) => tobbleButton_Clickd(id2, value, set_operationOriginTypeID)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u4E2D\u5FC3",
    value: OperationOriginTypeID.medianCenter
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u30AB\u30FC\u30BD\u30EB",
    value: OperationOriginTypeID.pivot
  })))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: operationUnitID == OperationUnitID.stroke ? SVGFiles.icons.selectLine : operationUnitID == OperationUnitID.strokeSegment ? SVGFiles.icons.selectSegment : SVGFiles.icons.selectPoint,
    label: ["\u9078\u629E", "1"],
    subtoolID: SubToolID.brushSelect,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.editTransform,
    label: ["\u30AB\u30FC\u30BD\u30EB", "2"],
    subtoolID: SubToolID.locateOperatorCursor,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.editTransform,
    label: ["\u79FB\u52D5/\u5909\u5F62", "3"],
    subtoolID: SubToolID.editModeMain,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.divideLineSegment,
    label: ["\u518D\u5206\u5272", "4"],
    subtoolID: SubToolID.resampleSegment,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUI_Home({ ribbonUIRef, isVisible }) {
  react.exports.useState(ribbonUIRef.docContext.subtoolID);
  react.exports.useEffect(() => {
  }, []);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-home${!isVisible ? " hidden" : ""}`
  });
}
function UI_RibbonUI_Layer_VectorLayer({ ribbonUIRef }) {
  const currentVectorLayer = ribbonUIRef.docContext.currentVectorLayer;
  const isVectorLayer = currentVectorLayer != null;
  const [drawLineType, set_drawLineType] = react.exports.useState(isVectorLayer ? currentVectorLayer.drawLineType : DrawLineTypeID.none);
  const [fillAreaType, set_fillAreaType] = react.exports.useState(isVectorLayer ? currentVectorLayer.fillAreaType : FillAreaTypeID.none);
  const [lineWidthBiasRate, set_lineWidthBiasRate] = react.exports.useState(isVectorLayer ? currentVectorLayer.lineWidthBiasRate : 1);
  const [eyesSymmetry_visible, set_eyesSymmetry_visible] = react.exports.useState(isVectorLayer && VectorLayer.isVectorStrokeLayer(currentVectorLayer));
  const [eyesSymmetry_enabled, set_eyesSymmetry_enabled] = react.exports.useState(isVectorLayer && currentVectorLayer.eyesSymmetryEnabled);
  const [eyesSymmetry_side, set_eyesSymmetry_side] = react.exports.useState(isVectorLayer && currentVectorLayer.eyesSymmetryInputSide);
  const [eyesSymmetry_layerOptions, set_eyesSymmetry_layerOptions] = react.exports.useState(ribbonUIRef.posingLayerOptions);
  const [eyesSymmetry_currentOption, set_eyesSymmetry_currentOption] = react.exports.useState(ribbonUIRef.posingLayerOptions_Selected);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.layer],
    filter: (layer) => {
      return VectorLayer.isVectorLayerWithOwnData(layer);
    },
    update: (docContext) => {
      const vectorLayer = docContext.currentVectorLayer;
      set_drawLineType(vectorLayer.drawLineType);
      set_fillAreaType(vectorLayer.fillAreaType);
      set_lineWidthBiasRate(vectorLayer.lineWidthBiasRate);
      set_eyesSymmetry_visible(VectorLayer.isVectorStrokeLayer(vectorLayer));
      set_eyesSymmetry_enabled(vectorLayer.eyesSymmetryEnabled);
      set_eyesSymmetry_side(vectorLayer.eyesSymmetryInputSide);
      set_eyesSymmetry_layerOptions(ribbonUIRef.posingLayerOptions);
      set_eyesSymmetry_currentOption(ribbonUIRef.posingLayerOptions_Selected);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function numberInput_Changed(id2, value, setFunction) {
    setFunction(value);
    if (ribbonUIRef.numberInput_Changed) {
      ribbonUIRef.numberInput_Changed(id2, value);
    }
  }
  function eyesSymmetry_enabled_Changed(id2, checked, value) {
    if (ribbonUIRef.checkBox_Changed) {
      ribbonUIRef.checkBox_Changed(id2, checked, value);
    }
  }
  function eyesSymmetry_layerOptions_Changed(id2, item) {
    if (ribbonUIRef.selectBox_Changed) {
      ribbonUIRef.selectBox_Changed(id2, item);
    }
  }
  function tobbleButton_Clickd(id2, value, setFunction) {
    setFunction(value);
    if (ribbonUIRef.toggleButton_Clicked) {
      ribbonUIRef.toggleButton_Clicked(id2, value);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "ribbon-ui-layer"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u63CF\u753B"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents grouped-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column-inner"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u7DDA\u8272"
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.vectorLayer_drawLineType,
    currentValue: drawLineType,
    onClick: (id2, value) => tobbleButton_Clickd(id2, value, set_drawLineType)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u306A\u3057",
    value: DrawLineTypeID.none
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u30EC\u30A4\u30E4\u30FC\u8272",
    value: DrawLineTypeID.layerColor
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u30D1\u30EC\u30C3\u30C8",
    value: DrawLineTypeID.paletteColor
  })), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u5857\u308A\u8272"
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.vectorLayer_fillAreaType,
    currentValue: fillAreaType,
    onClick: (id2, value) => tobbleButton_Clickd(id2, value, set_fillAreaType)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u306A\u3057",
    value: FillAreaTypeID.none
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u30EC\u30A4\u30E4\u30FC\u8272",
    value: FillAreaTypeID.fillColor
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u30D1\u30EC\u30C3\u30C8",
    value: FillAreaTypeID.paletteColor
  })))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column-inner"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30D9\u30FC\u30B9\u7DDA\u5E45"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: lineWidthBiasRate,
    digit: 2,
    step: 0.1,
    min: 0.01,
    max: 10,
    onChange: (value) => numberInput_Changed(RibbonUIControlID.vectorLayer_lineWidthBiasRate, value, set_lineWidthBiasRate)
  }))))), eyesSymmetry_visible && /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u76EE\u306E\u5DE6\u53F3\u5BFE\u79F0\u88DC\u52A9"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "checkbox-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u6709\u52B9"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "checkbox"
  }, /* @__PURE__ */ react.exports.createElement(UI_CheckBox, {
    value: eyesSymmetry_enabled,
    onChange: (checked, value) => eyesSymmetry_enabled_Changed(RibbonUIControlID.vectorLayer_enableEyesSymmetry, checked, value)
  }))), eyesSymmetry_enabled && /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u63CF\u304D\u3053\u3080\u5074"), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.vectorLayer_eyesSymmetryInputSide,
    currentValue: eyesSymmetry_side,
    onClick: (id2, value) => tobbleButton_Clickd(id2, value, set_eyesSymmetry_side)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u5DE6",
    value: EyesSymmetryInputSideID.left
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u53F3",
    value: EyesSymmetryInputSideID.right
  }))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "select-item eyes-symmetry"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30DD\u30FC\u30BA\u30EC\u30A4\u30E4\u30FC"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "select-box"
  }, /* @__PURE__ */ react.exports.createElement(UI_SelectBox, {
    selectBoxPopoverRef: ribbonUIRef.selectBoxPopoverRef,
    border: true,
    options: eyesSymmetry_layerOptions,
    values: eyesSymmetry_currentOption,
    onChange: (item) => eyesSymmetry_layerOptions_Changed(RibbonUIControlID.vectorLayer_posingLayer, item)
  }))))))));
}
function UI_RibbonUI_Layer({ ribbonUIRef, isVisible }) {
  const [state, set_state] = react.exports.useState(() => {
    return createState(ribbonUIRef.docContext.currentLayer);
  });
  const layerTypeNames = react.exports.useMemo(() => /* @__PURE__ */ new Map([
    [LayerTypeID.none, ""],
    [LayerTypeID.rootLayer, ""],
    [LayerTypeID.vectorLayer, "\u7DDA\u753B \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.groupLayer, "\u30B0\u30EB\u30FC\u30D7 \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.imageFileReferenceLayer, "\u753B\u50CF\u30D5\u30A1\u30A4\u30EB \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.posingLayer, "3D\u30DD\u30FC\u30BA \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.vectorLayerReferenceLayer, "\u7DDA\u753B\u53C2\u7167 \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.autoFillLayer, "\u81EA\u52D5\u5857\u308A \u30EC\u30A4\u30E4\u30FC"],
    [LayerTypeID.surroundingFillLayer, "\u56F2\u307F\u5857\u308A \u30EC\u30A4\u30E4\u30FC"]
  ]), []);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.layer],
    update: (docContext) => {
      set_state(createState(docContext.currentLayer));
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function createState(layer) {
    const isVectorLayer = VectorLayer.isVectorLayer(layer);
    const vectorLayer = isVectorLayer ? layer : null;
    return {
      currentLayer: layer,
      isVectorLayer,
      layerName: layer.name,
      layerColor: ColorLogic.rgbaToRgbaString(layer.layerColor),
      isRenderTarget: layer.isRenderTarget,
      isMaskedByBelowLayer: layer.isMaskedByBelowLayer,
      fillColor: isVectorLayer ? ColorLogic.rgbaToRgbaString(vectorLayer.fillColor) : ""
    };
  }
  function updateState(old_state, value, propName) {
    const new_state = createState(old_state.currentLayer);
    new_state[String(propName)] = value;
    set_state(new_state);
    return new_state;
  }
  function textInput_Changed(id2, value, propName) {
    updateState(state, value, propName);
    if (ribbonUIRef.textInput_Changed) {
      ribbonUIRef.textInput_Changed(id2, value);
    }
  }
  function checkBox_Changed(id2, checked, value, propName) {
    updateState(state, value, propName);
    if (ribbonUIRef.checkBox_Changed) {
      ribbonUIRef.checkBox_Changed(id2, checked, value);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-layer${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, layerTypeNames.has(state.currentLayer.type) ? layerTypeNames.get(state.currentLayer.type) : ""), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "vertical-layout layer-basic-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_TextInput, {
    value: state.layerName,
    maxLength: 40,
    onChange: (value) => {
      textInput_Changed(RibbonUIControlID.layer_name, value, "layerName");
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "layer-colors"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_RGBAColor, {
    value: state.currentLayer.layerColor
  }), state.isVectorLayer && /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_RGBAColor, {
    value: state.currentLayer.fillColor
  })))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u51E6\u7406\u5BFE\u8C61"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents layer-additional-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column-inner",
    onClick: () => checkBox_Changed(RibbonUIControlID.layer_isMaskedByBelowLayer, !state.isMaskedByBelowLayer, !state.isMaskedByBelowLayer, "isMaskedByBelowLayer")
  }, /* @__PURE__ */ react.exports.createElement(UI_CheckBox, {
    value: state.isMaskedByBelowLayer
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u4E0B\u306E\u30EC\u30A4\u30E4\u30FC\u3067\u30DE\u30B9\u30AF"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-column-inner",
    onClick: () => checkBox_Changed(RibbonUIControlID.layer_isRenderTarget, !state.isRenderTarget, !state.isRenderTarget, "isRenderTarget")
  }, /* @__PURE__ */ react.exports.createElement(UI_CheckBox, {
    value: state.isRenderTarget
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8"
  }))))), state.isVectorLayer && /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Layer_VectorLayer, {
    ribbonUIRef
  })), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null));
}
function UI_RibbonUI_Main_Drawing_NonScroll({ ribbonUIRef, isVisible }) {
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.drawing, MainToolTabID.group, MainToolTabID.pointBrushFill],
    onActivated: () => {
      ribbonUIRef.brushPropertyBoxRef.resize();
    },
    update: () => {
      ribbonUIRef.brushPropertyBoxRef.updateBox();
      ribbonUIRef.brushPropertyBoxRef.updatePopover();
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.brushPropertyBoxRef.numberInput_Changed = (id2, value) => {
      if (ribbonUIRef.numberInput_Changed) {
        ribbonUIRef.numberInput_Changed(id2, value, true);
      }
    };
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.brushPropertyBoxRef.numberInput_Changed = null;
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_BrushPropertyBox, {
    uiRef: ribbonUIRef.brushPropertyBoxRef
  }));
}
function UI_RibbonUI_Main_Drawing({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.drawing],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      set_currentSubtoolID(subtoolID);
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-main-drawing${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.draw,
    label: ["\u7DDA\u3092\u63CF\u304F", "1"],
    subtoolID: SubToolID.drawLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.eracer,
    label: ["\u6D88\u3057\u30B4\u30E0", "2/  E"],
    subtoolID: SubToolID.deletePointBrush,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.scratchLine,
    label: ["\u7DDA\u306E\u4FEE\u6B63", "3"],
    subtoolID: SubToolID.scratchLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.extrudeLine,
    label: ["\u7DDA\u306E\u5EF6\u9577", "4"],
    subtoolID: SubToolID.extrudeLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.drawStrokeWidth,
    label: ["\u592A\u304F\u3059\u308B", "5"],
    subtoolID: SubToolID.scratchLineWidth,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.dummy,
    label: ["\u592A\u3055\u306E\u8A2D\u5B9A", "6"],
    subtoolID: SubToolID.overWriteLineWidth,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUI_Main_GroupLayer({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.group],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-edit${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.scratchLine,
    label: ["\u7DDA\u306E\u4FEE\u6B63", "1"],
    subtoolID: SubToolID.scratchLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.eracer,
    label: ["\u6D88\u3057\u30B4\u30E0", "2/  E"],
    subtoolID: SubToolID.deletePointBrush,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.dummy,
    label: ["\u592A\u3055\u306E\u8A2D\u5B9A", "3"],
    subtoolID: SubToolID.overWriteLineWidth,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.divideLineSegment,
    label: ["\u518D\u5206\u5272", "4"],
    subtoolID: SubToolID.resampleSegment,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUI_Main_ImageFileReferlence({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.imageFileReference],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      set_currentSubtoolID(subtoolID);
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-main-iamge-file-ref${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Button, {
    ribbonUIRef,
    icon: SVGFiles.icons.openImage,
    label: ["\u30D5\u30A1\u30A4\u30EB\u306E\u9078\u629E"],
    id: RibbonUIControlID.imageFileRef_openImageFile
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.move,
    label: ["\u79FB\u52D5", "1"],
    subtoolID: SubToolID.image_GrabMove,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.rotate,
    label: ["\u56DE\u8EE2", "2"],
    subtoolID: SubToolID.image_Rotate,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.scale,
    label: ["\u62E1\u7E2E", "3"],
    subtoolID: SubToolID.image_Scale,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUITabs({ uiRef }) {
  const [current_tabID, set_current_tabID] = react.exports.useState(MainToolTabID.none);
  const [mainToolTabs, set_MainToolTabs] = react.exports.useState([]);
  react.exports.useEffect(() => {
    uiRef.update = (docContext) => {
      set_current_tabID(docContext.mainToolTabID);
      set_MainToolTabs(docContext.mainToolTabs);
    };
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  function item_Clicked(id2) {
    if (uiRef.item_Clicked) {
      uiRef.item_Clicked(id2);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "tabs"
  }, mainToolTabs.map(
    (tab) => /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, {
      key: tab.tabID
    }, tab.tabID == MainToolTabID.group && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.group,
      label: "\u30B0\u30EB\u30FC\u30D7",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.drawing && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.drawing,
      label: "\u7DDA\u753B",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.pointBrushFill && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.pointBrushFill,
      label: "\u30D6\u30E9\u30B7\u5857\u308A",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.autoFill && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.autoFill,
      label: "\u81EA\u52D5\u56F2\u307F\u5857\u308A",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.imageFileReference && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.imageFileReference,
      label: "\u753B\u50CF\u30D5\u30A1\u30A4\u30EB",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.posing && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.posing,
      label: "3D\u30DD\u30FC\u30BA",
      current_tabID,
      handleClick: item_Clicked
    }), (tab.tabID == MainToolTabID.edit || tab.tabID == MainToolTabID.edit_disabled) && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.edit,
      label: "\u7DE8\u96C6",
      disabled: tab.tabID == MainToolTabID.edit_disabled,
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.document && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.document,
      label: "\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.layer && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.layer,
      label: "\u30EC\u30A4\u30E4\u30FC",
      current_tabID,
      handleClick: item_Clicked
    }), tab.tabID == MainToolTabID.view && /* @__PURE__ */ react.exports.createElement(UI_RibbonTab, {
      tabID: MainToolTabID.view,
      label: "\u8868\u793A/\u8A2D\u5B9A",
      current_tabID,
      handleClick: item_Clicked
    }))
  ));
}
function UI_RibbonTab({ tabID, label, disabled = false, current_tabID, handleClick }) {
  function clicked() {
    if (!disabled) {
      return handleClick(tabID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `tab${current_tabID == tabID ? " selected" : ""}${disabled ? " disabled" : ""}`,
    onPointerDown: clicked
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "tab-label"
  }, label));
}
function UI_RibbonUI_View({ ribbonUIRef, isVisible }) {
  const [defaultViewScale, set_defaultViewScale] = react.exports.useState(ribbonUIRef.docContext.documentData.defaultViewScale);
  const [hideOuterArea, set_hideOuterArea] = react.exports.useState(ribbonUIRef.docContext.documentData.documentFrame_HideOuterArea);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.view],
    update: (docContext) => {
      set_defaultViewScale(docContext.documentData.defaultViewScale);
      set_hideOuterArea(docContext.documentData.documentFrame_HideOuterArea);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function documentViewSettings_Changed(new_defaultViewScale) {
    const values = [new_defaultViewScale];
    if (values.find((value) => !Number.isFinite(value))) {
      return;
    }
    if (ribbonUIRef.documentViewSettings_Changed) {
      ribbonUIRef.documentViewSettings_Changed(new_defaultViewScale);
    }
  }
  function checkBox_Changed(id2, checked, value, setFunction) {
    setFunction(value);
    if (ribbonUIRef.checkBox_Changed) {
      ribbonUIRef.checkBox_Changed(id2, checked, value);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-view${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30D3\u30E5\u30FC"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "vertical-layout view-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30D9\u30FC\u30B9\u62E1\u5927\u7387"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: defaultViewScale,
    digit: 2,
    step: 0.1,
    min: 0.01,
    max: 10,
    onChange: (value) => {
      set_defaultViewScale(value);
      documentViewSettings_Changed(value);
    }
  }))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30AD\u30E3\u30F3\u30D0\u30B9"), /* @__PURE__ */ react.exports.createElement("div", {
    className: "group-contents"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "vertical-layout view-params"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "param-row",
    onClick: () => checkBox_Changed(RibbonUIControlID.document_hideOuterArea, !hideOuterArea, !hideOuterArea, set_hideOuterArea)
  }, /* @__PURE__ */ react.exports.createElement(UI_CheckBox, {
    value: hideOuterArea
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u5916\u5074\u3092\u96A0\u3059"
  }))))), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Separator, null));
}
const itemScale = 0.9;
function UI_SubToolWindow({ ribbonUIRef, subToolWindowUIRef, isVisible }) {
  const [items, setItems] = react.exports.useState(subToolWindowUIRef.items);
  const [active_SubToolIndex, setActive_SubToolIndex] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  react.exports.useEffect(() => {
    subToolWindowUIRef.update = (items2, subToolIndex) => {
      setItems(items2);
      setActive_SubToolIndex(subToolIndex);
    };
    return function cleanup() {
      subToolWindowUIRef.update = null;
    };
  }, []);
  function item_Clicked(e, item) {
    if (e.button == 0) {
      subToolWindowUIRef.item_Click(item);
    }
  }
  function itemButton_Clicked(e, item) {
    if (e.button == 0) {
      subToolWindowUIRef.itemButton_Click(item);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `subtool-window${!isVisible ? " hidden" : ""}`
  }, items.map((item) => /* @__PURE__ */ react.exports.createElement("div", {
    key: item.subToolID,
    className: `item selectable-item ${active_SubToolIndex == item.subToolID ? "selected" : ""}`,
    onMouseDown: (e) => {
      item_Clicked(e, item);
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: `item-inner selectable-item-inner ${item.tool.toolBarImage.cssImageClassName}`,
    style: { backgroundPosition: `0 -${item.tool.toolBarImageIndex * 64 * itemScale}px`, opacity: item.isAvailable ? 1 : 0.5 }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "spacer"
  }), item.buttons.length > 0 ? /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-button image-splite-system",
    style: { backgroundPosition: `-${(item.buttonStateID - 1) * 64 * itemScale}px 0` },
    onMouseDown: (e) => {
      itemButton_Clicked(e, item);
    }
  }) : /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-button"
  })))));
}
function UI_RibbonUI_PointBrushFill({ ribbonUIRef, isVisible }) {
  const [currentSubtoolID, set_currentSubtoolID] = react.exports.useState(ribbonUIRef.docContext.subtoolID);
  const tabFunctionInfo = react.exports.useMemo(() => ({
    tabID: [MainToolTabID.pointBrushFill],
    update: (docContext) => {
      set_currentSubtoolID(docContext.subtoolID);
    }
  }), []);
  react.exports.useEffect(() => {
    ribbonUIRef.registerTabFunctionInfo(tabFunctionInfo);
    return function cleanup() {
      ribbonUIRef.unregisterTabFunctionInfo(tabFunctionInfo);
    };
  }, []);
  function subToolButton_Clicked(subtoolID) {
    if (ribbonUIRef.subtoolButton_Clicked) {
      set_currentSubtoolID(subtoolID);
      ribbonUIRef.subtoolButton_Clicked(subtoolID);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: `ribbon-ui-main-drawing${!isVisible ? " hidden" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.draw,
    label: ["\u7DDA\u3092\u63CF\u304F", "1"],
    subtoolID: SubToolID.drawPointBrush,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.eracer,
    label: ["\u6D88\u3057\u30B4\u30E0", "2/  E"],
    subtoolID: SubToolID.deletePointBrush,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.scratchLine,
    label: ["\u7DDA\u306E\u4FEE\u6B63", "3"],
    subtoolID: SubToolID.scratchLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_SubToolButton, {
    icon: SVGFiles.icons.extrudeLine,
    label: ["\u7DDA\u306E\u5EF6\u9577", "4"],
    subtoolID: SubToolID.pointBrush_extrudeLine,
    currentSubtoolID,
    onClick: subToolButton_Clicked
  }));
}
function UI_RibbonUI({ uiRef, subToolWindowRef }) {
  const [tabID, set_tabID] = react.exports.useState(MainToolTabID.none);
  react.exports.useEffect(() => {
    uiRef.setMainToolTab = (new_tabID) => {
      set_tabID(new_tabID);
    };
    return function cleanup() {
      uiRef.setMainToolTab = null;
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    className: "tool-ribbon"
  }, uiRef.docContext != null && /* @__PURE__ */ react.exports.createElement("div", {
    className: "tool-ribbon-rows"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "tabs-row"
  }, /* @__PURE__ */ react.exports.createElement(UI_MainMenuButton, {
    uiRef: uiRef.mainMenuButtonRef
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "centering-spacer"
  }), /* @__PURE__ */ react.exports.createElement(UI_ScrollView, {
    wheelScrollY: 32,
    direction: "horizontal",
    alignment: "center"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUITabs, {
    uiRef: uiRef.ribbonUITabsRef
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "centering-spacer"
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "right-menu-button-spacer"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ribbon-ui-row"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "centering-spacer"
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "nonscroll-part"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Main_Drawing_NonScroll, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.group || tabID == MainToolTabID.drawing || tabID == MainToolTabID.pointBrushFill
  })), /* @__PURE__ */ react.exports.createElement(UI_ScrollView, {
    wheelScrollY: 32,
    direction: "horizontal",
    alignment: "center"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Home, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.none
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Main_Drawing, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.drawing
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Main_GroupLayer, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.group
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_AutoFillLayer, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.autoFill
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_PointBrushFill, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.pointBrushFill
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Main_ImageFileReferlence, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.imageFileReference
  }), /* @__PURE__ */ react.exports.createElement(UI_SubToolWindow, {
    ribbonUIRef: uiRef,
    subToolWindowUIRef: subToolWindowRef,
    isVisible: tabID == MainToolTabID.posing
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Edit, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.edit
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Layer, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.layer
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_Document, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.document
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_View, {
    ribbonUIRef: uiRef,
    isVisible: tabID == MainToolTabID.view
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "centering-spacer"
  })))));
}
function UI_ModalWindowContainer({ children, uiRef, modalWindowTitle, onEscape }) {
  const backdropRef = react.exports.useRef(null);
  const windowContainerRef = react.exports.useRef(null);
  const backDropClickedRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    uiRef.show = (modalRef) => {
      backdropRef.current.parentElement.classList.remove("hidden");
      backDropClickedRef.current = false;
      modalRef.onModalWindowOpened();
      window.setTimeout(() => {
        windowContainerRef.current.focus();
      }, 100);
    };
    uiRef.hide = (modalRef) => {
      backdropRef.current.parentElement.classList.add("hidden");
      modalRef.onModalWindowClosed();
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.hide = null;
    };
  }, []);
  function container_keyDown(e) {
    if (e.key == "Escape") {
      if (onEscape) {
        onEscape();
        e.stopPropagation();
      }
    }
  }
  function backdrop_PointerDown(e) {
    e.preventDefault();
    backDropClickedRef.current = true;
  }
  function backdrop_PointerUp(e) {
    e.preventDefault();
    if (backDropClickedRef.current) {
      backDropClickedRef.current = false;
      if (onEscape) {
        onEscape();
      }
    }
  }
  function windowContainer_PointerMove(e) {
    backDropClickedRef.current = false;
  }
  function stopPropagation(e) {
    e.stopPropagation();
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-window-backdrop",
    ref: backdropRef,
    onPointerDown: backdrop_PointerDown,
    onPointerUp: backdrop_PointerUp
  }, /* @__PURE__ */ react.exports.createElement("div", {
    ref: windowContainerRef,
    className: `modal-window-container`,
    tabIndex: 0,
    onClick: stopPropagation,
    onPointerDown: stopPropagation,
    onKeyDown: container_keyDown,
    onPointerMove: windowContainer_PointerMove
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-window-header"
  }, modalWindowTitle), /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-window-content"
  }, children)));
}
function UI_Modal_ExportImage({ uiRef }) {
  const modalWindowContainerRef = react.exports.useMemo(() => ({}), []);
  const [exportFileName, set_exportFileName] = react.exports.useState("");
  const [exportDirectory, set_exportDirectory] = react.exports.useState("");
  const [autoNumberingEnabled, set_autoNumberingEnabled] = react.exports.useState(false);
  const [exportingCount, set_exportingCount] = react.exports.useState(0);
  const [imageFileType, set_imageFileType] = react.exports.useState(ImageFileTypeID.png);
  const [backGroundType, set_backGroundType] = react.exports.useState(DocumentBackGroundTypeID.lastPaletteColor);
  const [exportScale, set_exportScale] = react.exports.useState(null);
  const docContextRef = react.exports.useRef(null);
  const lastExportFileNameRef = react.exports.useRef("");
  const available = react.exports.useMemo(() => {
    return !Strings.isNullOrEmpty(exportFileName) && !Strings.isNullOrEmpty(exportDirectory);
  }, [exportFileName, exportDirectory]);
  react.exports.useEffect(() => {
    uiRef.show = (docContext, localSetting) => {
      docContextRef.current = docContext;
      if (Strings.isNullOrEmpty(docContext.documentData.exportImageSetting.fileName)) {
        const exportFileName2 = DocumentFileNameLogic.getExportFileName(docContext.documentFilePath, false, 0);
        set_exportFileName(exportFileName2);
      } else {
        set_exportFileName(docContext.documentData.exportImageSetting.fileName);
      }
      if (Strings.isNullOrEmpty(docContext.documentData.exportImageSetting.exportDirectory) && !Strings.isNullOrEmpty(docContext.documentFilePath)) {
        const exportDirectory2 = Platform.path.getDirectoryPath(docContext.documentFilePath);
        set_exportDirectory(exportDirectory2);
      } else {
        set_exportDirectory(docContext.documentData.exportImageSetting.exportDirectory);
      }
      set_imageFileType(docContext.documentData.exportImageSetting.imageFileType);
      set_backGroundType(docContext.documentData.exportImageSetting.backGroundType);
      set_exportScale(docContext.documentData.exportImageSetting.scale);
      set_exportScale(docContext.documentData.exportImageSetting.scale);
      set_autoNumberingEnabled(docContext.documentData.exportImageSetting.autoNumberingEnabled);
      set_exportingCount(docContext.documentData.exportImageSetting.exportingCount);
      modalWindowContainerRef.show(uiRef);
    };
    uiRef.hide = () => {
      modalWindowContainerRef.hide(uiRef);
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.hide = null;
    };
  }, []);
  function ok_Clicked() {
    if (!available) {
      return;
    }
    lastExportFileNameRef.current = exportFileName;
    uiRef.hide();
    if (uiRef.onClose) {
      const fileName = DocumentFileNameLogic.getExportFileName(exportFileName, autoNumberingEnabled, exportingCount);
      uiRef.onClose(
        {
          fileName,
          exportDirectory,
          imageFileType,
          backGroundType,
          scale: exportScale != null ? exportScale : 1,
          autoNumberingEnabled,
          exportingCount
        }
      );
    }
  }
  function cancel_Clicked() {
    uiRef.hide();
  }
  function modal_Escaped() {
    uiRef.hide();
  }
  return /* @__PURE__ */ react.exports.createElement(UI_ModalWindowContainer, {
    modalWindowTitle: "\u30A4\u30E1\u30FC\u30B8\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
    uiRef: modalWindowContainerRef,
    onEscape: modal_Escaped
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-export-image"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30D5\u30A1\u30A4\u30EB\u540D\uFF08\u62E1\u5F35\u5B50\u3092\u9664\u304F\uFF09"), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_TextInput, {
    value: exportFileName,
    onChange: (value) => {
      set_exportFileName(value);
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item auto-nmber-subsection"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "checkbox",
    onPointerDown: () => set_autoNumberingEnabled(!autoNumberingEnabled)
  }, /* @__PURE__ */ react.exports.createElement(UI_CheckBox, {
    value: autoNumberingEnabled
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u9023\u756A\u3092\u4ED8\u52A0"
  })), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: exportingCount,
    digit: 0,
    step: 1,
    min: 0,
    max: 999,
    onChange: (value) => {
      set_exportingCount(value);
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u5148"), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_TextInput, {
    value: exportDirectory,
    onChange: (value) => {
      set_exportDirectory(value);
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-spacer"
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u753B\u50CF\u5F62\u5F0F"), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.vectorLayer_drawLineType,
    currentValue: imageFileType,
    large: true,
    onClick: (id2, value) => set_imageFileType(value)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "png",
    value: ImageFileTypeID.png
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "jpeg",
    value: ImageFileTypeID.jpeg
  }))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-spacer"
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, "\u80CC\u666F"), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButtonGroup, {
    id: RibbonUIControlID.vectorLayer_drawLineType,
    currentValue: backGroundType,
    large: true,
    onClick: (id2, value) => set_backGroundType(value)
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u6700\u5F8C\u306E\u30D1\u30EC\u30C3\u30C8\u306E\u8272",
    value: DocumentBackGroundTypeID.lastPaletteColor
  }), /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_ToggleButton, {
    label: "\u900F\u904E\u8272",
    value: DocumentBackGroundTypeID.transparent
  }))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-spacer"
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "section-item"
  }, /* @__PURE__ */ react.exports.createElement(UI_RibbonUI_InputLabel, {
    label: "\u30B9\u30B1\u30FC\u30EB"
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    value: exportScale,
    digit: 2,
    step: 0.01,
    min: 0.1,
    max: 10,
    onChange: (value) => {
      set_exportScale(value);
    }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ok-cancel-buttons"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-primary ${!available ? "disabled" : ""}`,
    onClick: ok_Clicked
  }, "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8"), /* @__PURE__ */ react.exports.createElement("button", {
    className: "app-button-cancel",
    onClick: cancel_Clicked
  }, "\u30AD\u30E3\u30F3\u30BB\u30EB"))));
}
function UI_Modal_ImageFileReference({ uiRef }) {
  const fileRef = react.exports.useRef(null);
  const imageRef = react.exports.useRef(null);
  const modalWindowContainerRef = react.exports.useMemo(() => ({}), []);
  const [available, set_available] = react.exports.useState(false);
  react.exports.useEffect(() => {
    uiRef.show = () => {
      modalWindowContainerRef.show(uiRef);
    };
    uiRef.hide = () => {
      modalWindowContainerRef.hide(uiRef);
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.hide = null;
    };
  }, []);
  function image_Clicked() {
    fileRef.current.click();
  }
  function file_Changed(e) {
    if (e.target.files.length == 0) {
      return;
    }
    const reader = new FileReader();
    reader.onload = (event) => {
      if (typeof event.target.result == "string") {
        imageRef.current.src = event.target.result;
        set_available(true);
      }
    };
    reader.readAsDataURL(e.target.files[0]);
  }
  function ok_Clicked() {
    if (!available) {
      return;
    }
    uiRef.hide();
    if (fileRef.current.files.length == 0) {
      return;
    }
    if (uiRef.onClose) {
      const file = fileRef.current.files[0];
      let filePath;
      if ("path" in file) {
        filePath = Platform.path.getPlatformIndependentPath(file["path"]);
      } else {
        filePath = file.name;
      }
      uiRef.onClose(filePath, imageRef.current);
    }
  }
  function cancel_Clicked() {
    uiRef.hide();
  }
  function modal_Escaped() {
    uiRef.hide();
  }
  return /* @__PURE__ */ react.exports.createElement(UI_ModalWindowContainer, {
    modalWindowTitle: "\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u306E\u9078\u629E",
    uiRef: modalWindowContainerRef,
    onEscape: modal_Escaped
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-image-file-reference"
  }, /* @__PURE__ */ react.exports.createElement("input", {
    type: "file",
    accept: "image/jpeg,image/png,image/gif,image/bmp",
    ref: fileRef,
    onChange: file_Changed
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "image",
    onClick: image_Clicked
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: `text ${available ? "hidden" : ""}`
  }, "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u3092", /* @__PURE__ */ react.exports.createElement("br", null), "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002"), /* @__PURE__ */ react.exports.createElement("img", {
    ref: imageRef,
    className: !available ? "hidden" : ""
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ok-cancel-buttons"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-primary ${!available ? "disabled" : ""}`,
    onClick: ok_Clicked
  }, "\u6C7A\u5B9A"), /* @__PURE__ */ react.exports.createElement("button", {
    className: "app-button-cancel",
    onClick: cancel_Clicked
  }, "\u30AD\u30E3\u30F3\u30BB\u30EB"))));
}
function UI_Modal_RadioSelection({ uiRef }) {
  const [windowTitle, set_windowTitle] = react.exports.useState("");
  const [options, set_options] = react.exports.useState([]);
  const [selectedIndex, set_selectedIndex] = react.exports.useState(0);
  const modalWindowContainerRef = react.exports.useMemo(() => ({}), []);
  react.exports.useEffect(() => {
    uiRef.show = (new_WindowTitle, new_Options, new_selectedIndex) => {
      set_windowTitle(new_WindowTitle);
      set_options(new_Options);
      if (new_Options.find((option) => option.index == new_selectedIndex)) {
        set_selectedIndex(new_selectedIndex);
      } else {
        throw new Error("ERROR 2001:Invalid default selected index");
      }
      modalWindowContainerRef.show(uiRef);
    };
    uiRef.hide = () => {
      modalWindowContainerRef.hide(uiRef);
    };
    return function cleanup() {
      uiRef.show = null;
      uiRef.hide = null;
    };
  }, []);
  function option_Clicked(option) {
    set_selectedIndex(option.index);
  }
  function ok_Clicked() {
    if (uiRef.selection_Fixed) {
      const option = options.find((opt) => opt.index == selectedIndex);
      uiRef.selection_Fixed(option);
    }
    uiRef.hide();
  }
  function cancel_Clicked() {
    uiRef.hide();
    if (uiRef.selection_Cancled) {
      uiRef.selection_Cancled();
    }
  }
  function modal_Escaped() {
    uiRef.hide();
  }
  return /* @__PURE__ */ react.exports.createElement(UI_ModalWindowContainer, {
    modalWindowTitle: windowTitle,
    uiRef: modalWindowContainerRef,
    onEscape: modal_Escaped
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "modal-radio-selection"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "options"
  }, /* @__PURE__ */ react.exports.createElement(UI_RadioButtons, {
    options,
    selectedIndex,
    onClick: option_Clicked
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "ok-cancel-buttons"
  }, /* @__PURE__ */ react.exports.createElement("button", {
    className: `app-button-primary`,
    onClick: ok_Clicked
  }, "\u78BA\u5B9A"), /* @__PURE__ */ react.exports.createElement("button", {
    className: "app-button-cancel",
    onClick: cancel_Clicked
  }, "\u30AD\u30E3\u30F3\u30BB\u30EB"))));
}
function UI_FooterOperationPanel({ uiRef }) {
  const edit_CommandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.undo, icon: "undo", title: "\u3082\u3069\u306B\u623B\u3059" },
        { index: MainCommandButtonID.redo, icon: "redo", title: "\u3084\u308A\u306A\u304A\u3057" },
        { index: 9001, icon: "", isSeparator: true },
        { index: MainCommandButtonID.saveFile, icon: "save", title: "\u4FDD\u5B58" },
        { index: 9002, icon: "", isSeparator: true }
      ],
      commandButton_Clicked: (item) => {
        if (uiRef.button_Click) {
          uiRef.button_Click(item.index);
        }
      }
    };
  }, []);
  const view_CommandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.touchOperationPanel, icon: "touchoperationpanel", title: "\u30BF\u30C3\u30C1\u64CD\u4F5C\u30D1\u30CD\u30EB\u306E\u8868\u793A" },
        { index: MainCommandButtonID.layerWindow, icon: "layers", title: "\u30EC\u30A4\u30E4\u30FC\u30D1\u30CD\u30EB\u306E\u8868\u793A" },
        { index: MainCommandButtonID.paletteWindow, icon: "palette", title: "\u30D1\u30EC\u30C3\u30C8\u30D1\u30CD\u30EB\u306E\u8868\u793A" },
        { index: MainCommandButtonID.colorMixerWindow, icon: "colorize", title: "\u30AB\u30E9\u30FC\u30DF\u30AD\u30B5\u30FC\u30D1\u30CD\u30EB\u306E\u8868\u793A" },
        { index: MainCommandButtonID.timeLineWindow, icon: "playcircle", title: "\u30BF\u30A4\u30E0\u30E9\u30A4\u30F3\u30D1\u30CD\u30EB\u306E\u8868\u793A" }
      ],
      commandButton_Clicked: (item) => {
        if (uiRef.button_Click) {
          uiRef.button_Click(item.index);
        }
      }
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    className: `footer-ui-container-left ${uiRef.isForMobile ? "mobile-screen" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: edit_CommandButtonsRef
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: `footer-ui-container-right ${uiRef.isForMobile ? "mobile-screen" : ""}`
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: view_CommandButtonsRef
  })));
}
function UI_HeaderWindow({ uiRef }) {
  const file_CommandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.openFile, icon: "folder", title: "\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u304F" },
        { index: MainCommandButtonID.saveFile, icon: "save", title: "\u4FDD\u5B58" },
        { index: MainCommandButtonID.export, icon: "export", title: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8" },
        { index: MainCommandButtonID.undo, icon: "undo", title: "\u5143\u306B\u623B\u3059" },
        { index: MainCommandButtonID.redo, icon: "redo", title: "\u3084\u308A\u76F4\u3057" }
      ],
      commandButton_Clicked: (item) => {
        if (uiRef.commandButton_Click) {
          uiRef.commandButton_Click(item.index);
        }
      }
    };
  }, []);
  const view_CommandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.layerWindow, icon: "layers" },
        { index: MainCommandButtonID.paletteWindow, icon: "palette" },
        { index: MainCommandButtonID.colorMixerWindow, icon: "colorize" },
        { index: MainCommandButtonID.timeLineWindow, icon: "playcircle" }
      ],
      commandButton_Clicked: (item) => {
        if (uiRef.commandButton_Click) {
          uiRef.commandButton_Click(item.index);
        }
      }
    };
  }, []);
  react.exports.useEffect(() => {
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    className: "file-commands"
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: file_CommandButtonsRef
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "file-name"
  }, /* @__PURE__ */ react.exports.createElement("input", {
    type: "text",
    id: "fileName"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "view-commands"
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: view_CommandButtonsRef
  })));
}
function UI_TimeLineWindow({ uiRef }) {
  const commandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.timeLine_inertKeyframe, icon: "add", title: "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u3092\u633F\u5165" },
        { index: MainCommandButtonID.timeLine_deleteKeyframe, icon: "remove", title: "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u3092\u524A\u9664" },
        { index: MainCommandButtonID.timeLine_moveKeyframe_minus, icon: "arrowleft", title: "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u3092\u524D\u306B\u79FB\u52D5" },
        { index: MainCommandButtonID.timeLine_moveKeyframe_plus, icon: "arrowright", title: "\u30AD\u30FC\u30D5\u30EC\u30FC\u30E0\u3092\u5F8C\u306B\u79FB\u52D5" }
      ],
      commandButton_Clicked: (item) => {
        if (uiRef.commandButton_Clicked) {
          uiRef.commandButton_Clicked(item);
        }
      }
    };
  }, []);
  const onionSkinModeOptions = react.exports.useMemo(() => {
    return [
      { index: OnionSkinMode.disabled, label: "\u975E\u8868\u793A", data: 1 },
      { index: OnionSkinMode.showOnTopLayer, label: "\u524D\u9762\u306B\u8868\u793A", data: 2 },
      { index: OnionSkinMode.showOnLowestLayer, label: "\u80CC\u9762\u306B\u8868\u793A", data: 3 }
    ];
  }, []);
  const [maxFrame, set_maxFrame] = react.exports.useState(0);
  const [loopStartFrame, set_loopStartFrame] = react.exports.useState(0);
  const [loopEndFrame, set_loopEndFrame] = react.exports.useState(0);
  const [selected_OnionSkinModeOptions, set_selected_OnionSkinModeOptions] = react.exports.useState([]);
  const [onionSkinBackwardLevel, set_onionSkinBackwardLevel] = react.exports.useState(0);
  const [onionSkinForwardLevel, set_onionSkinForwardLevel] = react.exports.useState(0);
  react.exports.useEffect(() => {
    uiRef.update = (ctx) => {
      set_maxFrame(ctx.documentData.animationSettingData.maxFrame);
      set_loopStartFrame(ctx.documentData.animationSettingData.loopStartFrame);
      set_loopEndFrame(ctx.documentData.animationSettingData.loopEndFrame);
      set_selected_OnionSkinModeOptions(onionSkinModeOptions.filter((option) => option.data === ctx.documentData.animationSettingData.onionSkinMode));
      set_onionSkinBackwardLevel(ctx.documentData.animationSettingData.onionSkinBackwardLevel);
      set_onionSkinForwardLevel(ctx.documentData.animationSettingData.onionSkinForwardLevel);
    };
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  function spinnerButton_Clicked(index2) {
    uiRef.commandButton_Clicked({ index: index2 });
  }
  function onionSkinModeOptions_Changed(item) {
    if (uiRef.numberInput_Changed && item) {
      uiRef.numberInput_Changed(NumberInputControlID.onionSkinMode, item.data);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-buttons"
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: commandButtonsRef
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-button-group"
  }, /* @__PURE__ */ react.exports.createElement(UI_NumberSpinner, {
    title: "\u6700\u5927\u30D5\u30EC\u30FC\u30E0",
    value: maxFrame,
    buttonIndexs: [
      MainCommandButtonID.timeLine_changeMaxFrame_minus,
      MainCommandButtonID.timeLine_changeMaxFrame_plus
    ],
    onClick: spinnerButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberSpinner, {
    title: "\u30EB\u30FC\u30D7\u958B\u59CB\u30D5\u30EC\u30FC\u30E0",
    value: loopStartFrame,
    buttonIndexs: [
      MainCommandButtonID.timeLine_changeLoopStartFrame_minus,
      MainCommandButtonID.timeLine_changeLoopStartFrame_plus
    ],
    onClick: spinnerButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberSpinner, {
    title: "\u30EB\u30FC\u30D7\u7D42\u4E86\u30D5\u30EC\u30FC\u30E0",
    value: loopEndFrame,
    buttonIndexs: [
      MainCommandButtonID.timeLine_changeLoopEndFrame_minus,
      MainCommandButtonID.timeLine_changeLoopEndFrame_plus
    ],
    onClick: spinnerButton_Clicked
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-button-group"
  }, /* @__PURE__ */ react.exports.createElement(UI_SelectBox, {
    title: "\u30AA\u30CB\u30AA\u30F3\u30B9\u30AD\u30F3",
    selectBoxPopoverRef: uiRef.selectBoxPopoverRef,
    popoberAlign: UI_PopoverContainerAlign.top,
    options: onionSkinModeOptions,
    values: selected_OnionSkinModeOptions,
    onChange: onionSkinModeOptions_Changed
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberSpinner, {
    title: "\u30AA\u30CB\u30AA\u30F3\u30B9\u30AD\u30F3\u8868\u793A\u30EC\u30D9\u30EB\uFF08\u524D\uFF09",
    value: onionSkinBackwardLevel,
    buttonIndexs: [
      MainCommandButtonID.timeLine_changeOnionSkinBackwardLevel_minus,
      MainCommandButtonID.timeLine_changeOnionSkinBackwardLevel_plus
    ],
    onClick: spinnerButton_Clicked
  }), /* @__PURE__ */ react.exports.createElement(UI_NumberSpinner, {
    title: "\u30AA\u30CB\u30AA\u30F3\u30B9\u30AD\u30F3\u8868\u793A\u30EC\u30D9\u30EB\uFF08\u5F8C\uFF09",
    value: onionSkinForwardLevel,
    buttonIndexs: [
      MainCommandButtonID.timeLine_changeOnionSkinForwardLevel_minus,
      MainCommandButtonID.timeLine_changeOnionSkinForwardLevel_plus
    ],
    onClick: spinnerButton_Clicked
  })));
}
function UI_ColorMixerWindow({ uiRef }) {
  const [rgbaValue, setRGBAValue] = react.exports.useState(() => {
    return vec4.fromValues(0, 0, 0, 1);
  });
  const [hsvValue, setHSVValue] = react.exports.useState(() => {
    return vec4.fromValues(0, 0, 0, 0);
  });
  react.exports.useEffect(() => {
    uiRef.update = (color) => {
      const newRGBA = vec4.clone(color);
      setValueFromRGBA(newRGBA);
    };
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  function setValueFromRGBA(newRGBA) {
    const newHSV = vec4.create();
    ColorLogic.rgbToHSVv(newHSV, newRGBA);
    setRGBAValue(newRGBA);
    setHSVValue(newHSV);
    return newRGBA;
  }
  function setValueFromHSV(newHSV) {
    const newRGBA = vec4.clone(rgbaValue);
    ColorLogic.hsvToRGBv(newRGBA, newHSV);
    setRGBAValue(newRGBA);
    setHSVValue(newHSV);
    return newRGBA;
  }
  function ARGB_Changed(index2, value) {
    const newRGBA = vec4.clone(rgbaValue);
    newRGBA[index2] = value;
    const newRGBAValue = setValueFromRGBA(newRGBA);
    if (uiRef.color_Change) {
      uiRef.color_Change(newRGBAValue);
    }
  }
  function HSV_Changed(index2, value) {
    const newHSV = vec4.clone(hsvValue);
    newHSV[index2] = value;
    const newRGBAValue = setValueFromHSV(newHSV);
    if (uiRef.color_Change) {
      uiRef.color_Change(newRGBAValue);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "color-mixer-window"
  }, /* @__PURE__ */ react.exports.createElement("canvas", {
    className: "color-canvas",
    id: "colorMixer_colorCanvas"
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "A",
    trackColor: "#888",
    index: 3,
    value: rgbaValue[3],
    onChange: ARGB_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "R",
    trackColor: "#f55",
    index: 0,
    value: rgbaValue[0],
    onChange: ARGB_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "G",
    trackColor: "#0d0",
    index: 1,
    value: rgbaValue[1],
    onChange: ARGB_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "B",
    trackColor: "#22d",
    index: 2,
    value: rgbaValue[2],
    onChange: ARGB_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "H",
    trackColor: "#dd0",
    index: 0,
    value: hsvValue[0],
    onChange: HSV_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "S",
    trackColor: "#0dd",
    index: 1,
    value: hsvValue[1],
    onChange: HSV_Changed
  }), /* @__PURE__ */ react.exports.createElement(ColorSlider, {
    label: "V",
    trackColor: "#d0d",
    index: 2,
    value: hsvValue[2],
    onChange: HSV_Changed
  }));
}
function ColorSlider({ label, trackColor, index: index2, value, onChange }) {
  react.exports.useRef(null);
  function input_Changed(newValue) {
    if (!onChange) {
      return;
    }
    onChange(index2, newValue);
  }
  function slider_Changed(newValue) {
    if (!onChange) {
      return;
    }
    onChange(index2, newValue);
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "color-mixer-value-slider"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "label-text"
  }, label)), /* @__PURE__ */ react.exports.createElement("div", {
    className: "input",
    style: { borderBottom: `solid 2px ${trackColor}` }
  }, /* @__PURE__ */ react.exports.createElement(UI_NumberInput, {
    digit: 2,
    step: 0.01,
    min: 0,
    max: 1,
    value,
    onChange: input_Changed
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "range"
  }, /* @__PURE__ */ react.exports.createElement(UI_ColorSlider, {
    min: 0,
    max: 1,
    step: 0.01,
    value,
    trackColor,
    onChange: slider_Changed
  })));
}
function UI_LayerWindow({ uiRef }) {
  const [listItems, set_listItem] = react.exports.useState([]);
  const commandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: MainCommandButtonID.layer_addLayer, icon: "add", title: "\u30EC\u30A4\u30E4\u30FC\u3092\u8FFD\u52A0" },
        { index: MainCommandButtonID.layer_deleteLayer, icon: "remove", title: "\u30EC\u30A4\u30E4\u30FC\u3092\u524A\u9664" },
        { index: MainCommandButtonID.layer_moveUp, icon: "arrowup", title: "\u30EC\u30A4\u30E4\u30FC\u3092\u4E0A\u306B\u79FB\u52D5" },
        { index: MainCommandButtonID.layer_moveDown, icon: "arrowdown", title: "\u30EC\u30A4\u30E4\u30FC\u3092\u4E0B\u306B\u79FB\u52D5" }
      ],
      commandButton_Clicked: (item) => {
        uiRef.commandButton_Clicked(item);
      }
    };
  }, []);
  react.exports.useEffect(() => {
    uiRef.update = (items) => {
      set_listItem(items.slice());
    };
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  react.exports.useEffect(() => {
    uiRef.scrollIntoView = (item) => {
      const target_rowItem = listItems.find((rowItem) => rowItem == item);
      if (target_rowItem) {
        target_rowItem.scrollIntoView();
      }
    };
    return function cleanup() {
      uiRef.scrollIntoView = null;
    };
  }, [listItems]);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "layer-window"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-buttons-container"
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: commandButtonsRef
  })), /* @__PURE__ */ react.exports.createElement(UI_ScrollView, {
    wheelScrollY: 15
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "layer-window-items"
  }, listItems.map((rowItem) => /* @__PURE__ */ react.exports.createElement(LayerWindowRow, {
    key: rowItem.index,
    listItem: rowItem,
    uiRef
  })))));
}
function LayerWindowRow({ listItem, uiRef }) {
  const itemElementRef = react.exports.useRef(null);
  react.exports.useEffect(() => {
    listItem.scrollIntoView = () => {
      var _a;
      (_a = itemElementRef.current) == null ? void 0 : _a.scrollIntoView({
        block: "center"
      });
    };
    return function cleanup() {
      listItem.scrollIntoView = () => {
      };
    };
  }, [listItem]);
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: itemElementRef,
    className: `item ${listItem.isCurrentLayer ? "current" : ""} ${listItem.isSelected ? "selected" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "expander",
    style: { paddingLeft: `${listItem.hierarchyDepth * 0.8}rem` },
    onPointerDown: (e) => {
      if (e.button == 0) {
        if (GroupLayer.isGroupLayer(listItem.layer)) {
          uiRef.expander_Clicked(listItem);
        } else {
          uiRef.item_Clicked(listItem);
        }
      }
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "expander-icon"
  }, GroupLayer.isGroupLayer(listItem.layer) && /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: listItem.layer.isListExpanded ? "expandmore" : "expandright"
  }))), /* @__PURE__ */ react.exports.createElement("div", {
    className: "layer-name",
    onPointerDown: (e) => {
      if (e.button == 0) {
        uiRef.item_Clicked(listItem);
      }
    }
  }, listItem.layer.name), /* @__PURE__ */ react.exports.createElement("div", {
    className: "layer-visibility",
    onPointerDown: (e) => {
      if (e.button == 0) {
        uiRef.visibility_Clicked(listItem);
      }
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "visibility-icon"
  }, /* @__PURE__ */ react.exports.createElement(UI_Icon_MaterialIcon, {
    iconName: listItem.isVisible ? "visible" : "invisible"
  }))));
}
function UI_PaletteSelectorWindow({ uiRef }) {
  const [items, setItems] = react.exports.useState([]);
  const commandButtonsRef = react.exports.useMemo(() => {
    return {
      items: [
        { index: PaletteSelectorWindowButtonID.lineColor, icon: "pencil", title: "\u7DDA\u8272" },
        { index: PaletteSelectorWindowButtonID.fillColor, icon: "paint", title: "\u5857\u308A\u8272" },
        { index: PaletteSelectorWindowButtonID.adjustmentMode, icon: "tune", title: "\u73FE\u5728\u306E\u30EC\u30A4\u30E4\u30FC\u306B\u95A2\u4FC2\u306A\u304F\u8ABF\u6574" }
      ],
      commandButton_Clicked: (item) => {
        uiRef.commandButton_Click(item);
      }
    };
  }, []);
  react.exports.useEffect(() => {
    uiRef.update = (items2) => {
      setItems(items2.slice());
    };
    uiRef.setCommandButtonState = (index2, isSelected) => {
      commandButtonsRef.setCommandButtonState(index2, isSelected);
    };
    return function cleanup() {
      uiRef.update = null;
    };
  }, []);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "palette-selector-window"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "command-buttons-container"
  }, /* @__PURE__ */ react.exports.createElement(UI_CommandButtons, {
    uiRef: commandButtonsRef
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "items-container"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "items"
  }, items.map((item, index2) => /* @__PURE__ */ react.exports.createElement(UI_PaletteSelectorItem, {
    key: index2,
    item,
    index: index2,
    uiRef
  })))));
}
function UI_PaletteSelectorItem({ item, index: index2, uiRef }) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "item-container",
    onMouseDown: (e) => {
      if (e.button == 0) {
        uiRef.item_Click(index2, item);
      }
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: `item ${item.isSelected ? "selected" : ""}`
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "alpha alpha-checker-background-pallete"
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "alpha-color",
    style: { backgroundColor: `rgba(${ColorLogic.rgbaToRgbaString(item.color)})` }
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "rgb",
    style: { backgroundColor: `#${ColorLogic.rgbToHex2String(item.color)}` }
  })));
}
function UI_SideBarContainer({ dockingTo, isMobileMode, contents, uiRef }) {
  const [contentInfos, set_contentInfos] = react.exports.useState(contents);
  react.exports.useEffect(() => {
    uiRef.update = () => {
      updateContents();
    };
    uiRef.setContentOpened = (id2, opened) => {
      const contentInfo = getContentInfo(id2);
      setContentOpened(contentInfo, opened);
    };
    uiRef.isContentOpened = (id2) => {
      var _a;
      const contentInfo = getContentInfo(id2);
      return (_a = contentInfo.isOpened) != null ? _a : false;
    };
    uiRef.toggleVisibility = (id2) => {
      const contentInfo = getContentInfo(id2);
      tab_Clicked(contentInfo);
    };
    return function cleanup() {
      uiRef.update = null;
      uiRef.toggleVisibility = null;
      uiRef.setContentOpened = null;
    };
  }, []);
  function leftRightClass() {
    return dockingTo == "left" ? "left-panel" : "right-panel";
  }
  function closedClass(contentInfo) {
    return !contentInfo.isOpened ? "closed" : "";
  }
  function getContentInfo(id2) {
    return contents.find((ct) => ct.id == id2);
  }
  function setContentOpened(contentInfo, open) {
    contentInfo.isOpened = open;
  }
  function updateContents() {
    set_contentInfos(contentInfos.slice());
  }
  function tab_Clicked(contentInfo) {
    const contendOpened = !contentInfo.isOpened;
    setContentOpened(contentInfo, !contentInfo.isOpened);
    updateContents();
    if (contendOpened) {
      if (uiRef.onContentOpened) {
        uiRef.onContentOpened(contentInfo);
      }
    } else {
      if (uiRef.onContentClosed) {
        uiRef.onContentClosed(contentInfo);
      }
    }
  }
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    className: `side-panel-tabs ${contents.length == 0 ? " hidden" : ""} ${isMobileMode ? "hidden" : ""}`
  }, contentInfos.map(
    (contentInfo) => /* @__PURE__ */ react.exports.createElement("div", {
      key: contentInfo.key,
      className: `side-panel-tab ${leftRightClass()} ${closedClass(contentInfo)}`,
      onPointerDown: () => tab_Clicked(contentInfo)
    }, /* @__PURE__ */ react.exports.createElement("i", {
      className: "material-icons"
    }, contentInfo.icon))
  )), /* @__PURE__ */ react.exports.createElement("div", {
    className: `side-panel-contents ${leftRightClass()} ${isMobileMode ? "mobile-screen" : ""}`
  }, contentInfos.map(
    (contentInfo) => /* @__PURE__ */ react.exports.createElement("div", {
      key: contentInfo.key,
      className: `side-panel-content ${leftRightClass()} ${closedClass(contentInfo)}`
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: `content-container ${leftRightClass()}`
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: `content-inner-container ${closedClass(contentInfo)}`
    }, /* @__PURE__ */ react.exports.createElement(contentInfo.component, {
      uiRef: contentInfo.uiRef
    }))))
  )));
}
let _Main;
window.onload = () => {
  loadSetings().then(() => {
    initializeMain();
    setTimeout(run, 1e3 / 30);
  });
};
async function loadSetings() {
  const currentDirectoryPath = await Platform.fileSystem.getUserDefaultDocumentDirectory();
  const localSetting = {
    currentDirectoryPath,
    referenceDirectoryPath: "./test",
    exportPath: "./",
    autoNumberingEnabled: false,
    maxLastUsedFilePaths: 10,
    lastUsedFilePaths: [
      "./test/test01-app-demo.v.ora",
      "./test/test02-eyes-symmetry-colored.v.ora"
    ],
    fileSections: [],
    uiStates: UserUIStateLogic.createDefaultUIStates(),
    shortcutKeySettings: []
  };
  const defaultUserStrageData = {
    version: "0.1.1",
    [UserSettingFileLogic.localStorage_ActiveSettingNameKey]: "setting1",
    setting1: localSetting
  };
  await UserStorage.load(defaultUserStrageData);
}
function initializeMain() {
  _Main = new App_Main();
  _Main.appView.mainWindow.attachCanvas(document.getElementById(_Main.appView.dom.ID.mainCanvas));
  _Main.appView.editorWindow.attachCanvas(document.getElementById(_Main.appView.dom.ID.editorCanvas));
  _Main.appView.webglWindow.attachCanvas(document.getElementById(_Main.appView.dom.ID.webglCanvas));
  _Main.appView.timeLineWindow.canvasWindow.attachCanvas(document.getElementById(_Main.appView.dom.ID.timeLineCanvas));
  const ua2 = navigator.userAgent;
  _Main.appView.isForMobile = ua2.indexOf("iPhone") > 0 || ua2.indexOf("iPad") > 0 || ua2.indexOf("Android") > 0 || ua2.indexOf("Mobile") > 0;
  _Main.appView.footerWindow.uiFooterOperationpanelRef.isForMobile = _Main.appView.isForMobile;
  _Main.appView.setMobileMode();
  reactDom.exports.render(
    react.exports.createElement(UI_HeaderWindow, { uiRef: _Main.appView.headerWindow.uiHeaderWindowRef }),
    document.getElementById(_Main.appView.dom.ID.header)
  );
  reactDom.exports.render(
    react.exports.createElement(UI_RibbonUI, {
      uiRef: _Main.appView.ribbonUIWindow.uiRibbonUIRef,
      subToolWindowRef: _Main.appView.subToolWindow.uiSubToolWindowRef
    }),
    document.getElementById(_Main.appView.dom.ID.ribbonUI)
  );
  reactDom.exports.render(
    react.exports.createElement(UI_FooterOperationPanel, {
      uiRef: _Main.appView.footerWindow.uiFooterOperationpanelRef
    }),
    document.getElementById(_Main.appView.dom.ID.footerUI)
  );
  reactDom.exports.render(
    react.exports.createElement(
      UI_SideBarContainer,
      {
        dockingTo: "left",
        isMobileMode: _Main.appView.isForMobile,
        contents: [],
        uiRef: _Main.appView.left_SideBarContainerRef
      }
    ),
    document.getElementById(_Main.appView.dom.ID.leftSidePanel)
  );
  reactDom.exports.render(
    react.exports.createElement(
      UI_SideBarContainer,
      {
        dockingTo: "right",
        isMobileMode: _Main.appView.isForMobile,
        contents: [
          { key: 1, id: SideBarContentID.layerWindow, component: UI_LayerWindow, uiRef: _Main.appView.layerWindow.uiRef, icon: "layers", isOpened: false },
          { key: 2, id: SideBarContentID.paletteWindow, component: UI_PaletteSelectorWindow, uiRef: _Main.appView.paletteSelectorWindow.uiRef, icon: "palette", isOpened: false },
          { key: 3, id: SideBarContentID.colorMixerWindow, component: UI_ColorMixerWindow, uiRef: _Main.appView.colorMixerWindow.uiRef, icon: "colorize", isOpened: false }
        ],
        uiRef: _Main.appView.right_SideBarContainerRef
      }
    ),
    document.getElementById(_Main.appView.dom.ID.rightSidePanel)
  );
  reactDom.exports.render(
    react.exports.createElement(UI_TimeLineWindow, { uiRef: _Main.appView.timeLineWindow.uiTimeLineWindowRef }),
    document.getElementById("time-line-ui")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_PopoverRouter, {
      mainMenuUIRef: _Main.appView.popover.mainMenuUIRef,
      brushPropertyBoxRef: _Main.appView.popover.brushPropertyBoxRef,
      selectBoxRef: _Main.appView.popover.selectBoxPopoverRef
    }),
    document.getElementById("popover-dock-container")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_Modal_RadioSelection, { uiRef: _Main.appView.modalWindow.uiRadioSelectionRef }),
    document.getElementById("modal-radio-selection")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_Modal_ImageFileReference, { uiRef: _Main.appView.modalWindow.uiImageFileReferenceRef }),
    document.getElementById("modal-image-file-ref")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_Modal_ExportImage, { uiRef: _Main.appView.modalWindow.uiExportImageRef }),
    document.getElementById("modal-export-image")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_Dialog_DocumentFiler, { uiRef: _Main.appView.dialogScreen.uiDocumentFilerRef }),
    document.getElementById("dialog-document-filer")
  );
  reactDom.exports.render(
    react.exports.createElement(UI_Dialog_ShortcutKeys, { uiRef: _Main.appView.dialogScreen.uiShortcutKeysRef }),
    document.getElementById("dialog-shortcut-keys")
  );
  _Main.appView.colorMixerWindow.colorCanvas.canvas = document.getElementById(_Main.appView.dom.ID.colorMixerWindow_colorCanvas);
  _Main.onInitializeSystemDevices();
}
function run() {
  try {
    if (_Main.mainProcessState == MainProcessStateID.pause) {
      setTimeout(run, 1e3);
      return;
    } else if (_Main.mainProcessState == MainProcessStateID.running) {
      _Main.run();
      _Main.draw();
    } else if (_Main.mainProcessState == MainProcessStateID.systemResourceLoading) {
      _Main.processLoadingSystemResources();
    } else if (_Main.mainProcessState == MainProcessStateID.documentJSONLoading) {
      _Main.processLoadingDocumentFile();
    } else if (_Main.mainProcessState == MainProcessStateID.documentResourceLoading) {
      _Main.processLoadingDocumentResources();
    }
    if (_Main.docContext != null && _Main.docContext.animationPlaying) {
      setTimeout(run, 1e3 / _Main.docContext.animationPlayingFPS);
    } else {
      window.requestAnimationFrame(run);
    }
  } catch (e) {
    console.log(e);
    setTimeout(run, 1e3);
  }
}
//# sourceMappingURL=index.js.map
